<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Beat Board</title>
<style>
    :root{
      --bgp-size: 80px;
      --bgp-fill: rgba(255,255,255,0.06);

      --bg: #0f1115;
      --grid: rgba(255,255,255,0.06);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;

      /* Preset palette */
      --act1: #7bce76;  /* green */
      --act2: #78beff;  /* blue */
      --act3: #ff818d;  /* red */
      --neutral: #c9c9c9;

      --cardW: 335px;
      --cardH: 220px;   /* will be auto-updated by JS based on tallest card */
    }

    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    * { box-sizing: border-box; }

    /* Top bar */
    .topbar{
      position: fixed;
      left: 14px; right: 14px; top: 12px;
      display: flex; gap: 10px; align-items: center; justify-content: space-between;
      z-index: 10;
      pointer-events: none;
    }
    .panel{
      pointer-events: auto;
      display: flex; gap: 10px; align-items: center;
      background: rgba(18,20,26,0.85);
      border: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(10px);
      padding: 10px 12px;
      border-radius: 14px;
      box-shadow: var(--shadow);
    }

    /* Menu bar (File / Edit / View) */
    .menubar{
      justify-content: space-between;
      width: fit-content;
      gap: 14px;
      flex-wrap: nowrap;
    }
    .menus{
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap: nowrap;
    }
    .menu{ position: relative; }
    .menuBtn{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 750;
      letter-spacing: 0.2px;
    }
    .menuBtn:hover{ background: rgba(255,255,255,0.08); }
    .menuBtn[aria-expanded="true"]{
      background: rgba(255,255,255,0.10);
      border-color: rgba(255,255,255,0.18);
    }

    .menuDropdown{
      position:absolute;
      top: calc(100% + 10px);
      left: 0;
      min-width: 230px;
      display:none;
      background: rgba(18,20,26,0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 6px;
      backdrop-filter: blur(10px);
      z-index: 50;
    }
    .menuDropdown.open{ display:block; }

    .menuItem{
      width: 100%;
      text-align:left;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 10px;
      border-radius: 12px;
      cursor: pointer;
      color: rgba(255,255,255,0.92);
      font-weight: 650;
      font-size: 13px;
      background: transparent;
      border: 1px solid transparent;
    }
    .menuItem:hover{ background: rgba(255,255,255,0.08); }
    .menuItem.danger:hover{ background: rgba(255,90,90,0.16); border-color: rgba(255,90,90,0.22); }

    .menuSep{
      height: 1px;
      margin: 6px 6px;
      background: rgba(255,255,255,0.10);
      border-radius: 999px;
    }

    /* Grid toggle */
    #board.gridOff{
      background: none !important;
    }

    /* Locked cards (prevents dragging) */
    .card.locked::before{
      content: "ðŸ”’";
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 12px;
      opacity: 0.28;
      pointer-events: none;
      filter: grayscale(1);
    }

    /* Presentation mode */
    body.bbPresent .topbar{ display:none !important; }
    body.bbPresent #board{ background: none !important; }


    /* Topbar stays in one row on smaller widths */
    @media (max-width: 720px){
      .menuBtn{ padding: 8px 9px; }
      .menuDropdown{ min-width: 210px; }
    }
    .brand{
      font-weight: 650;
      letter-spacing: 0.2px;
      display:flex; align-items:center; gap:10px;
    }
    .dot{ width:10px; height:10px; border-radius:999px; background: var(--act1); box-shadow: 0 0 0 3px rgba(155,191,126,0.18); }

    button{
      appearance: none;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.10);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
    }
    button:hover{ background: rgba(255,255,255,0.10); }
    button:active{ transform: translateY(1px); }

    .hint{
      font-size: 12px;
      color: var(--muted);
      line-height: 1.25;
      max-width: 680px;
    }
    .kbd{
      display:inline-block;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.06);
      font-weight: 700;
      font-size: 11px;
      margin: 0 2px;
      color: rgba(255,255,255,0.9);
    }

    /* Board */
    #viewport{
      position: fixed;
      inset: 0;
      overflow: hidden;
      cursor: grab;
    
      touch-action: none;
    }
#viewport:active{ cursor: grabbing; }

    #board{
      position: absolute;
      left: 0; top: 0;
      width: 6000px;
      height: 4000px;
      transform-origin: 0 0;
      background:
        linear-gradient(var(--grid) 1px, transparent 1px) 0 0 / 60px 60px,
        linear-gradient(90deg, var(--grid) 1px, transparent 1px) 0 0 / 60px 60px;
    }

    /* Cards */
    .card{
      position: absolute;
      z-index: 2;
      width: var(--cardW);
      height: var(--cardH);
      padding: 14px 14px 44px 14px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border: 1px solid rgba(0,0,0,0.25);
      user-select: none;
      overflow: hidden;
    }
    
    
    /* Resize handle (bottom-right) for standard cards */
.card .resizeHandle{
  position: absolute;
  right: 6px;
  bottom: 6px;
  width: 22px;
  height: 22px;
  cursor: nwse-resize;
  display: none;
  touch-action: none;
  z-index: 5;

  /* Rounded triangle handle (no grip lines) */
  background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path d='M24 4 Q24 0 21.172 2.828 L2.828 21.172 Q0 24 4 24 L20 24 Q24 24 24 20 L24 4 Z' fill='%23ffffff' fill-opacity='0.22' stroke='%23000000' stroke-opacity='0.35' stroke-width='1.2' stroke-linejoin='round'/></svg>") no-repeat center / 100% 100%;
  filter: drop-shadow(0 2px 6px rgba(0,0,0,0.30));
  opacity: 0.95;
}
.card .resizeHandle::before,
.card .resizeHandle::after{
  content: none;
}
.card.selected .resizeHandle,
.card.multiSelected .resizeHandle{
  display: block;
}

.card.imageCard{
      /* Always-slim frame: keep padding minimal regardless of size */
      padding: 2px;
      /* Image cards have their own sizing; don't inherit the global card box */
      width: auto;
      height: auto;
      background: transparent;
    }
    .card.imageCard .title{ display:none; }
    .card.imageCard .body{
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      flex-direction: column;
    }
    .card.imageCard img{
      -webkit-user-drag: none;
      user-drag: none;
      user-select: none;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: calc(var(--radius) - 4px);
      display:block;
    }
    .card.imageCard .imgCaption{
      display: none; /* keep image cards clean; can add a toggle later */
      font-size: 12px;
      opacity: 0.85;
      text-align: center;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      width: 100%;
    }

    /* Image card resize handle (bottom-right) */
.card.imageCard .resizeHandle{
  position: absolute;
  right: 6px;
  bottom: 6px;
  width: 18px;
  height: 18px;
  cursor: nwse-resize;
  display: none;
  touch-action: none;

  background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path d='M24 4 Q24 0 21.172 2.828 L2.828 21.172 Q0 24 4 24 L20 24 Q24 24 24 20 L24 4 Z' fill='%23ffffff' fill-opacity='0.22' stroke='%23000000' stroke-opacity='0.35' stroke-width='1.2' stroke-linejoin='round'/></svg>") no-repeat center / 100% 100%;
  filter: drop-shadow(0 2px 6px rgba(0,0,0,0.30));
  opacity: 0.95;
}

.card.selected .resizeHandle,
    .card.multiSelected .resizeHandle{
      display: block;
    }
/* Temporary groups (lightweight, non-hierarchical) */
    .groupHalo{
      position:absolute;
      z-index: 1;
      border-radius: 22px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.14);
      pointer-events: auto;
      cursor: grab;
    }


    .groupLabel{
      position:absolute;
      z-index: 12;
      padding: 4px 8px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 750;
      letter-spacing: 0.2px;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.18);
      color: rgba(255,255,255,0.92);
      pointer-events: none;
      user-select: none;
      white-space: nowrap;
      transform: translateY(-8px);
    }

    /* Clickable folder drag frame (doesn't block cards inside) */
    .groupFrame{
      position:absolute;
      z-index: 10;
      pointer-events: none; /* parts enable events */
      border-radius: 22px;
    }
    .groupFramePart{
      position:absolute;
      pointer-events: auto;
      cursor: grab;
      background: transparent;
    }
    .card.groupTarget{
      outline: 2px solid rgba(255,255,255,0.55);
      outline-offset: -2px;
      animation: bbJiggle 0.22s ease-in-out infinite alternate;
      transform-origin: 50% 50%;
    }
    @keyframes bbJiggle{
      from{ transform: scale(1); }
      to{ transform: scale(1.015); }
    }


    .card .title{
      font-weight: 800;
      font-size: 13px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
      opacity: 0.95;
      margin-bottom: 10px;
      color: rgba(0,0,0,0.86);
      padding-right: 32px; /* room for color button */
    }

    .card .body{
      font-size: 13px;
      line-height: 1.35;
      color: rgba(0,0,0,0.84);
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* subtle fade at bottom for overflow */
    .card::after{
      content:"";
      position:absolute;
      left:0; right:0; bottom:0;
      height: 40px;
      pointer-events:none;
      background: linear-gradient(transparent, rgba(0,0,0,0.12));
      opacity: 0.35;
    }

    .card.selected,
    .card.multiSelected{
      outline: 3px solid rgba(255,255,255,0.75);
      outline-offset: 3px;
    }

    .card.selected{
      outline: 4px solid rgba(255,255,255,0.9);
    }

    /* Preset background classes */
    .act1{ background: var(--act1); }
    .act2{ background: var(--act2); }
    .act3{ background: var(--act3); }
    .neutral{ background: var(--neutral); }

    /* Card color button (top-right, subtle) */
    .colorBtn{
      display:none !important;

      position:absolute;
      top: 10px;
      right: 10px;
      width: 18px;
      height: 18px;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,0.25);
      background: rgba(255,255,255,0.18);
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,0.18);
    }
    .colorBtn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.25);
    }

    /* Color popover */
    .popover{
      display:none !important;

      position: fixed;
      z-index: 30;
      background: rgba(18,20,26,0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 10px;
      width: 220px;
      display: none;
      backdrop-filter: blur(10px);
    }
    .popover h4{
      margin: 0 0 8px 0;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.25px;
      color: rgba(255,255,255,0.78);
    }
    .popover .row{
      display:flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    .chip{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 11px;
      font-weight: 800;
      padding: 7px 8px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.9);
      cursor: pointer;
      user-select: none;
    }
    .chip:hover{ background: rgba(255,255,255,0.10); }
    .swatches{
      display:flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .swatch{
      width: 20px;
      height: 20px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.20);
      cursor: pointer;
    }
    .swatch.active{
      outline: 3px solid rgba(255,255,255,0.80);
      outline-offset: 2px;
    }
    .colorRow{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-top: 10px;
    }
    input[type="color"]{
      width: 44px;
      height: 34px;
      padding: 0;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: transparent;
      cursor: pointer;
    }
    .smallMuted{
      font-size: 11px;
      color: rgba(255,255,255,0.65);
      line-height: 1.2;
    }

    /* Editor modal */
    .modalOverlay{
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    .modal{
      width: min(780px, calc(100% - 26px));
      background: rgba(18,20,26,0.95);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      padding: 14px;
      box-shadow: var(--shadow);
    }
    .modal header{
      display:flex; align-items:center; justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    /* Folder settings overlay (compact + realtime) */
    .folderModal{ padding: 8px 12px 10px; }
    .folderHdr{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 4px;
    }
    .folderHdrTitle{ font-weight:800; letter-spacing:0.2px; }
    .folderForm{ display:flex; flex-direction:column; gap:8px; }
    .folderRow{ display:flex; gap:8px; align-items:center; }
    .folderLbl{ width:120px; opacity:0.8; }
    
    .folderRecentWrap{ display:flex; flex-direction:column; gap:6px; }
    .folderRecentTitle{ font-size: 12px; opacity:0.85; }
    .folderRecentGrid{ margin-top: 0; gap: 10px; }

.folderTextInput{
      flex:1;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      color: rgba(255,255,255,0.92);
      padding: 0 10px;
      outline: none;
    }
    .folderTextInput:focus{ border-color: rgba(255,255,255,0.28); box-shadow: 0 0 0 3px rgba(255,255,255,0.08); }
    .folderChk{ display:flex; align-items:center; gap:8px; opacity:0.85; font-size:12px; white-space:nowrap; }
    .folderHelpRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .folderHelp{ opacity:0.65; font-size:12px; }
    .folderColorChip{
      width: 22px;
      height: 22px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.18);
    }
    .folderColorPicker{
      width: 46px;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      padding: 0;
      cursor: pointer;
    }
    .folderPct{ width:54px; text-align:right; opacity:0.85; font-size:12px; font-variant-numeric: tabular-nums; }
    .folderActions{ display:flex; justify-content:flex-end; margin-top:2px; }

    /* Folder settings: tighter spacing + cleaner layout */
    .folderModal{ padding: 8px 12px 10px !important; }
    .folderModal{ padding-top: 8px !important; }
    .folderHdr{ margin-bottom: 4px; }
    .folderHdrTitle{ font-size: 13px; }
    .folderForm{ gap: 8px; }
    .folderRow{ gap: 8px; }
    .folderLbl{ width: 92px; }
    .folderTextInput{ height: 32px; border-radius: 11px; }
    .folderChk{ font-size: 12px; }
    .folderModal .tabsColorGrid{ gap: 10px; }
    .folderModal .customPickerPanel{ margin-top: 6px; padding-top: 6px; }
    .folderModal .customPickerHdr{ margin-bottom: 6px; }
    .folderModal .folderHelp{ display:none !important; }


    .hdrRight{
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .hdrRight select{
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 8px 10px;
      font-size: 13px;
      outline: none;
      cursor: pointer;
    }
    .hdrRight input[type="color"]{
      width: 42px;
      height: 34px;
      padding: 0;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: transparent;
      cursor: pointer;
      display:none; /* only for Custom */
    }
    .modal header h2{
      margin: 0;
      font-size: 14px;
      letter-spacing: 0.2px;
    }
    input[type="text"]{
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 10px 10px;
      font-size: 13px;
      outline: none;
      margin-bottom: 10px;
    }
    textarea{
      width: 100%;
      min-height: 300px;
      resize: vertical;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.35;
      outline: none;
    }

    /* Context menu */
    .ctx{
      position: fixed;
      z-index: 40;
      display: none;
      min-width: 200px;
      background: rgba(18,20,26,0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 6px;
      backdrop-filter: blur(10px);
    }
    .ctxItem{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 10px;
      border-radius: 12px;
      cursor: pointer;
      color: rgba(255,255,255,0.92);
      font-weight: 650;
      font-size: 13px;
    }
    .ctxItem:hover{ background: rgba(255,255,255,0.08); }
    .ctxSep{
      height: 0;
      border-top: 1px solid rgba(255,255,255,0.12);
      margin: 6px 0;
    }

    .ctxKey{
      font-size: 11px;
      color: rgba(255,255,255,0.55);
      font-weight: 750;
    }

    @media (max-width: 720px){
      .hint{ display:none; }
      :root{ --cardW: 300px; }
    }
  
    /* Editor colour picker (stable, minimal) */
    .editColorWrap{ position: relative; }
    .editColorBtn{
      display:flex; align-items:center; gap:8px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 0.2px;
    }
    .editColorDot{
      width: 14px; height: 14px; border-radius: 6px;
      border: 1px solid rgba(0,0,0,0.25);
      box-shadow: 0 8px 18px rgba(0,0,0,0.18);
      background: #c9c9c9;
      display:inline-block;
    }
    .editColorMenu{
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      width: 270px;
      background: rgba(18,20,26,0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 10px;
      display: none;
      z-index: 25;
      backdrop-filter: blur(10px);
    }
    .editColorRow{
      display:grid;
      grid-template-columns: repeat(6, 22px);
      grid-auto-rows: 22px;
      gap: 10px;
      margin-bottom: 12px;
      justify-content: start;
      align-content: start;
    }
    .editSwatch{
      width: 22px;
      height: 22px;
      border-radius: 9px;
      border: 1px solid rgba(255,255,255,0.20);
      cursor: pointer;
      position: relative;
    }
    .editSwatch.active{
      outline: 3px solid rgba(255,255,255,0.80);
      outline-offset: 2px;
    }
    .editColorBottom{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
    }
    .editColorLabel{
      font-size: 11px;
      color: rgba(255,255,255,0.70);
      font-weight: 750;
      letter-spacing: 0.2px;
    }
    .editColorClear{
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      padding: 8px 10px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
      font-size: 12px;
      white-space: nowrap;
    }
    .editColorClear:hover{ background: rgba(255,255,255,0.10); }


    /* Editor colour bar (top strip) */
    .modal{ position: relative; overflow: hidden; }
    .editColorBar{
      position: absolute;
      left: 0; right: 0; top: 0;
      height: 52px;
      background: #c9c9c9;
      border-radius: 18px 18px 0 0;
      box-shadow: 0 10px 24px rgba(0,0,0,0.22);
    }
    /* Put header controls on top of the colour bar */
    .modal header{
      position: relative;
      z-index: 2;
      background: transparent;
      border: none;
      margin: 0;
      height: 52px;
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      box-sizing: border-box;
    }
    .modal header h2{
      color: rgba(0,0,0,0.78);
      text-shadow: 0 1px 0 rgba(255,255,255,0.12);
    }
    .hdrRight button, .hdrRight select{
      background: rgba(0,0,0,0.12);
      border: 1px solid rgba(0,0,0,0.18);
      color: rgba(0,0,0,0.80);
    }
    .hdrRight button:hover, .hdrRight select:hover{
      background: rgba(0,0,0,0.16);
    }
    .editColorBtn{
      background: rgba(0,0,0,0.12);
      border: 1px solid rgba(0,0,0,0.18);
      color: rgba(0,0,0,0.80);
    }

    .modal{ padding: 14px; }

    /* Micro alignment nudge: pull fields up slightly */
    
    


    /* Final alignment fix: center header content */
    :root{
      --editorBarH: 44px;
    }

    .editColorBar{
      height: var(--editorBarH);
    }

    .modal header{
      height: var(--editorBarH);
      padding: 0 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    /* Remove extra top spacing from fields entirely */
    .modal input[type="text"],
    .modal textarea{
      margin-top: 0;
    }


    /* --- Header centering override (fix misalignment) --- */
    :root{ --editorBarH: 52px; --editorCtrlH: 34px; }

    .editColorBar{ height: var(--editorBarH) !important; }

    .modal header{
      height: var(--editorBarH) !important;
      padding: 0 14px !important;
      display:flex !important;
      align-items:center !important;
      justify-content: space-between !important;
    }

    .modal header h2{
      margin: 0 !important;
      height: var(--editorCtrlH) !important;
      display:flex !important;
      align-items:center !important;
      line-height: 1 !important;
    }

    .hdrRight{
      display:flex !important;
      align-items:center !important;
      gap: 10px !important;
    }

    /* Force all header buttons (Colour + Save) to the same height */
    .hdrRight button,
    .hdrRight select,
    .editColorBtn{
      height: var(--editorCtrlH) !important;
      padding: 0 14px !important;
      display:flex !important;
      align-items:center !important;
      justify-content:center !important;
      line-height: 1 !important;
      border-radius: 999px !important;
    }

    /* Ensure the little colour dot is vertically centered too */
    .editColorDot{
      width: 14px !important;
      height: 14px !important;
      border-radius: 7px !important;
    }


    /* --- Absolute centering fix (final) --- */
    :root{
      --editorBarH: 52px;
    }

    .editColorBar{
      height: var(--editorBarH) !important;
    }

    /* Turn header into a grid pinned to the bar */
    .modal header{
      position: absolute !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      height: var(--editorBarH) !important;
      display: grid !important;
      grid-template-columns: 1fr auto !important;
      align-items: center !important;
      padding: 0 14px !important;
      pointer-events: auto !important;
    }

    /* Left title */
    .modal header h2{
      margin: 0 !important;
      display: flex !important;
      align-items: center !important;
      height: 100% !important;
      line-height: 1 !important;
    }

    /* Right controls */
    .hdrRight{
      display: flex !important;
      align-items: center !important;
      height: 100% !important;
      gap: 10px !important;
    }

    .hdrRight > *{
      display: flex !important;
      align-items: center !important;
      height: 32px !important;
      padding: 0 14px !important;
      line-height: 1 !important;
      border-radius: 999px !important;
    }

    /* Push editor body below bar cleanly (editor modal only) */
    .modal.editorModal{
      padding-top: calc(var(--editorBarH) + 12px) !important;
    }


    /* Remove 'Edit' label from editor header */
    .modal header h2{
      display: none !important;
    }


    /* Right-align editor header controls */
    .modal header{
      grid-template-columns: 1fr auto !important;
    }

    .hdrRight{
      margin-left: auto !important;
      justify-content: flex-end !important;
    }


    /* Remove Save & Close button (auto-save on blur) */
    #btnCloseModal{
      display: none !important;
    }


    /* Minimal editor header button */
    .hdrBtn{
      height: 32px;
      padding: 0 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.10);
      color: #fff;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }
    .hdrBtn:hover{ background: rgba(0,0,0,0.18); }


    /* Rich editor body (contenteditable) */
    #editBody[contenteditable="true"]{
      width: 100%;
      min-height: 260px;
      resize: vertical;
      padding: 12px;
      border-radius: 14px;
      outline: none;
      white-space: pre-wrap;
      overflow: auto;

      /* Visible writing field (so you always know where you're typing) */
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.16);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.10), inset 0 0 0 1px rgba(0,0,0,0.12);
    }

    

    /* Ensure text cursor in all text fields (avoid hand/grab cursor while editing) */
    input[type="text"],
    input[type="search"],
    textarea,
    [contenteditable="true"]{
      cursor: text;
    }
/* Focus state for the writing field */
    #editBody[contenteditable="true"]:focus{
      border-color: rgba(255,255,255,0.30);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.12), 0 0 0 3px rgba(255,255,255,0.10);
    }

    /* Placeholder (handled via data-empty from JS so it also works with <br>) */
    #editBody[data-empty="true"]::before{
      content: attr(data-placeholder);
      color: rgba(255,255,255,0.45);
      pointer-events: none;
    }
    /* Make bold actually appear */
    #editBody b, #editBody strong{ font-weight: 800; }


    /* SHIFT+drag pan cursor (apply to viewport/board so it overrides their own cursor rules) */
body.bbShiftPan #viewport,
body.bbShiftPan #board{ cursor: grab; }

body.bbShiftPanning #viewport,
body.bbShiftPanning #board{ cursor: grabbing; }

/* Fallback (rare): if viewport isn't the hovered element */
body.bbShiftPanning{ cursor: grabbing; }


    .card.multiSelected{
      outline: 2px solid rgba(255,255,255,0.90);
      box-shadow: 0 0 0 4px rgba(255,255,255,0.14);
    }
    body.bbSelecting{ user-select:none; cursor: crosshair; }


    /* --- Locked cards (can't be dragged) --- */
    .card.locked{
      cursor: default;
    }
    .card.locked::before{
      content:"ðŸ”’";
      position:absolute;
      top: 10px;
      right: 10px;
      font-size: 13px;
      line-height: 1;
      opacity: 0.85;
      pointer-events:none;
      filter: none;
      text-shadow:
        0 1px 0 rgba(255,255,255,0.35),
        0 0 2px rgba(0,0,0,0.45);
    }



    /* --- Editor header buttons should NOT inherit card colour --- */
    .modal header .hdrBtn,
    .modal header .editColorBtn{
      background: rgba(255,255,255,0.75) !important;
      color: rgba(0,0,0,0.85) !important;
      border: 1px solid rgba(0,0,0,0.2) !important;
      backdrop-filter: none !important;
    }
    .modal header .hdrBtn:hover,
    .modal header .editColorBtn:hover{
      background: rgba(255,255,255,0.9) !important;
    }


    /* --- Editor: recent colours --- */
    .editRecentWrap{
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    .editRecentLabel{
      font-size: 11px;
      color: rgba(255,255,255,0.70);
      margin-bottom: 6px;
      user-select: none;
    }
    .editRecentRow{
      display:grid;
      grid-template-columns: repeat(6, 22px);
      grid-auto-rows: 22px;
      gap: 10px;
      justify-content: start;
      align-content: start;
    }


    /* --- In-app custom colour picker (styled) --- */
    .customPickerPanel{
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255,255,255,0.10);
    }
    .customPickerHdr{
      display:flex;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 10px;
    }
    .customPickerTitle{
      font-size: 12px;
      color: rgba(255,255,255,0.85);
      user-select:none;
    }
    .customPickerGrid{
      display:flex;
      gap: 12px;
      align-items:flex-start;
    }
    .svCanvas{
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
      cursor: crosshair;
      background: #000;
    }
    .customPickerSide{
      display:flex;
      flex-direction:column;
      gap: 10px;
      width: 120px;
    }
    .hueSlider{
      width: 120px;
    }
    .customPreview{
      width: 120px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.25);
      background: #4aa3ff;
    }
    .hexInput{
      width: 120px;
      height: 34px;
      border-radius: 12px;
      padding: 0 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.88);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      outline: none;
    }
    .hexInput:focus{
      border-color: rgba(255,255,255,0.28);
      background: rgba(255,255,255,0.10);
    }
    .customPickerBtns{
      display:flex;
      gap: 8px;
      justify-content:space-between;
    }
    .customPickerBtns .hdrBtn{
      flex:1;
    }


    /* --- Custom picker compact fit --- */
    .customPickerGrid{
      flex-direction: column;
      gap: 10px;
    }
    .customPickerSide{
      width: 100%;
      flex-direction: row;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .hueSlider{
      width: 100%;
    }
    .customPreview{
      width: 94px;
      height: 32px;
      border-radius: 10px;
    }
    .hexInput{
      width: 120px;
      height: 32px;
      border-radius: 10px;
    }
    .customPickerBtns{
      width: 100%;
    }


    /* --- Allow colour dropdown to extend outside editor (no forced scroll) --- */
    .modal,
    .modal header,
    .modal .hdrRight,
    .editColorWrap{
      overflow: visible !important;
    }
    .editColorMenu{
      max-height: none !important;
      overflow: visible !important;
    }


    /* --- Hide unwanted colour menu controls (keep DOM so JS doesn't break) --- */
    #editColorClear{ display:none !important; }
    #customPickerClose{ display:none !important; }
    #tabsCustomPickerClose{ display:none !important; }
    #customPickerSystem{ display:none !important; }

    /* Tighten header when close button hidden */
    .customPickerHdr{ justify-content:flex-start; }


    /* --- Live colour updates: hide Apply button --- */
    #customPickerApply{ display:none !important; }


    /* --- Card heading as subtle "tab" --- */
    .card .title{
      position: relative;
      display: block;
      font-weight: 800;
      letter-spacing: 0.2px;
      margin: -14px -14px 12px -14px; /* reach card edges (matches card padding) */
      padding: 14px 16px 12px 16px;
      border-top-left-radius: var(--radius);
      border-top-right-radius: var(--radius);
      background: rgba(0,0,0,0.10);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.16),
        inset 0 -1px 0 rgba(0,0,0,0.18);
    }
    
    /* Keep body spacing consistent after header becomes a strip */
    .card .body{
      margin-top: 0;
    }


    /* --- Fix: uniform divider opacity under card title --- */
    .card .title::after{
      content:"";
      position:absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 1px;
      background: rgba(0,0,0,0.22);
      opacity: 0.6;
    }


    /* --- Blank cards (no header) --- */
    .card.noHeader{
      padding-top: 18px; /* give body some breathing room without title strip */
    }
    .card.noHeader .body{
      margin-top: 0;
    }

/* --- Struck (Kill Without Deleting) --- */
.card.struck{
  opacity: 0.62;
  filter: grayscale(0.35) saturate(0.75);
}
.card.struck{
  background-image:
    linear-gradient(135deg,
      rgba(0,0,0,0) 45%,
      rgba(0,0,0,0.38) 46%,
      rgba(0,0,0,0.38) 54%,
      rgba(0,0,0,0) 55%);
  background-blend-mode: multiply;
}
.card.struck .title{
  text-decoration: line-through;
  text-decoration-thickness: 2px;
  text-decoration-color: rgba(0,0,0,0.35);
}

/* Tabs colour overlay */
.tabsModal{
  padding: 14px !important;
  max-height: calc(100vh - 90px);
  overflow: auto !important;
}

/* Tabs recent colours */
.tabsRecentWrap{
  margin-top: 6px;
  padding-top: 2px;
}
.tabsRecentLabel{
  font-size: 11px;
  color: rgba(255,255,255,0.70);
  font-weight: 750;
  letter-spacing: 0.2px;
  margin-bottom: 6px;
  user-select: none;
}
.tabsRecentRow{
  display:flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
}

/* Shared swatch button styling (used for defaults + recents) */
.tabsSwatchBtn{
  width: 46px;
  height: 34px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.14);
  cursor: pointer;
  background: rgba(255,255,255,0.06);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: 11px;
  font-weight: 850;
  color: rgba(255,255,255,0.85);
}
.tabsSwatchBtn:hover{ background: rgba(255,255,255,0.10); }
.tabsSwatchBtn.active{
  outline: 3px solid rgba(255,255,255,0.80);
  outline-offset: 2px;
}
.tabsSwatch{
  display: block;
  flex: 0 0 auto;
  width: 22px;
  height: 22px;
  aspect-ratio: 1 / 1;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.20);
}

/* keep Tabs modal independent from editor modal spacing */

.tabsColorGrid{
  display:flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: 10px;
}
.tabsColorRow{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;
  margin-top: 12px;
}
.tabsColorRow input[type="color"]{
  width: 46px;
  height: 34px;
  padding: 0;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.18);
  background: transparent;
  cursor: pointer;
}


/* Tabs: make custom picker visible without extra headroom */
#tabsCustomPickerPanel{
  margin-top: 10px;
  padding-top: 10px;
}
#tabsCustomPickerPanel .customPickerHdr{
  margin-bottom: 6px;
}
#tabsCustomPickerPanel .customPickerTitle{
  font-size: 12px;
  color: rgba(255,255,255,0.85);
}


    .fileInputHidden{position:fixed;left:-9999px;top:0;width:1px;height:1px;opacity:0;}

    /* Perf: keep image cards from forcing large repaints */
    .card.imageCard{ contain: layout paint; }
    .card.imageCard img{ will-change: transform; transform: translateZ(0); backface-visibility: hidden; }


    /* Find (Ctrl+F) */
    .findMatch{
      box-shadow: 0 0 0 3px rgba(110,180,255,0.25), 0 10px 26px rgba(0,0,0,0.22);
    }
    .findResultBtn{
      text-align:left;
      width:100%;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 12px;
      padding: 10px 12px;
      color: rgba(255,255,255,0.92);
      cursor: pointer;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .findResultBtn:hover{ background: rgba(255,255,255,0.07); }
    .findResultTop{ display:flex; justify-content:space-between; gap:10px; align-items:baseline; }
    .findResultTitle{ font-weight:800; letter-spacing:0.2px; font-size:12px; opacity:0.95; }
    .findResultChip{ font-size:11px; color: rgba(255,255,255,0.65); }
    .findResultSnippet{ font-size:12px; color: rgba(255,255,255,0.78); line-height:1.25; }


#foldersMenuBtn{display:none !important;}


    
    /* --- Ink overlay (Pen tool) --- */
    #inkCanvas{
      position:absolute;
      inset:0;
      z-index: 1; /* behind UI */
      pointer-events:none; /* IMPORTANT: keep canvas non-interactive so UI (like the size slider) always works */
      touch-action:none;
    }
    body.bbPenMode #inkCanvas{ pointer-events:none; cursor: crosshair; }
    body.bbPenMode.inkUiHover #inkCanvas{ pointer-events:none; }
    body.bbPenMode #viewport{ cursor: crosshair; }

    #inkPanel{
      display:flex;
      align-items:center;
      gap: 10px;
      row-gap: 10px;
      position: fixed;
      top: 12px;
      right: 14px;
      left: auto;
      z-index: 99999; /* stay above topbar/menus */
      /* Allow wrapping, but keep each row aligned to the right so controls never "drop" to top-left */
      flex-wrap: wrap;
      justify-content: flex-end;
      overflow: visible;
      max-width: min(760px, calc(100vw - 28px));
    }

    #inkPanel, #inkPanel *{ pointer-events: auto !important; }
    #inkPanel{ isolation:isolate; transform: translateZ(0); }

    @media (max-width: 720px){
      #inkPanel{ top: 64px; right: 14px; } /* drop below menubar */
    }

    #inkPanel .lbl{
      font-size: 12px;
      color: rgba(255,255,255,0.7);
      font-weight: 800;
      letter-spacing: 0.2px;
      margin-right: 2px;
      user-select:none;
    }

    /* --- Ink panel: collapsible UI --- */
    #inkCollapseBtn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width: 30px;
      height: 30px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.04);
      color: rgba(255,255,255,0.85);
      cursor: pointer;
      padding: 0;
      margin-left: -4px; /* tuck closer to pen */
    }
    #inkCollapseBtn:hover{ background: rgba(255,255,255,0.07); border-color: rgba(255,255,255,0.28); }
    #inkCollapseBtn:active{ transform: translateY(0.5px); }
    #inkCollapseBtn .inkCollapseCaret{
      display:block;
      font-size: 14px;
      line-height: 1;
      transform: rotate(90deg); /* expanded default */
      transition: transform 140ms ease;
    }
    /* Collapsed: hide everything except Pen + Collapse button */
    #inkPanel.inkCollapsed > *:not(#inkPen):not(#inkCollapseBtn){
      display:none !important;
    }
    #inkPanel.inkCollapsed{
      gap: 6px;
      flex-wrap: nowrap;
      max-width: none;
    }
    #inkPanel.inkCollapsed #inkCollapseBtn .inkCollapseCaret{
      transform: rotate(0deg);
    }


    #inkPen[aria-pressed="true"],
    #inkEraser[aria-pressed="true"]{
      background: rgba(255,255,255,0.18);
      border-color: rgba(255,255,255,0.22);
    }

    .inkColorsDrop{
      display:flex;
      align-items:center;
      gap: 10px;
    }
    #inkColorGrid{
      margin-top: 0;
      gap: 10px;
    }
    #inkColorGrid .tabsSwatchBtn{
      width: 38px;
      height: 32px;
      border-radius: 14px;
    }
    #inkCustomColorBtn{
      height: 32px;
      padding: 0 12px;
      border-radius: 999px;
      white-space: nowrap;
    }

    /* Ink tool icons + colour dropdown */
    #inkPanel{ pointer-events:auto; } /* ensure UI stays clickable in pen mode */
    .inkToolBtn{
      width: 40px;
      height: 36px;
      padding: 0;
      display: grid;
      place-items: center;
    }
    .inkToolBtn svg{
      width: 18px;
      height: 18px;
      fill: currentColor;
      opacity: 0.95;
      pointer-events:none;
    }

    .inkColorToggle{
      display:flex;
      align-items:center;
      gap: 8px;
      padding: 8px 10px;
    }
    /* Background color picker overlay */
    #bgColorWrap{ position: relative; }
    #bgColorToggle{ position: relative; z-index:1; }
    #bgFill{ position:absolute; inset:0; opacity:0; cursor:pointer; z-index:3; width:100%; height:100%; }
    .inkColorSwatch{
      width: 18px;
      height: 18px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.22);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.15);
      background: #ffffff;
    }
    .inkColorCaret{
      font-size: 12px;
      opacity: 0.85;
      transform: translateY(-0.5px);
    }
    .inkColorDropdown{
      position:absolute;
      top: calc(100% + 8px);
      right: 0;
      z-index: 80;
      background: rgba(14,14,14,0.92);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 12px;
      padding: 8px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
      min-width: min(340px, calc(100vw - 40px));
      max-width: min(340px, calc(100vw - 40px));
    }
    .inkColorDropdown #inkColorGrid{ margin-top: 0; }

    /* Ink colour popup custom picker (matches Tabs Colour modal style) */
    .inkCustomPicker{
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .inkSvCanvas{
      width: 100%;
      height: auto;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      cursor: crosshair;
      touch-action: none;
    }
    .inkHueSlider{
      width: 100%;
      cursor: pointer;
      height: 14px;
    }
    .inkCustomBottom{
      display:flex;
      align-items:center;
      gap: 10px;
    }
    #inkCustomPreview{
      width: 84px;
      height: 30px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: #ffffff;
    }


    .inkSizeWrap{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 190px;
    }
    #inkSize{
      width: 140px;
      accent-color: rgba(255,255,255,0.85);
      cursor: pointer;
    }
    .inkSizeLabel{
      width: 46px;
      text-align: right;
      font-size: 12px;
      color: rgba(255,255,255,0.78);
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      user-select: none;
    }


    #inkUndo, #inkClear{
      height: 36px;
      padding: 0 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      font-weight: 800;
      letter-spacing: 0.15px;
      cursor: pointer;
      user-select: none;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
    }
    #inkUndo:hover, #inkClear:hover{
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.22);
      transform: translateY(-0.5px);
    }
    #inkUndo:active, #inkClear:active{
      transform: translateY(0px);
    }



/* --- Background pattern styles (merged) --- */
#bgPattern{
  position: fixed;
  inset: 0;
  z-index: -20;
  pointer-events: none;
  opacity: 1;
  background-size: var(--bgp-size) var(--bgp-size);
  background-image: linear-gradient(to right, var(--bgp-fill) 1px, transparent 1px),
                    linear-gradient(to bottom, var(--bgp-fill) 1px, transparent 1px);
  mask-image: none;
  -webkit-mask-image: none;
}
body.bbPresent #bgPattern{ display:none !important; }

/* Variants */
#bgPattern.variant-dots{
  background-image: radial-gradient(var(--bgp-fill) 1px, transparent 1px);
}
#bgPattern.variant-grid{
  background-image: linear-gradient(to right, var(--bgp-fill) 1px, transparent 1px),
                    linear-gradient(to bottom, var(--bgp-fill) 1px, transparent 1px);
}
#bgPattern.variant-diagonal-stripes{
  background-image: repeating-linear-gradient(45deg, var(--bgp-fill), var(--bgp-fill) 1px, transparent 1px, transparent var(--bgp-size));
}
#bgPattern.variant-horizontal-lines{
  background-image: linear-gradient(to bottom, var(--bgp-fill) 1px, transparent 1px);
}
#bgPattern.variant-vertical-lines{
  background-image: linear-gradient(to right, var(--bgp-fill) 1px, transparent 1px);
}
#bgPattern.variant-checkerboard{
  /* modern + compact checkerboard */
  background-image: repeating-conic-gradient(from 45deg, var(--bgp-fill) 0 25%, transparent 0 50%);
}

/* Masks */
#bgPattern.mask-none{ mask-image:none; -webkit-mask-image:none; }
#bgPattern.mask-fade-edges{ mask-image: radial-gradient(ellipse at center, var(--bg), transparent); -webkit-mask-image: radial-gradient(ellipse at center, var(--bg), transparent); }
#bgPattern.mask-fade-center{ mask-image: radial-gradient(ellipse at center, transparent, var(--bg)); -webkit-mask-image: radial-gradient(ellipse at center, transparent, var(--bg)); }
#bgPattern.mask-fade-top{ mask-image: linear-gradient(to bottom, transparent, var(--bg)); -webkit-mask-image: linear-gradient(to bottom, transparent, var(--bg)); }
#bgPattern.mask-fade-bottom{ mask-image: linear-gradient(to bottom, var(--bg), transparent); -webkit-mask-image: linear-gradient(to bottom, var(--bg), transparent); }
#bgPattern.mask-fade-left{ mask-image: linear-gradient(to right, transparent, var(--bg)); -webkit-mask-image: linear-gradient(to right, transparent, var(--bg)); }
#bgPattern.mask-fade-right{ mask-image: linear-gradient(to right, var(--bg), transparent); -webkit-mask-image: linear-gradient(to right, var(--bg), transparent); }
#bgPattern.mask-fade-x{ mask-image: linear-gradient(to right, transparent, var(--bg), transparent); -webkit-mask-image: linear-gradient(to right, transparent, var(--bg), transparent); }
#bgPattern.mask-fade-y{ mask-image: linear-gradient(to bottom, transparent, var(--bg), transparent); -webkit-mask-image: linear-gradient(to bottom, transparent, var(--bg), transparent); }

/* BG control panel */
#bgPanel{
  gap: 10px;
  position: fixed;
  top: 62px;
  right: 14px;
  z-index: 59; /* just under inkPanel (60), above menus */
  flex-wrap: wrap;
  max-width: min(640px, calc(100vw - 28px));
  display: flex;
  align-items: center;
}
@media (max-width: 720px){
  #bgPanel{ top: 114px; right: 14px; }
}
#bgPanel .lbl{
  font-size: 12px;
  color: rgba(255,255,255,0.7);
  font-weight: 800;
  letter-spacing: 0.2px;
  margin-right: 2px;
  user-select:none;
}
#bgPanel select, #bgPanel input[type="range"], #bgPanel input[type="color"]{
  font: inherit;
}
#bgPanel .bgSelect{
  height: 32px;
  padding: 0 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.06);
  color: rgba(255,255,255,0.92);
  outline: none;
  cursor: pointer;
}
#bgPanel .bgRange{
  width: 140px;
  accent-color: rgba(255,255,255,0.85);
  cursor: pointer;
}
#bgPanel .bgSizeLabel{
  width: 54px;
  text-align: right;
  font-size: 12px;
  color: rgba(255,255,255,0.78);
  font-weight: 800;
  font-variant-numeric: tabular-nums;
  user-select: none;
}

    /* --- Ink overlay (Pen tool) --- */
    #inkCanvas{
      position:absolute;
      inset:0;
      z-index: 9; /* above board grid, below menus/modals */
      pointer-events:none;
      touch-action:none;
    }
    #inkPanel{
      gap: 10px;
      position: fixed;
      top: 12px;
      right: 14px;
      z-index: 60; /* above menu dropdowns */
      flex-wrap: wrap;
      max-width: min(640px, calc(100vw - 28px));
    }

    @media (max-width: 720px){
      #inkPanel{ top: 64px; right: 14px; } /* drop below menubar */
    }

    #inkPanel .lbl{
      font-size: 12px;
      color: rgba(255,255,255,0.7);
      font-weight: 800;
      letter-spacing: 0.2px;
      margin-right: 2px;
      user-select:none;
    }

    #inkPen[aria-pressed="true"],
    #inkEraser[aria-pressed="true"]{
      background: rgba(255,255,255,0.18);
      border-color: rgba(255,255,255,0.22);
    }

    .inkColors{
      display:flex;
      align-items:center;
      gap: 10px;
    }
    #inkColorGrid{
      margin-top: 0;
      gap: 10px;
    }
    #inkColorGrid .tabsSwatchBtn{
      width: 40px;
      height: 32px;
    }
    #inkCustomColorBtn{
      height: 32px;
      padding: 0 12px;
      border-radius: 999px;
      white-space: nowrap;
    }

    .inkSizeWrap{
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 190px;
    }
    #inkSize{
      width: 140px;
      accent-color: rgba(255,255,255,0.85);
      cursor: pointer;
    }
    .inkSizeLabel{
      width: 46px;
      text-align: right;
      font-size: 12px;
      color: rgba(255,255,255,0.78);
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      user-select: none;
    }




  /* Eraser cursor (DOM overlay so it tracks perfectly during erase without redrawing canvas) */
  #eraserCursor{
    position:absolute;
    left:0; top:0;
    width:12px; height:12px;
    border:1px solid rgba(255,255,255,0.85);
    border-radius:999px;
    transform: translate(-9999px,-9999px);
    pointer-events:none;
    z-index: 9999;
    display:none;
  }

    /* ---------- Mobile basics ---------- */
    @media (max-width: 768px){
      .topBar{ padding: 8px 10px; gap: 8px; }
      .menus{ flex-wrap: wrap; gap: 6px; }
      .menuBtn{
        padding: 10px 12px;
        font-size: 14px;
        border-radius: 12px;
      }
      .menuDrop{
        min-width: 220px;
        max-width: calc(100vw - 24px);
      }
      .ctx{
        font-size: 16px;
      }
      .ctxItem{
        padding: 12px 14px;
      }
      /* bigger grab areas */
      .resizeHandle{
        width: 22px !important;
        height: 22px !important;
        border-radius: 8px !important;
      }
      .card{
        min-width: 180px;
      }
      /* reduce accidental text selection during gestures */
      body.bbNoScroll{
        overscroll-behavior: none;
        touch-action: none;
        overflow: hidden;
      }
    }
</style>
<style id="bgPatternVisibilityFix">
  /* Ensure BG pattern is visible and not trapped behind the page */
  #bgPattern{
    position: absolute !important;
    inset: 0 !important;
    z-index: 0 !important;
    pointer-events: none !important;
  }
  /* Make sure the board doesn't paint its own grid over the BG pattern */
  #board{
    background: transparent !important;
    background-image: none !important;
  }
</style><style id="bgMenuStyle">
  /* Background menu dropdown sizing */
  .menuDropdown.bgDropdown{ min-width: 360px; }
  @media (max-width: 520px){
    .menuDropdown.bgDropdown{ min-width: min(92vw, 420px); }
    .menuDropdown.bgDropdown #bgPanel{ flex-wrap: wrap; }
  }

  /* BG panel in dropdown: remove fixed/absolute behavior and heavy chrome */
  #bgMenu #bgPanel{
    position: static !important;
    inset: auto !important;
    top: auto !important;
    right: auto !important;
    bottom: auto !important;
    left: auto !important;
    z-index: auto !important;
    background: transparent !important;
    border: 0 !important;
    box-shadow: none !important;
    padding: 8px 6px !important;
    margin: 0 !important;
  }
</style><style id="bgMenuUIFix">
  /* Background menu selects should match app UI */
  #bgMenu select {
    background: #1e1e1e !important;
    color: #e6e6e6 !important;
    border: 1px solid rgba(255,255,255,0.15) !important;
    border-radius: 6px !important;
    padding: 4px 8px !important;
    font-size: 12px !important;
  }

  #bgMenu select:hover {
    border-color: rgba(255,255,255,0.35) !important;
  }

  #bgMenu option {
    background: #1e1e1e;
    color: #e6e6e6;
  }

  /* Labels in BG panel */
  #bgMenu .lbl {
    color: #bdbdbd;
    font-size: 11px;
    margin-right: 6px;
  }
</style><style id="bgOpacityStyle">
  #bgMenu #bgOpacityLabel.bgSizeLabel{ min-width: 44px; text-align: right; }
</style><style id="bgSliderUniform">
  /* Background menu: keep opacity + size sliders the same length */
  #bgMenu #bgPanel .inkSizeWrap input[type="range"]{
    width: 170px;
    min-width: 170px;
  }
</style><style id="hideViewToggleGrid">
  /* Hide View > Show/Hide Grid (deprecated in favor of Background controls) */
  #menuToggleGrid{ display:none !important; }
  /* If it leaves an awkward separator just before/after, hide the nearest separator in that block */
  #menuToggleGrid + .menuSep, 
  #menuToggleGrid + div.menuSep,
  .menuSep:has(+ #menuToggleGrid),
  div.menuSep:has(+ #menuToggleGrid){
    display:none !important;
  }
</style><style id="bgColorSafeStyle">
  #bgMenu #bgColorWrap .editColorBtn{ padding: 6px 10px; border-radius: 10px; font-weight: 750; }
  #bgMenu #bgColorWrap .editColorDot{ width:14px; height:14px; border-radius:7px; }
  #bgColorOverlay{ align-items:center; justify-content:center; }
</style><style id="bgColorBtnClickable">
  #bgMenu #bgColorWrap{ pointer-events:auto; }
  #bgMenu #bgColorBtn{
    pointer-events:auto !important;
    position: relative;
    z-index: 5;
    opacity: 1 !important;
    filter: none !important;
  }
</style><style id="bgMenuCompact">
  /* Background menu: tighter spacing + consistent control sizing */
  #bgMenu #bgPanel{
    display:flex;
    align-items:center;
    flex-wrap: wrap;
    gap: 10px;
    padding: 6px 6px !important;
  }
  #bgMenu #bgPanel .bgSelect{ height: 32px; }
  #bgMenu #bgColorWrap{
    display:flex;
    align-items:center;
    gap: 8px;
    margin: 0;
  }
  #bgMenu #bgColorWrap .bgColorToggle{
    height: 32px;
    padding: 6px 10px;
    border-radius: 10px;
  }
  #bgMenu #bgPanel .inkSizeWrap{ margin:0; }
  #bgMenu #bgPanel .bgSizeLabel{ margin-left: 6px; }
</style>
<style id="inkCollapseStyle">
  /* Ink collapse toggle â€” matches tool button chrome */
  #inkPanel .inkCollapseBtn.inkCollapseSolo{
    width: 38px;
    height: 38px;
    border-radius: 14px;
    border: 1px solid rgba(255,255,255,0.14);
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.9);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 18px;      /* bigger arrow */
    line-height: 1;
    padding: 0;
    box-shadow: 0 6px 18px rgba(0,0,0,0.22);
    transition: transform 140ms ease, background 120ms ease, border-color 120ms ease, color 120ms ease;
  }
  #inkPanel .inkCollapseBtn.inkCollapseSolo:hover{
    background: rgba(255,255,255,0.08);
    border-color: rgba(255,255,255,0.22);
    color: rgba(255,255,255,1);
  }
  #inkPanel .inkCollapseBtn.inkCollapseSolo:active{
    transform: translateY(1px);
  }
  /* Arrow direction logic:
     - Collapsed: â—€ (points left, menu closed)
     - Expanded: â–¶ (points right, click to collapse)
  */
  #inkPanel.inkCollapsed .inkCollapseBtn.inkCollapseSolo{
    transform: rotate(0deg);
  }
  #inkPanel:not(.inkCollapsed) .inkCollapseBtn.inkCollapseSolo{
    transform: rotate(180deg);
  }
</style>
<style id="inkPenActiveStyle">
  /* Active pen highlight */
  #inkPen[aria-pressed="true"]{
    background: rgba(255,255,255,0.9) !important;
    color: #111 !important;
    border-color: rgba(255,255,255,0.9) !important;
  }
  #inkPen[aria-pressed="true"] svg{
    fill: #111 !important;
  }
</style>
<style id="inkEraserActiveStyle">
  /* Active eraser highlight (inverse like pen) */
  #inkEraser[aria-pressed="true"]{
    background: rgba(255,255,255,0.9) !important;
    color: #111 !important;
    border-color: rgba(255,255,255,0.9) !important;
  }
  #inkEraser[aria-pressed="true"] svg{
    fill: #111 !important;
  }
</style>
</head>
<body>
<div class="topbar">
<div class="panel menubar">
<div class="brand"><span class="dot"></span>Beat Board</div>
<div aria-label="Menu bar" class="menus" role="menubar">
<div class="menu">
<button aria-expanded="false" aria-haspopup="true" class="menuBtn" data-menu="fileMenu" type="button">File</button>
<div aria-hidden="true" class="menuDropdown" id="fileMenu" role="menu">
<button class="menuItem" id="menuNewHeader" type="button">New header card <span class="ctxKey">N</span></button>
<button class="menuItem" id="menuNewBlank" type="button">New blank card <span class="ctxKey">B</span></button>
<div class="menuSep"></div>
<button class="menuItem" id="menuSaveAs" type="button">Save Asâ€¦</button>
<button class="menuItem" id="menuOpen" type="button">Openâ€¦</button>
<button class="menuItem" id="menuOpenRecent" type="button">Open Recent</button>
<button class="menuItem" id="menuExportPng" type="button">Export as Image (PNG)</button>
<button class="menuItem" id="menuExportMd" type="button">Export as Markdown (MD)</button>
<label class="menuItem" for="imgImport" id="menuImportImages" role="menuitem">Import Image(s)â€¦</label>
<div class="menuSep"></div>
<button class="menuItem" id="btnExport" type="button">Exportâ€¦</button>
<button class="menuItem" id="btnImport" type="button">Importâ€¦</button>
<div class="menuSep"></div>
<button class="menuItem danger" id="btnClear" type="button">Reset board</button>
</div>
</div>
<div class="menu">
<button aria-expanded="false" aria-haspopup="true" class="menuBtn" data-menu="editMenu" type="button">Edit</button>
<div aria-hidden="true" class="menuDropdown" id="editMenu" role="menu">
<button class="menuItem" id="menuUndo" type="button">Undo <span class="ctxKey">Ctrl Z</span></button>
<button class="menuItem" id="menuRedo" type="button">Redo <span class="ctxKey">Ctrl Y</span></button>
<div class="menuSep"></div>
<button class="menuItem" id="menuCut" type="button">Cut <span class="ctxKey">Ctrl X</span></button>
<button class="menuItem" id="menuCopy" type="button">Copy <span class="ctxKey">Ctrl C</span></button>
<button class="menuItem" id="menuPaste" type="button">Paste <span class="ctxKey">Ctrl V</span></button>
<div class="menuSep"></div>
<button class="menuItem" id="menuSelectAll" type="button">Select All <span class="ctxKey">Ctrl A</span></button>
<button class="menuItem" id="menuFind" type="button">Findâ€¦ <span class="ctxKey">Ctrl F</span></button>
<div class="menuSep"></div>
<button class="menuItem" id="menuLockToggle" type="button">Lock / Unlock</button>
<div class="menuSep"></div>
<button class="menuItem" id="menuGroup" type="button">Group <span class="ctxKey">Ctrl G</span></button>
<button class="menuItem" id="menuUngroup" type="button">Ungroup <span class="ctxKey">Ctrl Shift G</span></button>
<div class="menuSep"></div>
<button class="menuItem" id="menuDuplicate" type="button">Duplicate <span class="ctxKey">Ctrl D</span></button>
<button class="menuItem" id="menuDelete" type="button">Delete <span class="ctxKey">Del</span></button>
</div>
</div>
<div class="menu">
<button aria-expanded="false" aria-haspopup="true" class="menuBtn" data-menu="tabsMenu" type="button">Tabs</button>
<div aria-hidden="true" class="menuDropdown" id="tabsMenu" role="menu">
<button class="menuItem" id="menuTabsColor" type="button">Colourâ€¦</button>
<div class="menuSep"></div>
<button class="menuItem" id="menuTabsStrikeToggle" type="button">Strike / Unstrike</button>
</div>
</div>
<div class="menu">
<button aria-expanded="false" aria-haspopup="true" class="menuBtn" data-menu="viewMenu" type="button">View</button>
<div aria-hidden="true" class="menuDropdown" id="viewMenu" role="menu">
<button class="menuItem" id="btnCenter" type="button">Center view</button>
<div class="menuSep"></div>
<button class="menuItem" id="menuToggleGrid" type="button">Show / Hide Grid</button>
<button class="menuItem" id="menuPresentation" type="button">Presentation Mode <span class="ctxKey">Esc</span></button>
<div class="menuSep"></div>
<button class="menuItem" id="menuZoomIn" type="button">Zoom in <span class="ctxKey">Ctrl +</span></button>
<button class="menuItem" id="menuZoomOut" type="button">Zoom out <span class="ctxKey">Ctrl -</span></button>
<button class="menuItem" id="menuZoomReset" type="button">Actual size <span class="ctxKey">Ctrl 0</span></button>
</div>
</div>
<div class="menu" id="bgMenuBtnWrap">
<button aria-expanded="false" aria-haspopup="true" class="menuBtn" data-menu="bgMenu" type="button">Background</button>
</div>
</div>
<div aria-hidden="true" class="menuDropdown bgDropdown" id="bgMenu" role="menu">
<div class="panel" id="bgPanel" title="Background pattern">
<select class="bgSelect" id="bgVariant" title="Pattern"><option value="grid">Grid</option>
<option value="horizontal-lines">Horizontal</option>
<option value="vertical-lines">Vertical</option>
<option value="dots">Dots</option>
</select>
<select class="bgSelect" id="bgMask" title="Mask">
<option value="none">No mask</option>
<option value="fade-edges">Fade edges</option>
<option value="fade-center">Fade center</option>
<option value="fade-top">Fade top</option>
<option value="fade-bottom">Fade bottom</option></select>
<div class="editColorWrap" id="bgColorWrap" title="Background colour">
<span class="lbl">Colour</span>
<div class="bgColorPickWrap" style="position:relative; display:inline-block;">
<button class="inkColorToggle bgColorToggle" id="bgColorToggle" title="Background colour" type="button">
<span aria-hidden="true" class="inkColorSwatch" id="bgColorSwatch"></span>
<span aria-hidden="true" class="inkColorCaret">â–¾</span>
</button>
<input id="bgFill" style="position:absolute; inset:0; opacity:0; cursor:pointer; z-index:3; width:100%; height:100%;" title="Line colour" type="color" value="#ffffff"/>
</div>
</div>
<div class="inkSizeWrap" title="Pattern opacity">
<input id="bgOpacity" max="1" min="0" step="0.05" type="range" value="0.5"/>
<div class="bgSizeLabel" id="bgOpacityLabel">50%</div>
</div>
<div class="inkSizeWrap" style="min-width: 190px;" title="Pattern size">
<input class="bgRange" id="bgSize" max="80" min="8" type="range" value="28"/>
<div class="bgSizeLabel" id="bgSizeLabel">28px</div>
</div>
</div>
</div></div>
</div>
<div class="panel inkCollapsed" id="inkPanel" title="Ink tool">
<button aria-expanded="false" aria-label="Toggle ink panel" class="inkCollapseBtn inkCollapseSolo" id="inkCollapseBtn" type="button">â—€</button>
<button aria-label="Pen" aria-pressed="false" class="inkToolBtn" id="inkPen" title="Pen (P)" type="button">
<svg aria-hidden="true" viewbox="0 0 24 24"><path d="M3 21l3.8-1 11-11-2.8-2.8-11 11L3 21zm14.6-14.6l1.4-1.4a2 2 0 0 1 2.8 2.8l-1.4 1.4-2.8-2.8z"></path></svg>
</button>
<button aria-label="Eraser" aria-pressed="false" class="inkToolBtn" id="inkEraser" title="Eraser (E)" type="button">
<svg aria-hidden="true" viewbox="0 0 24 24"><path d="M16.2 3.8a2.5 2.5 0 0 1 3.5 0l.5.5a2.5 2.5 0 0 1 0 3.5L11 17.5H5.5L3 15l13.2-11.2zM5.9 16h4.3l-2.6-2.6L5 15.9l.9.1zM21 20H9v2h12v-2z"></path></svg>
</button>
<div aria-label="Ink colours" class="inkColorsDrop">
<button aria-expanded="false" class="inkColorToggle" id="inkColorToggle" title="Ink colour" type="button">
<span aria-hidden="true" class="inkColorSwatch" id="inkColorSwatch"></span>
<span aria-hidden="true" class="inkColorCaret">â–¾</span>
</button>
<div class="inkColorDropdown" hidden="" id="inkColorDropdown">
<div aria-label="Ink colour presets" class="tabsColorGrid" id="inkColorGrid">
<button class="tabsSwatchBtn" data-preset="act1" title="Act 1" type="button"><span class="tabsSwatch" style="background: var(--act1)"></span></button>
<button class="tabsSwatchBtn" data-preset="act2" title="Act 2" type="button"><span class="tabsSwatch" style="background: var(--act2)"></span></button>
<button class="tabsSwatchBtn" data-preset="act3" title="Act 3" type="button"><span class="tabsSwatch" style="background: var(--act3)"></span></button>
<button class="tabsSwatchBtn" data-preset="neutral" title="Neutral" type="button"><span class="tabsSwatch" style="background: var(--neutral)"></span></button>
<button class="tabsSwatchBtn" data-hex="#ffe699" title="#ffe699" type="button"><span class="tabsSwatch" style="background: #ffe699"></span></button>
<button class="tabsSwatchBtn" data-hex="#dbe7f2" title="#dbe7f2" type="button"><span class="tabsSwatch" style="background: #dbe7f2"></span></button>
<button class="tabsSwatchBtn" data-hex="#d7f2ec" title="#d7f2ec" type="button"><span class="tabsSwatch" style="background: #d7f2ec"></span></button>
<button class="tabsSwatchBtn" data-hex="#f2d7d5" title="#f2d7d5" type="button"><span class="tabsSwatch" style="background: #f2d7d5"></span></button>
<button class="tabsSwatchBtn" data-hex="#c6e0b4" title="#c6e0b4" type="button"><span class="tabsSwatch" style="background: #c6e0b4"></span></button>
<button class="tabsSwatchBtn" data-hex="#bdd7ee" title="#bdd7ee" type="button"><span class="tabsSwatch" style="background: #bdd7ee"></span></button>
<button class="tabsSwatchBtn" data-hex="#f8cbad" title="#f8cbad" type="button"><span class="tabsSwatch" style="background: #f8cbad"></span></button>
<button class="tabsSwatchBtn" data-hex="#d98fb7" title="#d98fb7" type="button"><span class="tabsSwatch" style="background: #d98fb7"></span></button>
<button class="tabsSwatchBtn" data-hex="#b8a1d9" title="#b8a1d9" type="button"><span class="tabsSwatch" style="background: #b8a1d9"></span></button>
<button class="tabsSwatchBtn" data-hex="#a9d18e" title="#a9d18e" type="button"><span class="tabsSwatch" style="background: #a9d18e"></span></button>
<button class="tabsSwatchBtn" data-hex="#5f6b7a" title="#5f6b7a" type="button"><span class="tabsSwatch" style="background: #5f6b7a"></span></button>
<button class="tabsSwatchBtn" data-hex="#20262e" title="#20262e" type="button"><span class="tabsSwatch" style="background: #20262e"></span></button>
</div>
<div style="height:1px; background: rgba(255,255,255,0.10); margin: 10px 0;"></div>
<div style="font-size:11px; color: rgba(255,255,255,0.70); font-weight:750; letter-spacing:0.2px; margin-bottom:6px;">Custom colour</div>
<!-- Keep a native input as fallback + value pipeline -->
<input id="inkColorInput" style="display:none;" type="color" value="#ffffff"/>
<div class="inkCustomPicker" id="inkCustomPickerPanel">
<canvas aria-label="Saturation and value" class="svCanvas inkSvCanvas" height="120" id="inkSvCanvas" width="200"></canvas>
<input aria-label="Hue" class="hueSlider inkHueSlider" id="inkHueSlider" max="360" min="0" type="range" value="210"/>
<div class="inkCustomBottom">
<div aria-label="Preview" class="customPreview" id="inkCustomPreview"></div>
<input class="hexInput" id="inkHexInput" spellcheck="false" value="#ffffff"/>
</div>
</div>
</div>
</div>
<div class="inkSizeWrap" title="Brush size">
<input id="inkSize" max="40" min="1" type="range" value="4"/>
<div class="inkSizeLabel" id="inkSizeLabel">4px</div>
</div>
<button id="inkUndo" title="Undo ink (Ctrl Z)" type="button">Undo</button>
<button id="inkClear" title="Clear ink" type="button">Clear</button>
</div>
<div id="viewport">
<div aria-hidden="true" id="bgPattern"></div><div id="board"></div>
<!-- Ink overlay (screen-space, reprojected) -->
<canvas aria-label="Ink layer" id="inkCanvas"></canvas><div aria-hidden="true" id="eraserCursor"></div><div class="modalOverlay" id="bgColorOverlay" style="display:none;">
<div class="modal">
<div class="modalHeader">
<div class="modalTitle">Background Colour</div>
<button class="hdrBtn" id="bgColorCloseBtn" type="button">Close</button>
</div>
<div class="tabsModal">
<div class="tabsSwatchGridWrap">
<div class="tabsRecentWrap" id="bgRecentWrap" style="display:none;">
<div class="tabsRecentLabel">Recent</div>
<div class="tabsRecentRow" id="bgRecentRow"></div>
</div>
<div class="tabsSwatchGrid" id="bgColorGrid"></div>
</div>
<div class="tabsDivider"></div>
<div class="tabsCustomWrap">
<div class="tabsCustomLabel">Custom colour</div>
<div class="tabsPickerWrap">
<canvas class="tabsSvCanvas" height="220" id="bgSvCanvas" width="280"></canvas>
<input class="tabsHue" id="bgHueSlider" max="360" min="0" type="range" value="210"/>
</div>
<div class="tabsBottomRow">
<div class="tabsCustomPreview" id="bgCustomPreview"></div>
<input class="tabsHex" id="bgHexInput" type="text" value="#ffffff"/>
</div>
</div>
</div>
</div>
</div>
<!-- Editor modal (writing-focused) -->
<div class="modalOverlay" id="modalOverlay">
<div class="modal editorModal">
<div class="editColorBar" id="editColorBar"></div>
<header>
<h2 id="modalTitle">Edit</h2>
<div class="hdrRight">
<button class="hdrBtn" id="btnBold" title="Bold"><span style="font-weight:900">B</span></button>
<button class="hdrBtn" id="btnUnderline" title="Underline"><span style="text-decoration:underline;font-weight:900">U</span></button>
<button class="hdrBtn" id="btnItalic" title="Italic"><span style="font-style:italic;font-weight:900">I</span></button>
<div class="editColorWrap" title="Card colour">
<button aria-label="Card colour" class="editColorBtn" id="editColorBtn" type="button">
<span class="editColorDot" id="editColorDot"></span>
              Colour
            </button>
<div aria-hidden="true" class="editColorMenu" id="editColorMenu">
<div class="editRecentWrap" id="editRecentWrap" style="display:none">
<div class="editRecentLabel">Recent</div>
<div class="editRecentRow" id="editRecentRow"></div>
</div>
<div class="editColorRow" id="editColorSwatches"></div>
<div class="editColorBottom">
<label class="editColorLabel" id="editColorCustomLabel" style="cursor:pointer;">Custom</label>
<input id="editColorInput" type="color" value="#c9c9c9"/>
<button class="editColorClear" id="editColorClear" type="button">Default</button>
</div>
<div class="customPickerPanel" id="customPickerPanel" style="display:none">
<div class="customPickerHdr">
<div class="customPickerTitle">Custom colour</div>
<button class="hdrBtn customPickerClose" id="customPickerClose" title="Close" type="button">âœ•</button>
</div>
<div class="customPickerGrid">
<canvas aria-label="Saturation and value" class="svCanvas" height="130" id="svCanvas" width="190"></canvas>
<div class="customPickerSide">
<input aria-label="Hue" class="hueSlider" id="hueSlider" max="360" min="0" type="range" value="210"/>
<div aria-label="Preview" class="customPreview" id="customPreview"></div>
<input class="hexInput" id="hexInput" spellcheck="false" value="#4aa3ff"/>
<div class="customPickerBtns">
<button class="hdrBtn" id="customPickerApply" type="button">Apply</button>
<button class="hdrBtn" id="customPickerSystem" type="button">System</button>
</div>
</div>
</div>
</div>
</div>
</div>
<button id="btnCloseModal">Save &amp; Close</button>
</div>
</header>
<input id="editTitle" placeholder="Title" type="text"/>
<div contenteditable="true" id="editBody" spellcheck="true"></div>
</div>
</div>
<!-- Recent files overlay -->
<div class="modalOverlay" id="recentOverlay" style="display:none;">
<div class="modal" style="width:min(640px, calc(100% - 26px));">
<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;">
<div style="font-weight:800; letter-spacing:0.2px;">Open Recent</div>
<button class="hdrBtn" id="recentCloseBtn" type="button">Close</button>
</div>
<div id="recentList" style="display:flex; flex-direction:column; gap:8px;"></div>
<div style="margin-top:10px; font-size:11px; color: rgba(255,255,255,0.65); line-height:1.2;">
        Recent files are stored locally in your browser.
      </div>
</div>
</div>
<!-- Find overlay -->
<div class="modalOverlay" id="findOverlay" style="display:none;">
<div class="modal" style="width:min(720px, calc(100% - 26px));">
<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;">
<div style="font-weight:800; letter-spacing:0.2px;">Find</div>
<button class="hdrBtn" id="findCloseBtn" type="button">Close</button>
</div>
<div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
<input id="findInput" placeholder="Search titles, text, image namesâ€¦" spellcheck="false" style="flex:1; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.92); outline:none;" type="text"/>
<button class="hdrBtn" id="findPrevBtn" title="Previous" type="button">Prev</button>
<button class="hdrBtn" id="findNextBtn" title="Next" type="button">Next</button>
</div>
<div id="findMeta" style="font-size:12px; color: rgba(255,255,255,0.72); margin-bottom:6px;"></div>
<div id="findResults" style="display:flex; flex-direction:column; gap:8px; max-height: min(52vh, 520px); overflow:auto; padding-right:2px;"></div>
<div style="margin-top:10px; font-size:11px; color: rgba(255,255,255,0.65); line-height:1.2;">
        Tip: press <b>Enter</b> to jump to the next result. Press <b>Esc</b> to close.
      </div>
</div>
</div>
<!-- Folder settings overlay -->
<div class="modalOverlay" id="folderOverlay" style="display:none;">
<div class="modal folderModal" style="width:min(560px, calc(100% - 26px));">
<div class="folderHdr">
<div class="folderHdrTitle">Folder settings</div>
<button class="hdrBtn" id="folderCloseBtn" type="button">Close</button>
</div>
<div class="folderForm">
<div class="folderRow">
<label class="folderLbl">Name</label>
<input class="folderTextInput" id="folderNameInput" placeholder="Folder name" type="text"/>
<label class="folderChk">
<input id="folderShowName" type="checkbox">
<span>Show label</span>
</input></label>
</div><div class="folderRow" style="align-items:flex-start;">
<label class="folderLbl" style="padding-top:6px;">Colour</label>
<div style="flex:1; display:flex; flex-direction:column; gap:8px;">
<div class="folderRecentWrap">
<div class="folderRecentTitle">Recent</div>
<div aria-label="Recent folder colours" class="tabsColorGrid folderRecentGrid" id="folderRecentGrid"></div>
</div>
<div aria-label="Folder colour presets" class="tabsColorGrid" id="folderColorGrid">
<button class="tabsSwatchBtn" data-preset="act1" title="Act 1" type="button"><span class="tabsSwatch" style="background: var(--act1)"></span></button>
<button class="tabsSwatchBtn" data-preset="act2" title="Act 2" type="button"><span class="tabsSwatch" style="background: var(--act2)"></span></button>
<button class="tabsSwatchBtn" data-preset="act3" title="Act 3" type="button"><span class="tabsSwatch" style="background: var(--act3)"></span></button>
<button class="tabsSwatchBtn" data-preset="neutral" title="Neutral" type="button"><span class="tabsSwatch" style="background: var(--neutral)"></span></button>
<button class="tabsSwatchBtn" data-hex="#ffe699" title="#ffe699" type="button"><span class="tabsSwatch" style="background: #ffe699"></span></button>
<button class="tabsSwatchBtn" data-hex="#dbe7f2" title="#dbe7f2" type="button"><span class="tabsSwatch" style="background: #dbe7f2"></span></button>
<button class="tabsSwatchBtn" data-hex="#d7f2ec" title="#d7f2ec" type="button"><span class="tabsSwatch" style="background: #d7f2ec"></span></button>
<button class="tabsSwatchBtn" data-hex="#f2d7d5" title="#f2d7d5" type="button"><span class="tabsSwatch" style="background: #f2d7d5"></span></button>
<button class="tabsSwatchBtn" data-hex="#c6e0b4" title="#c6e0b4" type="button"><span class="tabsSwatch" style="background: #c6e0b4"></span></button>
<button class="tabsSwatchBtn" data-hex="#bdd7ee" title="#bdd7ee" type="button"><span class="tabsSwatch" style="background: #bdd7ee"></span></button>
<button class="tabsSwatchBtn" data-hex="#f8cbad" title="#f8cbad" type="button"><span class="tabsSwatch" style="background: #f8cbad"></span></button>
<button class="tabsSwatchBtn" data-hex="#d98fb7" title="#d98fb7" type="button"><span class="tabsSwatch" style="background: #d98fb7"></span></button>
<button class="tabsSwatchBtn" data-hex="#b8a1d9" title="#b8a1d9" type="button"><span class="tabsSwatch" style="background: #b8a1d9"></span></button>
<button class="tabsSwatchBtn" data-hex="#a9d18e" title="#a9d18e" type="button"><span class="tabsSwatch" style="background: #a9d18e"></span></button>
<button class="tabsSwatchBtn" data-hex="#5f6b7a" title="#5f6b7a" type="button"><span class="tabsSwatch" style="background: #5f6b7a"></span></button>
<button class="tabsSwatchBtn" data-hex="#20262e" title="#20262e" type="button"><span class="tabsSwatch" style="background: #20262e"></span></button>
</div>
<!-- Keep a native input as fallback + value pipeline -->
<input id="folderColorInput" style="display:none;" type="color" value="#ffffff"/>
<!-- Custom colour picker (same as Tabs Colour panel) -->
<div class="customPickerPanel" id="folderCustomPickerPanel" style="display:block">
<div class="customPickerHdr">
<div class="customPickerTitle">Custom colour</div>
</div>
<div class="customPickerGrid">
<canvas aria-label="Saturation and value" class="svCanvas" height="130" id="folderSvCanvas" width="190"></canvas>
<div class="customPickerSide">
<input aria-label="Hue" class="hueSlider" id="folderHueSlider" max="360" min="0" type="range" value="210"/>
<div aria-label="Preview" class="customPreview" id="folderCustomPreview"></div>
<input class="hexInput" id="folderHexInput" spellcheck="false" value="#ffffff"/>
</div>
</div>
</div>
</div>
</div>
<div class="folderRow">
<label class="folderLbl">Opacity</label>
<input id="folderOpacityInput" max="100" min="0" style="flex:1;" type="range" value="20"/>
<div class="folderPct" id="folderOpacityLabel">20%</div>
</div>
<div class="folderActions">
<button class="hdrBtn" id="folderResetBtn" type="button">Reset</button>
</div>
</div>
</div>
</div>
<!-- Tabs colour overlay -->
<div class="modalOverlay" id="tabsColorOverlay" style="display:none;">
<div class="modal tabsModal" style="width:min(520px, calc(100% - 26px));">
<div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px;">
<div style="font-weight:800; letter-spacing:0.2px;">Tabs Colour</div>
<button class="hdrBtn" id="tabsColorCloseBtn" type="button">Close</button>
</div>
<!-- Recent colours -->
<div class="tabsRecentWrap" id="tabsRecentWrap" style="display:none;">
<div class="tabsRecentLabel">Recent</div>
<div class="tabsRecentRow" id="tabsRecentRow"></div>
</div>
<div class="tabsColorGrid" id="tabsColorGrid">
<button class="tabsSwatchBtn" data-preset="act1" title="Act 1" type="button"><span class="tabsSwatch" style="background: var(--act1)"></span></button>
<button class="tabsSwatchBtn" data-preset="act2" title="Act 2" type="button"><span class="tabsSwatch" style="background: var(--act2)"></span></button>
<button class="tabsSwatchBtn" data-preset="act3" title="Act 3" type="button"><span class="tabsSwatch" style="background: var(--act3)"></span></button>
<button class="tabsSwatchBtn" data-preset="neutral" title="Neutral" type="button"><span class="tabsSwatch" style="background: var(--neutral)"></span></button>
<button class="tabsSwatchBtn" data-hex="#ffe699" title="#ffe699" type="button"><span class="tabsSwatch" style="background: #ffe699"></span></button>
<button class="tabsSwatchBtn" data-hex="#dbe7f2" title="#dbe7f2" type="button"><span class="tabsSwatch" style="background: #dbe7f2"></span></button>
<button class="tabsSwatchBtn" data-hex="#d7f2ec" title="#d7f2ec" type="button"><span class="tabsSwatch" style="background: #d7f2ec"></span></button>
<button class="tabsSwatchBtn" data-hex="#f2d7d5" title="#f2d7d5" type="button"><span class="tabsSwatch" style="background: #f2d7d5"></span></button>
<button class="tabsSwatchBtn" data-hex="#c6e0b4" title="#c6e0b4" type="button"><span class="tabsSwatch" style="background: #c6e0b4"></span></button>
<button class="tabsSwatchBtn" data-hex="#bdd7ee" title="#bdd7ee" type="button"><span class="tabsSwatch" style="background: #bdd7ee"></span></button>
<button class="tabsSwatchBtn" data-hex="#f8cbad" title="#f8cbad" type="button"><span class="tabsSwatch" style="background: #f8cbad"></span></button>
<button class="tabsSwatchBtn" data-hex="#d98fb7" title="#d98fb7" type="button"><span class="tabsSwatch" style="background: #d98fb7"></span></button>
<button class="tabsSwatchBtn" data-hex="#b8a1d9" title="#b8a1d9" type="button"><span class="tabsSwatch" style="background: #b8a1d9"></span></button>
<button class="tabsSwatchBtn" data-hex="#a9d18e" title="#a9d18e" type="button"><span class="tabsSwatch" style="background: #a9d18e"></span></button>
<button class="tabsSwatchBtn" data-hex="#5f6b7a" title="#5f6b7a" type="button"><span class="tabsSwatch" style="background: #5f6b7a"></span></button>
<button class="tabsSwatchBtn" data-hex="#20262e" title="#20262e" type="button"><span class="tabsSwatch" style="background: #20262e"></span></button>
</div>
<div class="tabsColorRow">
<div id="tabsColorCustomLabel" style="display:none; font-size:11px; color: rgba(255,255,255,0.70); font-weight:750; letter-spacing:0.2px; cursor:pointer;">Custom</div>
<!-- Keep a native input as fallback + value pipeline -->
<input id="tabsColorInput" style="display:none;" type="color" value="#c9c9c9"/>
</div>
<!-- Custom colour picker (same as editor) -->
<div class="customPickerPanel" id="tabsCustomPickerPanel" style="display:block">
<div class="customPickerHdr">
<div class="customPickerTitle">Custom colour</div>
</div>
<div class="customPickerGrid">
<canvas aria-label="Saturation and value" class="svCanvas" height="130" id="tabsSvCanvas" width="190"></canvas>
<div class="customPickerSide">
<input aria-label="Hue" class="hueSlider" id="tabsHueSlider" max="360" min="0" type="range" value="210"/>
<div aria-label="Preview" class="customPreview" id="tabsCustomPreview"></div>
<input class="hexInput" id="tabsHexInput" spellcheck="false" value="#4aa3ff"/>
</div>
</div>
</div>
</div>
</div>
<!-- Context menu -->
<div class="ctx" id="ctxMenu">
<div class="ctxItem" id="ctxNew">New header card <span class="ctxKey">N</span></div>
<div class="ctxItem" id="ctxNewBlank">New blank card <span class="ctxKey">B</span></div>
<div class="ctxSep"></div>
<div class="ctxItem" id="ctxDuplicate">Duplicate</div>
<div class="ctxSep"></div>
<div class="ctxItem" id="ctxGroup">Group</div>
<div class="ctxItem" id="ctxUngroup">Ungroup</div>
<div class="ctxSep"></div>
<div class="ctxItem" id="ctxReset">Reset</div>
<div class="ctxItem" id="ctxDelete">Delete <span class="ctxKey">Del</span></div>
</div>
<input accept="image/*" class="fileInputHidden" id="imgImport" multiple="" type="file"/>
<input accept="application/json,.json" class="fileInputHidden" id="openProject" type="file"/>
<script>
(() => {
  const STORAGE_KEY = "beatboard.v4";
  // --- Image storage (keeps giant base64 blobs out of the main cards JSON for performance) ---
  const IMG_STORE_PREFIX = STORAGE_KEY + "::img::";
  const __imgCache = new Map(); // imgId -> dataUrl

  function imgKey(imgId){ return IMG_STORE_PREFIX + imgId; }

  function getImageDataUrl(imgId){
    if(!imgId) return null;
    if(__imgCache.has(imgId)) return __imgCache.get(imgId);
    const v = localStorage.getItem(imgKey(imgId));
    if(v != null) __imgCache.set(imgId, v);
    return v;
  }
  function putImageDataUrl(imgId, dataUrl){
    if(!imgId || !dataUrl) return;
    try{
      localStorage.setItem(imgKey(imgId), dataUrl);
      __imgCache.set(imgId, dataUrl);
    } catch(err){
      // If storage is full, try to at least keep it in memory for this session
      __imgCache.set(imgId, dataUrl);
      console.warn("Image storage full or blocked:", err);
    }
  }
  function deleteImageDataUrl(imgId){
    if(!imgId) return;
    __imgCache.delete(imgId);
    try{ localStorage.removeItem(imgKey(imgId)); } catch(e){}
  }

  async function blobToDataURL(blob){
    return await new Promise((resolve, reject)=>{
      const r = new FileReader();
      r.onload = ()=>resolve(r.result);
      r.onerror = ()=>reject(new Error("Blob to dataURL failed"));
      r.readAsDataURL(blob);
    });
  }

  async function compressImageFileToDataUrl(file, maxDim=1600, quality=0.78){
    // Decode off the main thread where possible (createImageBitmap is generally faster)
    let bitmap = null;
    try{ bitmap = await createImageBitmap(file); } catch(e){ bitmap = null; }

    // Fallback path: use a temporary Image tag
    let w,h, drawSource;
    if(bitmap){
      w = bitmap.width; h = bitmap.height; drawSource = bitmap;
    } else {
      const dataUrl = await new Promise((resolve, reject)=>{
        const r = new FileReader();
        r.onload = ()=>resolve(r.result);
        r.onerror = ()=>reject(new Error("Image read failed"));
        r.readAsDataURL(file);
      });
      const img = await new Promise((resolve, reject)=>{
        const i = new Image();
        i.onload = ()=>resolve(i);
        i.onerror = ()=>reject(new Error("Image decode failed"));
        i.src = dataUrl;
      });
      w = img.naturalWidth || img.width; h = img.naturalHeight || img.height; drawSource = img;
    }

    const scale = Math.min(1, maxDim / Math.max(w, h));
    const cw = Math.max(1, Math.round(w * scale));
    const ch = Math.max(1, Math.round(h * scale));

    const canvas = document.createElement("canvas");
    canvas.width = cw; canvas.height = ch;
    const ctx = canvas.getContext("2d", { alpha:false, desynchronized:true });
    ctx.drawImage(drawSource, 0,0, cw, ch);

    // Prefer WebP if the browser supports it; otherwise use JPEG
    const tryTypes = ["image/webp", "image/jpeg"];
    for(const type of tryTypes){
      try{
        const blob = await new Promise((resolve)=> canvas.toBlob(resolve, type, quality));
        if(blob) return await blobToDataURL(blob);
      } catch(e){}
    }
    // Last resort
    return canvas.toDataURL("image/jpeg", quality);
  }


  const viewport = document.getElementById("viewport");

  function worldToClient(wx, wy){
    const rect = viewport.getBoundingClientRect();
    return {
      x: rect.left + view.x + (wx * view.scale),
      y: rect.top  + view.y + (wy * view.scale),
      rect
    };
  }

  const board = document.getElementById("board");

  // Track last pointer position (for paste anchoring)
  viewport.addEventListener("mousemove", (e)=>{ lastPointerClient = { x: e.clientX, y: e.clientY }; try{ const w = worldFromClient(e.clientX, e.clientY); lastGroupHoverId = getGroupAtWorldPoint(w.x, w.y); }catch(_){ } });
  // Folder settings: double-click the folder halo OR near card edges/header when cards fill the folder.
// - Double-click on empty halo space: opens folder settings.
// - When cards are packed edge-to-edge, double-click near a card edge or on the card header (within a small margin) opens folder settings.
//   Double-clicking in the middle of a card still opens the card editor as usual.
(function(){
  const EDGE_PX = 16;    // edge margin (client px)
  const HEADER_PX = 34;  // top header-ish zone (client px)

  function wantsFolderOnCardDblclick(cardEl, evt){ return true; }

  function gidFromEvent(evt){
    const w = worldFromClient(evt.clientX, evt.clientY);
    let gid = (typeof lastGroupHoverId !== "undefined" && lastGroupHoverId) ? lastGroupHoverId : null;
    if(!gid) gid = getGroupAtWorldPoint(w.x, w.y);
    if(!gid && typeof getMenuTargetFolderId === "function") gid = getMenuTargetFolderId();
    if(!gid && typeof selected !== "undefined" && selected && selected.size){
      const first = selected.values().next().value;
      const c = first ? getCardById(first) : null;
      if(c && c.groupId) gid = c.groupId;
    }
    return gid;
  }

  document.addEventListener("dblclick", (e) => {
    try{
      const hitModal = e.target.closest && e.target.closest(".modal, .modalOverlay");
      const hitMenu  = e.target.closest && e.target.closest(".menuDropdown, .menuBar, .ctxMenu");
      const hitEditable = (e.target && e.target.closest && e.target.closest('input, textarea, select, option, button, [contenteditable="true"], [contenteditable=""], .modal, .modalOverlay')) || (e.target && e.target.isContentEditable);
      if(hitModal || hitMenu || hitEditable) return;

      const hitCardEl = e.target.closest && e.target.closest(".card");
      if(hitCardEl) return; // let card dblclick open the card editor (even inside folders)

      const gid = gidFromEvent(e);
      if(!gid) return;

      e.preventDefault();
      e.stopPropagation();
      hideCtx();
      hideColorPopover();
      activeFolderId = gid;
      openFolderOverlay(gid);
    }catch(_){}
  }, true); // capture: run before card dblclick handlers
})();

// Tabs colour overlay
const tabsColorOverlay = document.getElementById("tabsColorOverlay");
const tabsColorCloseBtn = document.getElementById("tabsColorCloseBtn");
const tabsColorGrid = document.getElementById("tabsColorGrid");
const tabsColorInput = document.getElementById("tabsColorInput");
const tabsColorCustomLabel = document.getElementById("tabsColorCustomLabel");
const tabsCustomPickerPanel = document.getElementById("tabsCustomPickerPanel");
const tabsCustomPickerClose = document.getElementById("tabsCustomPickerClose");
const tabsHueSlider = document.getElementById("tabsHueSlider");
const tabsSvCanvas = document.getElementById("tabsSvCanvas");
const tabsCustomPreview = document.getElementById("tabsCustomPreview");
const tabsHexInput = document.getElementById("tabsHexInput");

  // Recent overlay
  const recentOverlay = document.getElementById("recentOverlay");
  const recentList = document.getElementById("recentList");
  const recentCloseBtn = document.getElementById("recentCloseBtn");

  // Find overlay
  const findOverlay = document.getElementById("findOverlay");
  const findInput = document.getElementById("findInput");
  const findResults = document.getElementById("findResults");
  const findMeta = document.getElementById("findMeta");
  const findCloseBtn = document.getElementById("findCloseBtn");

  // Folder settings overlay refs
  const folderOverlay = document.getElementById("folderOverlay");
  const folderCloseBtn = document.getElementById("folderCloseBtn");
  const folderNameInput = document.getElementById("folderNameInput");
  const folderShowName = document.getElementById("folderShowName");
  const folderColorGrid = document.getElementById("folderColorGrid");
  const folderRecentGrid = document.getElementById("folderRecentGrid");
  const folderColorInput = document.getElementById("folderColorInput");
  const folderCustomPickerPanel = document.getElementById("folderCustomPickerPanel");
  const folderHueSlider = document.getElementById("folderHueSlider");
  const folderSvCanvas = document.getElementById("folderSvCanvas");
  const folderCustomPreview = document.getElementById("folderCustomPreview");
  const folderHexInput = document.getElementById("folderHexInput");
  const folderOpacityInput = document.getElementById("folderOpacityInput");
  const folderOpacityLabel = document.getElementById("folderOpacityLabel");
  const folderResetBtn = document.getElementById("folderResetBtn");

  const findPrevBtn = document.getElementById("findPrevBtn");
  const findNextBtn = document.getElementById("findNextBtn");

  const menuBtns = Array.from(document.querySelectorAll(".menuBtn"));
  const dropdowns = Array.from(document.querySelectorAll(".menuDropdown"));
  // --- Critical: prevent menu clicks from reaching the board/viewport (which clears selection) ---
  // IMPORTANT: Do NOT stop propagation in capture phase, or the click won't reach the menu buttons/items.
  // We stop propagation in the bubbling phase (below) so menu handlers run, but the viewport never sees it.

  function closeAllMenus(){
    dropdowns.forEach(d => d.classList.remove("open"));
    menuBtns.forEach(b => { b.setAttribute("aria-expanded","false"); });
    dropdowns.forEach(d => d.setAttribute("aria-hidden","true"));
  }

  function toggleMenu(menuId, btn){
    const dd = document.getElementById(menuId);
    if(!dd) return;
    const isOpen = dd.classList.contains("open");
    closeAllMenus();
    if(!isOpen){
      dd.classList.add("open");
      dd.setAttribute("aria-hidden","false");
      if(btn) btn.setAttribute("aria-expanded","true");
    }
  }

  menuBtns.forEach(btn => {
    const id = btn.getAttribute("data-menu");
    btn.addEventListener("pointerdown", (e)=>{ e.preventDefault(); }); // avoid focus oddities
    btn.addEventListener("click", (e)=>{
      e.stopPropagation();
      toggleMenu(id, btn);
    });
  });

  // ---------------------------------------------------------------------------
  // Menu action routing (CAPTURE)
  // Some board listeners and selection logic use capture-phase events.
  // Depending on browser quirks (esp. Firefox), button click handlers can be
  // starved or selection can be mutated before the action runs.
  // We route menu actions here in CAPTURE so the click always triggers the
  // intended command while selection is still intact.
  // ---------------------------------------------------------------------------
  const menusRoot = document.querySelector('.menus');
  const runMenuCommand = (id)=>{
    switch(id){
      // File
      case 'menuNewHeader': createAtBestSpot({}, (lastPointerClient ? worldFromClient(lastPointerClient.x, lastPointerClient.y) : null)); break;
      case 'menuNewBlank':  createAtBestSpot({ blank:true }, (lastPointerClient ? worldFromClient(lastPointerClient.x, lastPointerClient.y) : null)); break;
      case 'menuSaveAs': saveAs(); break;
      case 'menuOpen': try{ openProject.value=''; openProject.click(); }catch(_){ } break;
      case 'menuOpenRecent': openRecentOverlay(); break;
      case 'menuExportPng': exportPNG(); break;
      case 'btnExport': btnExport?.click(); break;
      case 'btnImport': btnImport?.click(); break;
      case 'btnClear':  btnClear?.click(); break;

      // Edit
      case 'menuUndo': undo(); break;
      case 'menuRedo': redo(); break;
      case 'menuCut': cutCards(); break;
      case 'menuCopy': copyCards(); break;
      case 'menuPaste': pasteCards(); break;
      case 'menuSelectAll': selectAllCards(); break;
      case 'menuLockToggle': toggleLockSelected(); break;
      case 'menuGroup': groupSelectedIntoFolder(); break;
      case 'menuUngroup': if(selected.size){ pushHistory(); ungroupIds(Array.from(selected)); save(); render(); } break;
      case 'menuDuplicate': duplicateSelected(); break;
      case 'menuDelete': deleteSelected(); break;

      // View
      case 'btnCenter': centerView(); break;
      case 'menuToggleGrid': toggleGrid(); break;
      case 'menuPresentation': togglePresentation(); break;

      // Tabs
      case 'menuTabsColor': openTabsColorOverlay(); break;
      case 'menuTabsStrikeToggle': toggleStrikeSelected(); break;
      case 'menuZoomIn': zoomAt(window.innerWidth/2, window.innerHeight/2, 1.12); break;
      case 'menuZoomOut': zoomAt(window.innerWidth/2, window.innerHeight/2, 1/1.12); break;
      case 'menuZoomReset': resetZoom(); break;
      default: return false;
    }
    return true;
  };

  // Delegate menu item actions on POINTERDOWN (capture), then stop further propagation.
// Why: some selection logic runs on click/mouseup and can clear selection before the menu action executes.
// Using pointerdown ensures the action runs while the current selection is still intact (and works reliably in Firefox).
menusRoot?.addEventListener('pointerdown', (e)=>{
  const item = e.target?.closest?.('.menuItem');
  if(!item || !item.id) return;
  if(item.disabled) return;

  // Allow native label -> file input activation (Firefox-friendly)
  if(item.id === 'menuImportImages') return;
  // Prevent focus changes / text selection and stop the board from seeing this gesture.
  e.preventDefault();
  e.stopPropagation();
  if(e.stopImmediatePropagation) e.stopImmediatePropagation();

  const ran = runMenuCommand(item.id);
  if(ran){
    closeAllMenus();
    // Ensure any follow-up click on the viewport doesn't clear selection as a side-effect.
    try{ window.__BB?.setSuppressNextClick?.(true); }catch(_){}
  }
}, true);

  // IMPORTANT: Prevent menu interactions from being swallowed by board listeners
  // (Firefox can sometimes route the click through to the underlying viewport).
  // This keeps selection intact and ensures menu item clicks always fire.
  const menubarPanel = document.querySelector(".menubar");
  const stopMenuEvt = (e)=>{ e.stopPropagation(); };
  // Use bubbling listeners (NOT capture) so button/menu item handlers still run.
  menubarPanel?.addEventListener("mousedown", stopMenuEvt);
  menubarPanel?.addEventListener("click", stopMenuEvt);
  menubarPanel?.addEventListener("pointerdown", stopMenuEvt);
  // Also stop events on dropdowns/items just to be safe.
  dropdowns.forEach(dd=>{
    dd.addEventListener("mousedown", stopMenuEvt);
    dd.addEventListener("click", stopMenuEvt);
    dd.addEventListener("pointerdown", stopMenuEvt);
  });

  // Close menus on outside click / ESC
  document.addEventListener("pointerdown", (e)=>{
    const inside = e.target && (e.target.closest?.(".menuDropdown") || e.target.closest?.(".menuBtn"));
    if(!inside) closeAllMenus();
  });
  document.addEventListener("keydown", (e)=>{
    if(e.key === "Escape"){
      closeAllMenus();
      // Presentation mode uses ESC to exit
      if(isPresentation) exitPresentation();
      // Close recents overlay if open
      if(recentOverlay && recentOverlay.style.display !== "none") closeRecentOverlay();
      // Close find overlay if open
      if(findOverlay && findOverlay.style.display !== "none") closeFindOverlay();
    }
  });

  function isRectFree(x,y,w,h, ignoreId=null){
  for(const c of cards){
    if(ignoreId && c.id === ignoreId) continue;
    if(
      x < c.x + w && x + w > c.x &&
      y < c.y + h && y + h > c.y
    ){
      return false;
    }
  }
  return true;
}

function createAtBestSpot(opts, preferWorld){
  const { w: cardW, h: cardH } = getCardDims();
  const gap = 18;

  // Prefer: next to currently selected card (writer intent: add adjacent beat)
  let anchor = null;
  if(selectedId){
    anchor = cards.find(c => c.id === selectedId) || null;
  } else if(selected && selected.size){
    const last = Array.from(selected).pop();
    anchor = cards.find(c => c.id === last) || null;
  }
  // If nothing is selected, but we have a preferred spawn point (eg. rightâ€‘click),
  // snap next to the nearest card to that point (so you don't have to select first).
  if(!anchor && preferWorld){
    const px = preferWorld.x, py = preferWorld.y;

    const rectDist = (c)=>{
      const rx1 = c.x, ry1 = c.y, rx2 = c.x + cardW, ry2 = c.y + cardH;
      const dx = (px < rx1) ? (rx1 - px) : (px > rx2) ? (px - rx2) : 0;
      const dy = (py < ry1) ? (ry1 - py) : (py > ry2) ? (py - ry2) : 0;
      return Math.hypot(dx, dy);
    };

    let best = null;
    let bestD = Infinity;
    for(const c of cards){
      // ignore struck? no, allow snapping beside struck too; ignore if locked? still ok.
      const d = rectDist(c);
      if(d < bestD){ bestD = d; best = c; }
    }

    // Only snap if we're reasonably close to a card (or inside it).
    // This keeps "new card at empty space" behaviour intact.
    const maxSnap = Math.max(220, Math.max(cardW, cardH) * 0.65);
    if(best && bestD <= maxSnap){
      anchor = best;
    }
  }


  if(anchor){
    const OFF = {
      right: { dx:  (cardW + gap), dy: 0 },
      left:  { dx: -(cardW + gap), dy: 0 },
      below: { dx: 0, dy:  (cardH + gap) },
      above: { dx: 0, dy: -(cardH + gap) },
      br:    { dx:  (cardW + gap), dy:  (cardH + gap) },
      ar:    { dx:  (cardW + gap), dy: -(cardH + gap) },
      bl:    { dx: -(cardW + gap), dy:  (cardH + gap) },
      al:    { dx: -(cardW + gap), dy: -(cardH + gap) },
    };

    const opposite = (d)=> (d==="right"?"left":d==="left"?"right":d==="above"?"below":"above");

    // Default preference if we don't have an anchor point.
    let primary = "right";
    let secondary = "below";

    // If the user created the card near a specific point (mouse / touch),
    // infer intent: if they clicked above a card, prefer "above", etc.
    if(preferWorld){
      const ax = anchor.x + cardW/2;
      const ay = anchor.y + cardH/2;
      const dx = preferWorld.x - ax;
      const dy = preferWorld.y - ay;

      const adx = Math.abs(dx);
      const ady = Math.abs(dy);
      const bias = 1.10; // small bias toward the dominant axis

      if(ady > adx * bias){
        primary = (dy > 0) ? "below" : "above";
        secondary = (dx > 0) ? "right" : "left";
      } else if(adx > ady * bias){
        primary = (dx > 0) ? "right" : "left";
        secondary = (dy > 0) ? "below" : "above";
      } else {
        // Near-diagonal: keep it intuitive (quadrant)
        primary = (dx > 0) ? "right" : "left";
        secondary = (dy > 0) ? "below" : "above";
      }
    }

    const diagPref = (preferWorld)
      ? (( (preferWorld.x - (anchor.x + cardW/2)) >= 0 ? "r" : "l") + ( (preferWorld.y - (anchor.y + cardH/2)) >= 0 ? "b" : "a"))
      : "br";

    const diagMap = { rb:"br", ra:"ar", lb:"bl", la:"al" };
    const diagKey = diagMap[diagPref] || "br";

    // Ordered candidates: intended side first, then secondary, then opposites, then diagonals.
    const candidates = [
      OFF[primary],
      OFF[secondary],
      OFF[opposite(primary)],
      OFF[opposite(secondary)],
      OFF[diagKey],
      OFF.br, OFF.ar, OFF.bl, OFF.al,
    ].filter(Boolean);

    // De-dupe offsets (e.g., if diagKey repeats)
    const seen = new Set();
    const uniq = [];
    for(const p of candidates){
      const k = `${p.dx},${p.dy}`;
      if(seen.has(k)) continue;
      seen.add(k);
      uniq.push(p);
    }

    for(const p of uniq){
      const nx = Math.round(anchor.x + p.dx);
      const ny = Math.round(anchor.y + p.dy);
      if(isRectFree(nx, ny, cardW, cardH)){
        createCardAt(nx, ny, opts || {});
        return;
      }
    }

    // Fallback: stack to the right with a small vertical offset until free
    for(let i=1;i<50;i++){
      const nx = Math.round(anchor.x + (cardW + gap));
      const ny = Math.round(anchor.y + i * (gap));
      if(isRectFree(nx, ny, cardW, cardH)){
        createCardAt(nx, ny, opts || {});
        return;
      }
    }
  }

  // Default: center of viewport (or provided world point)
  const p = preferWorld || worldFromClient(window.innerWidth/2, window.innerHeight/2);
  createCardAt(Math.round(p.x - cardW/2), Math.round(p.y - cardH/2), opts || {});
}

  function zoomAt(clientX, clientY, factor){
    const before = worldFromClient(clientX, clientY);
    view.scale = clamp(view.scale * factor, 0.25, 3.0);
    const after = worldFromClient(clientX, clientY);
    view.x += (after.x - before.x) * view.scale;
    view.y += (after.y - before.y) * view.scale;
    applyView();
    save();
  }


  function getDocumentSnapshot(){
    return {
      version: "beatboard",
      createdAt: new Date().toISOString(),
      view,
      gridVisible,
      cards
    };
  }

  function downloadJson(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 5000);
  }

  function downloadText(filename, text, mime="text/plain"){
    const blob = new Blob([text], {type:mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 5000);
  }

  function exportMarkdown(){
    closeAllMenus();
    if(cards.length === 0) return;

    const d = new Date();
    const pad2 = (n)=> String(n).padStart(2,"0");
    const name = `beat-board-${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}.md`;

    // Group cards by folder (groupId) while preserving a readable order.
    const groups = new Map();
    for(const c of cards){
      const gid = c.groupId || "__ungrouped__";
      if(!groups.has(gid)) groups.set(gid, []);
      groups.get(gid).push(c);
    }

    // Order groups by their top-leftmost card position.
    const groupList = Array.from(groups.entries()).map(([gid, arr])=>{
      let minX=Infinity, minY=Infinity;
      for(const c of arr){
        minX = Math.min(minX, c.x);
        minY = Math.min(minY, c.y);
      }
      return {gid, arr, minX, minY};
    }).sort((a,b)=> (a.minY-b.minY) || (a.minX-b.minX));

    let md = `# Beat Board Export\n\n`;
    md += `Exported: ${d.toLocaleString()}\n\n`;

    for(const g of groupList){
      const isUngrouped = g.gid === "__ungrouped__";
      const title = isUngrouped ? "Ungrouped" : `Folder (${g.arr.length} cards)`;
      md += `## ${title}\n\n`;

      const arr = g.arr.slice().sort((a,b)=> (a.y-b.y) || (a.x-b.x));

      for(const c of arr){
        const isImg = c.type === "image";
        const cardTitle = (c.title||"").trim() || (isImg ? (c.imgName||"Image") : "Card");
        md += `### ${cardTitle.replace(/\n/g," ").trim()}\n\n`;

        if(isImg){
          const dataUrl = getImageDataUrl(c.imgId);
          if(dataUrl && dataUrl.startsWith("data:image/") && dataUrl.length < 800000){
            md += `![${(c.imgName||cardTitle).replace(/\n/g," ").trim()}](${dataUrl})\n\n`;
          } else {
            md += `_(Image: ${(c.imgName||"Image").replace(/\n/g," ").trim()})_\n\n`;
          }
        }

        const body = stripHtmlToText(c.body||"").trim();
        if(body){
          md += body + "\n\n";
        } else {
          md += "_(empty)_\n\n";
        }
      }
    }

    downloadText(name, md, "text/markdown");
  }

  function getRecents(){
    try{
      const raw = localStorage.getItem(RECENTS_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr : [];
    }catch(e){ return []; }
  }
  function setRecents(arr){
    try{ localStorage.setItem(RECENTS_KEY, JSON.stringify(arr.slice(0,5))); }catch(e){}
  }

  function saveAs(){
    closeAllMenus();
    const snap = getDocumentSnapshot();
    const d = new Date();
    const pad = (n)=> String(n).padStart(2,"0");
    const name = `beat-board-${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}.json`;

    // Store in recents (keep full payload locally)
    const recents = getRecents();
    recents.unshift({ name, ts: Date.now(), data: snap });
    const dedup = [];
    const seen = new Set();
    for(const r of recents){
      if(!r || !r.name || seen.has(r.name)) continue;
      seen.add(r.name);
      dedup.push(r);
    }
    setRecents(dedup);

    downloadJson(name, snap);
  }

  function openRecentOverlay(){
    closeAllMenus();
    if(!recentOverlay || !recentList) return;

    const recents = getRecents();
    recentList.innerHTML = "";

    if(recents.length === 0){
      const empty = document.createElement("div");
      empty.style.padding = "10px";
      empty.style.borderRadius = "12px";
      empty.style.border = "1px solid rgba(255,255,255,0.10)";
      empty.style.color = "rgba(255,255,255,0.70)";
      empty.textContent = "No recent files yet. Use File â†’ Save Asâ€¦ first.";
      recentList.appendChild(empty);
    } else {
      for(const r of recents.slice(0,5)){
        const row = document.createElement("button");
        row.type = "button";
        row.className = "menuItem";
        row.style.border = "1px solid rgba(255,255,255,0.10)";
        row.style.background = "rgba(255,255,255,0.04)";
        row.style.padding = "12px";
        const date = new Date(r.ts || Date.now());
        row.innerHTML = `<span>${escapeHtml(r.name || "Untitled")}</span><span class="ctxKey">${escapeHtml(date.toLocaleString())}</span>`;
        row.addEventListener("click", ()=>{
          try{
            const data = r.data;
            if(!data || !Array.isArray(data.cards) || !data.view) return;
            pushHistory();
            view = data.view;
            gridVisible = !!data.gridVisible;
            cards = data.cards;
            cards.forEach(c=>{
if(!("preset" in c)) c.preset = c.color || "neutral";
              if(!("customColor" in c)) c.customColor = null;
              if(!("noHeader" in c)) c.noHeader = false;
              if(!("locked" in c)) c.locked = false;
              if(!("struck" in c)) c.struck = false;
          if(!("groupId" in c)) c.groupId = null;
            
              if(!("type" in c)) c.type = "text";
              if(!("w" in c)) c.w = null;
              if(!("h" in c)) c.h = null;
              if(c.type === "image"){
                if(!("imgId" in c)) c.imgId = null;
                // Migration: older boards stored images directly on the card (c.img).
                // Move that data into the image store to keep saves fast.
                if(!c.imgId && c.img){
                  const mid = uid();
                  putImageDataUrl(mid, c.img);
                  c.imgId = mid;
                  try{ delete c.img; } catch(e){ c.img = null; }
                }
                if(!("imgName" in c)) c.imgName = c.title || "Image";
                if(!("w" in c)) c.w = null;
                if(!("h" in c)) c.h = null;
                if(!("noHeader" in c)) c.noHeader = true;
              }
            });
            selected.clear();
            selectedId = null;
            render();
            save();
          }catch(e){}
          closeRecentOverlay();
        });
        recentList.appendChild(row);
      }
    }

    recentOverlay.style.display = "flex";
  }

  function closeRecentOverlay(){
    if(recentOverlay) recentOverlay.style.display = "none";
  }


// Tabs actions
let tabsColorBatchActive = false;
function openTabsColorOverlay(){
  closeAllMenus();
  if(!tabsColorOverlay) return;
  if(selected.size === 0) return; // nothing selected

  // reset any in-progress batch
  tabsColorBatchActive = false;
  if(tabsCustomPickerPanel) tabsCustomPickerPanel.style.display = "block";

  // Seed to first selected card's colour
  const first = cards.find(c=> selected.has(c.id));
  const seed = (first && (first.customColor || getComputedStyle(document.documentElement).getPropertyValue(`--${first.preset || "neutral"}`).trim())) || "#c9c9c9";
  if(tabsColorInput) tabsColorInput.value = seed || "#c9c9c9";
  if(tabsCustomPreview) tabsCustomPreview.style.background = tabsColorInput.value;
  if(tabsHexInput) tabsHexInput.value = tabsColorInput.value;

  tabsColorOverlay.style.display = "flex";
  try{ renderTabsRecentColors(seed); }catch(e){}
}
function closeTabsColorOverlay(){
if(tabsCustomPickerPanel) tabsCustomPickerPanel.style.display = "none";
  tabsColorBatchActive = false;
  try{
    const hex = (tabsHexInput && tabsHexInput.value) ? tabsHexInput.value : (tabsColorInput ? tabsColorInput.value : null);
    if(hex) pushRecentColor(hex);
  }catch(e){}
  if(tabsColorOverlay) tabsColorOverlay.style.display = "none";
}
tabsColorCloseBtn?.addEventListener("click", closeTabsColorOverlay);
tabsColorOverlay?.addEventListener("mousedown", (e)=>{ if(e.target === tabsColorOverlay) closeTabsColorOverlay(); });

/* Tabs custom colour picker (same UI as editor) */
(function initTabsCustomPicker(){
  try{
    if(!tabsColorCustomLabel || !tabsColorInput) return;

    let H = 210, S = 0.55, V = 1.0;
    const clamp01 = (x)=> Math.max(0, Math.min(1, x));

    function hsvToRgb(h, s, v){
      const c = v * s;
      const hh = (h % 360) / 60;
      const x = c * (1 - Math.abs((hh % 2) - 1));
      let r=0,g=0,b=0;
      if(hh>=0 && hh<1){ r=c; g=x; b=0; }
      else if(hh<2){ r=x; g=c; b=0; }
      else if(hh<3){ r=0; g=c; b=x; }
      else if(hh<4){ r=0; g=x; b=c; }
      else if(hh<5){ r=x; g=0; b=c; }
      else { r=c; g=0; b=x; }
      const m = v - c;
      return { r: Math.round((r+m)*255), g: Math.round((g+m)*255), b: Math.round((b+m)*255) };
    }
    function rgbToHex(r,g,b){
      const to = (n)=> n.toString(16).padStart(2,"0");
      return "#" + to(r) + to(g) + to(b);
    }
    function hexToRgb(hex){
      const h = String(hex||"").trim().replace(/^#/,"");
      if(h.length===3){
        return { r: parseInt(h[0]+h[0],16), g: parseInt(h[1]+h[1],16), b: parseInt(h[2]+h[2],16) };
      }
      if(h.length===6){
        return { r: parseInt(h.slice(0,2),16), g: parseInt(h.slice(2,4),16), b: parseInt(h.slice(4,6),16) };
      }
      return null;
    }
    function rgbToHsv(r,g,b){
      r/=255; g/=255; b/=255;
      const max = Math.max(r,g,b), min = Math.min(r,g,b);
      const d = max - min;
      let h=0;
      if(d===0) h=0;
      else if(max===r) h = 60 * (((g-b)/d) % 6);
      else if(max===g) h = 60 * (((b-r)/d) + 2);
      else h = 60 * (((r-g)/d) + 4);
      if(h<0) h += 360;
      const s = max===0 ? 0 : d/max;
      const v = max;
      return {h,s,v};
    }

    function commit(hex, {push}){
      tabsColorInput.value = hex;
      if(tabsCustomPreview) tabsCustomPreview.style.background = hex;
      if(tabsHexInput) tabsHexInput.value = hex;
      if(push) tabsColorBatchActive = true;
      applyColorToSelected({ custom: hex }, { push });
    }

    function drawSV(){
      if(!tabsSvCanvas) return;
      const ctx = tabsSvCanvas.getContext("2d");
      const w = tabsSvCanvas.width, h = tabsSvCanvas.height;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = `hsl(${H}, 100%, 50%)`;
      ctx.fillRect(0,0,w,h);

      const gW = ctx.createLinearGradient(0,0,w,0);
      gW.addColorStop(0, "rgba(255,255,255,1)");
      gW.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = gW;
      ctx.fillRect(0,0,w,h);

      const gB = ctx.createLinearGradient(0,0,0,h);
      gB.addColorStop(0, "rgba(0,0,0,0)");
      gB.addColorStop(1, "rgba(0,0,0,1)");
      ctx.fillStyle = gB;
      ctx.fillRect(0,0,w,h);

      const x = S * w;
      const y = (1 - V) * h;
      ctx.beginPath();
      ctx.arc(x, y, 6, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(x, y, 7.5, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(0,0,0,0.45)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function setFromHSV(){
      const {r,g,b} = hsvToRgb(H,S,V);
      const hex = rgbToHex(r,g,b);
      const push = !tabsColorBatchActive;
      commit(hex, {push});
    }

    function openPicker(){
      // If panel/canvas not present, fall back to system picker
      if(!tabsCustomPickerPanel || !tabsSvCanvas || !tabsHueSlider){
        tabsColorInput.click();
        return;
      }
      // Seed from current
      const rgb = hexToRgb(tabsColorInput.value);
      if(rgb){
        const hsv = rgbToHsv(rgb.r,rgb.g,rgb.b);
        H = hsv.h; S = hsv.s; V = hsv.v;
      }
      tabsHueSlider.value = String(Math.round(H));
      tabsCustomPickerPanel.style.display = "block";
      drawSV();
      // Don't auto-commit here; commit happens via interactions / hex input
      if(tabsCustomPreview) tabsCustomPreview.style.background = tabsColorInput.value;
      if(tabsHexInput) tabsHexInput.value = tabsColorInput.value;
    }

    function closePicker(){
      if(tabsCustomPickerPanel) tabsCustomPickerPanel.style.display = "block";
    }

    tabsColorCustomLabel.addEventListener("click", (e)=>{
      e.preventDefault();
      openPicker();
    });

    tabsCustomPickerClose?.addEventListener("click", (e)=>{ e.preventDefault(); closePicker(); });

    tabsHueSlider?.addEventListener("input", ()=>{
      H = parseFloat(tabsHueSlider.value || "0");
      drawSV();
      setFromHSV();
    });

    let dragging = false;
    function handleSV(ev){
      const rect = tabsSvCanvas.getBoundingClientRect();
      const x = clamp01((ev.clientX - rect.left) / rect.width);
      const y = clamp01((ev.clientY - rect.top) / rect.height);
      S = x;
      V = 1 - y;
      drawSV();
      setFromHSV();
    }

    if(tabsSvCanvas){
      tabsSvCanvas.addEventListener("mousedown", (e)=>{ dragging=true; handleSV(e); });
      window.addEventListener("mousemove", (e)=>{ if(dragging) handleSV(e); });
      window.addEventListener("mouseup", ()=>{
        if(dragging){
          dragging = false;
          folderMaybePushRecent(folderColorInput.value);
        }
      });

      tabsSvCanvas.addEventListener("touchstart", (e)=>{ dragging=true; if(e.touches[0]) handleSV(e.touches[0]); }, {passive:true});
      window.addEventListener("touchmove", (e)=>{ if(dragging && e.touches[0]) handleSV(e.touches[0]); }, {passive:true});
      window.addEventListener("touchend", ()=>{
        if(dragging){
          dragging = false;
          folderMaybePushRecent(folderColorInput.value);
        }
      });
    }

    tabsHexInput?.addEventListener("input", ()=>{
      const rgb = hexToRgb(tabsHexInput.value);
      if(!rgb) return;
      const hex = rgbToHex(rgb.r,rgb.g,rgb.b);
      const push = !tabsColorBatchActive;
      commit(hex, {push});
    });

  }catch(err){
    // Absolute safety: if anything goes wrong, keep native picker working
    try{
      if(tabsColorCustomLabel && tabsColorInput){
        tabsColorCustomLabel.addEventListener("click", () => tabsColorInput.click());
      }
    }catch(e){}
    console.warn("Tabs custom picker disabled:", err);
  }
})();

function applyColorToSelected({ preset=null, custom=null } = {}, { push=true } = {}){
  if(selected.size === 0) return;
  if(push) pushHistory();
  // Apply to currently selected cards
  for(const c of cards){
    if(!selected.has(c.id)) continue;
    if(c.locked) continue; // respect locks
    if(custom){
      c.customColor = custom;
      c.preset = c.preset || "neutral";
    }else if(preset){
      c.preset = preset;
      c.customColor = null;
    }
  }
  save();
  render();
}

tabsColorGrid?.addEventListener("click", (e)=>{
  const btn = e.target?.closest?.(".tabsSwatchBtn");
  if(!btn) return;

  // Preset swatches (act1/act2/act3/neutral)
  const preset = btn.getAttribute("data-preset");
  const hexAttr = btn.getAttribute("data-hex");

  tabsColorBatchActive = false;

  if(preset){
    applyColorToSelected({ preset }, { push: true });
    try{
      const cs = getComputedStyle(document.documentElement);
      const val = cs.getPropertyValue(`--${preset || "neutral"}`).trim() || cs.getPropertyValue("--neutral").trim();
      if(val) pushRecentColor(val);
    }catch(e){}
    closeTabsColorOverlay();
    return;
  }

  // Extra default swatches (explicit hex)
  if(hexAttr){
    const hex = String(hexAttr).trim();
    if(!hex) return;
    applyColorToSelected({ custom: hex }, { push: true });
    pushRecentColor(hex);
    closeTabsColorOverlay();
  }
});

tabsColorInput?.addEventListener("input", ()=>{
  const val = tabsColorInput.value;
  if(!val) return;
  // Native/system picker may emit multiple input events while dragging.
  const push = !tabsColorBatchActive;
  if(push) tabsColorBatchActive = true;
  applyColorToSelected({ custom: val }, { push });
});

function toggleStrikeSelected(){
  if(selected.size === 0) return;
  pushHistory();
  const selCards = cards.filter(c => selected.has(c.id));
  const allStruck = selCards.length > 0 && selCards.every(c=>!!c.struck);
  for(const c of selCards){
    c.struck = !allStruck;
  }
  save();
  render();
}
  recentCloseBtn?.addEventListener("click", closeRecentOverlay);
  recentOverlay?.addEventListener("mousedown", (e)=>{ if(e.target === recentOverlay) closeRecentOverlay(); });

  /* ---------- Find overlay ---------- */
  function closeFindOverlay(){
    if(findOverlay) findOverlay.style.display = "none";
    findMatches = new Set();
    findOrder = [];
    findIndex = -1;
    render();
  }
  function openFindOverlay(seed=""){
    closeAllMenus();
    if(!findOverlay || !findInput || !findResults) return;
    findOverlay.style.display = "flex";
    findInput.value = seed || "";
    setTimeout(()=>{ try{ findInput.focus(); findInput.select(); }catch(e){} }, 0);
    runFind(findInput.value);
  }
  function normalizeText(s){
    return (s||"").toString().toLowerCase();
  }
  function cardSearchText(c){
    const title = (c.title||"");
    const body = stripHtmlToText(c.body||"");
    const img = (c.type==="image" ? (c.imgName||"") : "");
    return `${title}\n${body}\n${img}`;
  }
  function runFind(q){
    if(!findResults) return;
    const query = normalizeText(q).trim();
    findMatches = new Set();
    findOrder = [];
    findIndex = -1;
    findResults.innerHTML = "";
    if(findMeta) findMeta.textContent = "";

    if(!query){
      render();
      if(findMeta) findMeta.textContent = "Type to search.";
      return;
    }

    // Rank: title hits > body hits > image-name hits, then spatial order.
    const ranked = [];
    for(const c of cards){
      const t = normalizeText(c.title||"");
      const b = normalizeText(stripHtmlToText(c.body||""));
      const i = normalizeText((c.type==="image" ? (c.imgName||"") : ""));
      let score = 0;
      if(t.includes(query)) score += 6;
      if(i.includes(query)) score += 4;
      if(b.includes(query)) score += 2;
      if(score>0){
        ranked.push({c, score});
      }
    }
    ranked.sort((a,b)=>{
      if(b.score!==a.score) return b.score-a.score;
      // spatial order
      if(a.c.y!==b.c.y) return a.c.y-b.c.y;
      return a.c.x-b.c.x;
    });

    for(const r of ranked){
      const c = r.c;
      findMatches.add(c.id);
      findOrder.push(c.id);

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "findResultBtn";
      const title = (c.title||"").trim() || (c.type==="image" ? (c.imgName||"Image") : "Card");
      const chip = c.type==="image" ? "Image" : "Text";
      const snippet = (stripHtmlToText(c.body||"") || "").trim().replace(/\s+/g," ");
      const short = snippet.length>160 ? (snippet.slice(0,160) + "â€¦") : snippet;

      btn.innerHTML = `
        <div class="findResultTop">
          <div class="findResultTitle">${escapeHtml(title)}</div>
          <div class="findResultChip">${escapeHtml(chip)}</div>
        </div>
        <div class="findResultSnippet">${escapeHtml(short || "")}</div>
      `;
      btn.addEventListener("click", ()=>{
        focusCardById(c.id);
      });
      findResults.appendChild(btn);
    }

    render();
    if(findMeta){
      findMeta.textContent = ranked.length ? `${ranked.length} result${ranked.length===1?"":"s"}.` : "No matches.";
    }
    if(findOrder.length){
      findIndex = 0;
      focusCardById(findOrder[0], {quiet:true});
    }
  }

  function focusCardById(id, opts={}){
    const c = getCardById(id);
    if(!c) return;
    selected = new Set([id]);
    selectedId = id;
    syncSelectionClasses();

    // Center camera on the card
    const { w: baseW, h: baseH } = getCardDims();
    const w = (c.w || baseW);
    const h = (c.h || baseH);
    const cx = c.x + w/2;
    const cy = c.y + h/2;

    const vx = window.innerWidth/2;
    const vy = window.innerHeight/2;

    view.x = vx - (cx * view.scale);
    view.y = vy - (cy * view.scale);
    applyView();
    save();
    render();

    if(!opts.quiet && findInput){
      try{ findInput.focus(); }catch(e){}
    }
  }

  function stepFind(dir){
    if(!findOrder.length) return;
    findIndex = (findIndex + dir) % findOrder.length;
    if(findIndex < 0) findIndex = findOrder.length-1;
    const id = findOrder[findIndex];
    focusCardById(id, {quiet:true});
    if(findMeta) findMeta.textContent = `${findOrder.length} result${findOrder.length===1?"":"s"} â€” ${findIndex+1}/${findOrder.length}`;
  }

  findCloseBtn?.addEventListener("click", closeFindOverlay);
  findOverlay?.addEventListener("mousedown", (e)=>{ if(e.target === findOverlay) closeFindOverlay(); });

  function closeFolderOverlay(){
    if(!folderOverlay) return;
    // Commit the last chosen folder colour to recents only when the panel closes.
    if(__folderPendingRecentColor){
      folderPushRecentColor(__folderPendingRecentColor);
      __folderPendingRecentColor = "";
    }
    folderOverlay.style.display = "none";
  }

  function openFolderOverlay(gid){
    if(!folderOverlay) return;
    if(!gid) return;
    activeFolderId = gid;
    folderHistoryPushed = false;
    __folderPendingRecentColor = "";

    const gs = getGroupStyle(gid);
    if(folderNameInput) folderNameInput.value = gs.name || "";
    if(folderShowName) folderShowName.checked = !!gs.showName;
    if(folderColorInput) folderColorInput.value = gs.color || "#ffffff";
    try{ window.__BB?.seedFolderPickerFromHex?.(folderColorInput.value || "#ffffff"); }catch(_){ }
    if(folderOpacityInput) folderOpacityInput.value = Math.round((gs.opacity ?? 0.20) * 100);
    if(folderOpacityLabel) folderOpacityLabel.textContent = `${folderOpacityInput.value}%`;

    folderSetPreview(folderColorInput?.value || "#ffffff");
    folderSyncSwatches();
    renderFolderRecentColors();

    folderOverlay.style.display = "flex";
    setTimeout(()=>{ try{ folderNameInput?.focus(); folderNameInput?.select(); }catch(_){ } }, 0);
  }

  // --- Folders top-menu helpers ---
  const menuFolderSettings = document.getElementById("menuFolderSettings");
  const menuFolderMoreVisible = document.getElementById("menuFolderMoreVisible");
  const menuFolderLessVisible = document.getElementById("menuFolderLessVisible");
  const menuFolderToggleLabel = document.getElementById("menuFolderToggleLabel");
  const menuFolderRename = document.getElementById("menuFolderRename");

  function getMenuTargetFolderId(){
    // 1) Prefer folder under cursor (halo area)
    if(lastGroupHoverId) return lastGroupHoverId;

    // 2) If selection is inside a single folder, use that
    if(selected && selected.size){
      let gid = null;
      for(const id of selected){
        const c = cards.find(cc=>cc.id===id);
        if(!c || !c.groupId) continue;
        if(gid === null) gid = c.groupId;
        else if(gid !== c.groupId){ gid = null; break; }
      }
      if(gid) return gid;
    }

    // 3) Fallback: primary selected card's folder
    if(selectedId){
      const c = cards.find(cc=>cc.id===selectedId);
      if(c && c.groupId) return c.groupId;
    }

    return null;
  }

  function withMenuFolder(fn){
    const gid = getMenuTargetFolderId();
    if(!gid){
      toast("Hover a folder (halo) or select a card inside a folder first.");
      return;
    }
    fn(gid);
    save(true);
    draw();
  }

  menuFolderSettings?.addEventListener("click", ()=>{
    withMenuFolder((gid)=>openFolderOverlay(gid));
  });

  menuFolderMoreVisible?.addEventListener("click", ()=>{
    withMenuFolder((gid)=>{
      const gs = getGroupStyle(gid);
      const next = clamp01((gs.opacity ?? 0.20) + 0.10);
      groupStyles = groupStyles || {};
      groupStyles[gid] = Object.assign({}, gs, { opacity: next });
    });
  });

  menuFolderLessVisible?.addEventListener("click", ()=>{
    withMenuFolder((gid)=>{
      const gs = getGroupStyle(gid);
      const next = clamp01((gs.opacity ?? 0.20) - 0.10);
      groupStyles = groupStyles || {};
      groupStyles[gid] = Object.assign({}, gs, { opacity: next });
    });
  });

  menuFolderToggleLabel?.addEventListener("click", ()=>{
    withMenuFolder((gid)=>{
      const gs = getGroupStyle(gid);
      groupStyles = groupStyles || {};
      groupStyles[gid] = Object.assign({}, gs, { showName: !gs.showName });
    });
  });

  menuFolderRename?.addEventListener("click", ()=>{
    withMenuFolder((gid)=>{
      const gs = getGroupStyle(gid);
      const cur = gs.name || "";
      const name = prompt("Folder name:", cur);
      if(name === null) return; // cancelled
      groupStyles = groupStyles || {};
      groupStyles[gid] = Object.assign({}, gs, { name: name.trim(), showName: true });
    });
  });

  folderCloseBtn?.addEventListener("click", closeFolderOverlay);
  folderOverlay?.addEventListener("mousedown", (e)=>{ if(e.target === folderOverlay) closeFolderOverlay(); });
  folderOverlay?.addEventListener("click", (e)=>{ if(e.target === folderOverlay) closeFolderOverlay(); });
  folderOverlay?.addEventListener("touchstart", (e)=>{ if(e.target === folderOverlay) closeFolderOverlay(); }, {passive:true});
  folderOpacityInput?.addEventListener("input", ()=>{ if(folderOpacityLabel) folderOpacityLabel.textContent = `${folderOpacityInput.value}%`; });

  // Folder settings (realtime)
  let folderRealtimeRAF = 0;
  let folderHistoryPushed = false;

  function folderScheduleRenderSave(){
    if(folderRealtimeRAF) return;
    folderRealtimeRAF = requestAnimationFrame(()=>{
      folderRealtimeRAF = 0;
      render();
      save(true);
    });
  }
  function folderEnsureHistory(){
    if(folderHistoryPushed) return;
    folderHistoryPushed = true;
    pushHistory();
  }
  function folderSetPreview(hex){
    try{ if(folderCustomPreview) folderCustomPreview.style.background = hex; }catch(_){ }
    try{ if(folderHexInput) folderHexInput.value = hex; }catch(_){ }
  }
function folderPresetToHex(preset){
    const root = getComputedStyle(document.documentElement);
    if(preset === "act1") return (root.getPropertyValue("--act1") || "#9bbf7e").trim();
    if(preset === "act2") return (root.getPropertyValue("--act2") || "#7ea7c7").trim();
    if(preset === "act3") return (root.getPropertyValue("--act3") || "#c98983").trim();
    if(preset === "neutral") return "#bfbfbf";
    return "#ffffff";
  }

  // Folder recent colours (local only)
  const FOLDER_RECENT_KEY = "bb_recent_folder_colors_v1";
  let folderRecentColors = [];
  let __folderPendingRecentColor = "";
  function loadFolderRecentColors(){
    try{
      const raw = localStorage.getItem(FOLDER_RECENT_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      if(!Array.isArray(arr)){ folderRecentColors = []; return; }

      // Normalize + de-dupe (so "#FFE699" and "#ffe699" don't become separate recents)
      const seen = new Set();
      const out = [];
      for(const v of arr){
        if(typeof v !== "string") continue;
        let h = v.trim().toLowerCase();
        if(!h) continue;

        // Expand #rgb to #rrggbb
        if(/^#[0-9a-f]{3}$/i.test(h)){
          h = "#" + h[1]+h[1] + h[2]+h[2] + h[3]+h[3];
        }
        if(!/^#[0-9a-f]{6}$/i.test(h)) continue;

        if(seen.has(h)) continue;
        seen.add(h);
        out.push(h);
        if(out.length >= 7) break;
      }
      folderRecentColors = out;
    }catch(_){
      folderRecentColors = [];
    }
  }
  function saveFolderRecentColors(){
    try{ localStorage.setItem(FOLDER_RECENT_KEY, JSON.stringify(folderRecentColors.slice(0,7))); }catch(_){}
  }
  function folderPushRecentColor(hex){
    let h = String(hex || "").trim().toLowerCase();
    if(!h) return;

    // Expand #rgb to #rrggbb
    if(/^#[0-9a-f]{3}$/i.test(h)){
      h = "#" + h[1]+h[1] + h[2]+h[2] + h[3]+h[3];
    }
    if(!/^#[0-9a-f]{6}$/i.test(h)) return;

    // Normalize existing list too (older saves may have mixed case/whitespace)
    const seen = new Set([h]);
    const next = [h];
    for(const v of (folderRecentColors || [])){
      if(typeof v !== "string") continue;
      let x = v.trim().toLowerCase();
      if(/^#[0-9a-f]{3}$/i.test(x)){
        x = "#" + x[1]+x[1] + x[2]+x[2] + x[3]+x[3];
      }
      if(!/^#[0-9a-f]{6}$/i.test(x)) continue;
      if(seen.has(x)) continue;
      seen.add(x);
      next.push(x);
      if(next.length >= 7) break;
    }
    folderRecentColors = next;

    saveFolderRecentColors();
    renderFolderRecentColors();
  }
  
  // Push into folder recents, but only on "commit" events (prevents the custom picker from spamming near-identical colours)
  let __folderLastRecentPushed = "";
  let __folderLastRecentAt = 0;
  function folderMaybePushRecent(hex){
    // Stage the most recently chosen colour; we only commit it to recents when the panel closes.
    let h = String(hex || "").trim().toLowerCase();
    if(/^#[0-9a-f]{3}$/i.test(h)){
      h = "#" + h[1]+h[1] + h[2]+h[2] + h[3]+h[3];
    }
    if(!/^#[0-9a-f]{6}$/i.test(h)) return;
    __folderPendingRecentColor = h;
  }

function renderFolderRecentColors(){
    if(!folderRecentGrid) return;
    folderRecentGrid.innerHTML = "";
    if(Array.isArray(folderRecentColors) && folderRecentColors.length > 7){ folderRecentColors = folderRecentColors.slice(0,7); }
    const cur = (folderColorInput?.value || "").trim().toLowerCase();
    folderRecentColors.forEach(h=>{
      const b = document.createElement("button");
      b.type="button";
      b.className = "tabsSwatchBtn" + (h===cur ? " active" : "");
      b.setAttribute("data-hex", h);
      b.title = h;
      const s = document.createElement("span");
      s.className = "tabsSwatch";
      s.style.background = h;
      b.appendChild(s);
      folderRecentGrid.appendChild(b);
    });
    // If empty, show nothing (keeps layout tight)
    folderRecentGrid.style.display = folderRecentColors.length ? "flex" : "none";
  }
  loadFolderRecentColors();

  function folderSyncSwatches(){
    if(!folderColorGrid) return;
    const btns = Array.from(folderColorGrid.querySelectorAll(".tabsSwatchBtn"));
    const cur = (folderColorInput?.value || "").toLowerCase();
    btns.forEach(b=>b.classList.remove("active"));
    // Recent buttons
    try{
      folderRecentGrid?.querySelectorAll?.(".tabsSwatchBtn")?.forEach?.(b=>b.classList.remove("active"));
    }catch(_){ }


    for(const b of btns){
      const preset = b.getAttribute("data-preset");
      const hexAttr = b.getAttribute("data-hex");
      let hx = "";
      if(preset){
        hx = folderPresetToHex(preset);
      }else if(hexAttr){
        hx = hexAttr;
      }
      hx = (hx || "").trim().toLowerCase();
      if(hx && cur && hx === cur){
        b.classList.add("active");
        return;
      }
    renderFolderRecentColors();
    }
  }

  function folderApplyRealtime(){
    if(!activeFolderId) return;
    folderEnsureHistory();

    const name = (folderNameInput?.value || "").trim();
    const showName = !!folderShowName?.checked;
    const color = folderColorInput?.value || "#ffffff";
const op = clamp01((parseInt(folderOpacityInput?.value || "20",10) || 0) / 100);

    groupStyles[activeFolderId] = { color, opacity: op, name, showName };
    folderSetPreview(color);
    folderSyncSwatches();
    folderScheduleRenderSave();
  }

  folderResetBtn?.addEventListener("click", ()=>{
    if(!activeFolderId) return;
    folderEnsureHistory();
    delete groupStyles[activeFolderId];
    // Reset controls to defaults and apply instantly
    const gs = getGroupStyle(activeFolderId);
    if(folderNameInput) folderNameInput.value = gs.name || "";
    if(folderShowName) folderShowName.checked = !!gs.showName;
    if(folderColorInput) folderColorInput.value = gs.color || "#ffffff";
    if(folderOpacityInput) folderOpacityInput.value = Math.round((gs.opacity ?? 0.20) * 100);
    if(folderOpacityLabel) folderOpacityLabel.textContent = `${folderOpacityInput.value}%`;
    folderSetPreview(folderColorInput?.value || "#ffffff");
    folderSyncSwatches();
    folderScheduleRenderSave();
  });

  folderNameInput?.addEventListener("input", folderApplyRealtime);
  folderShowName?.addEventListener("change", folderApplyRealtime);
  folderOpacityInput?.addEventListener("input", ()=>{
    if(folderOpacityLabel) folderOpacityLabel.textContent = `${folderOpacityInput.value}%`;
    folderApplyRealtime();
  });
  folderColorInput?.addEventListener("input", folderApplyRealtime);

  /* Folder custom colour picker (same UI as Tabs Colour panel) */
  (function initFolderCustomPicker(){
    try{
      if(!folderColorInput || !folderCustomPickerPanel || !folderSvCanvas || !folderHueSlider || !folderCustomPreview || !folderHexInput) return;

      let H = 210, S = 0.55, V = 1.0;
      const clamp01 = (x)=> Math.max(0, Math.min(1, x));

      function hsvToRgb(h, s, v){
        const c = v * s;
        const hh = (h % 360) / 60;
        const x = c * (1 - Math.abs((hh % 2) - 1));
        let r=0,g=0,b=0;
        if(hh>=0 && hh<1){ r=c; g=x; b=0; }
        else if(hh<2){ r=x; g=c; b=0; }
        else if(hh<3){ r=0; g=c; b=x; }
        else if(hh<4){ r=0; g=x; b=c; }
        else if(hh<5){ r=x; g=0; b=c; }
        else { r=c; g=0; b=x; }
        const m = v - c;
        return { r: Math.round((r+m)*255), g: Math.round((g+m)*255), b: Math.round((b+m)*255) };
      }
      function rgbToHex2(r,g,b){
        const to = (n)=> n.toString(16).padStart(2,"0");
        return "#" + to(r) + to(g) + to(b);
      }
      function hexToRgb(hex){
        const h = String(hex||"").trim().replace(/^#/,"");
        if(h.length===3){
          return { r: parseInt(h[0]+h[0],16), g: parseInt(h[1]+h[1],16), b: parseInt(h[2]+h[2],16) };
        }
        if(h.length===6){
          return { r: parseInt(h.slice(0,2),16), g: parseInt(h.slice(2,4),16), b: parseInt(h.slice(4,6),16) };
        }
        return null;
      }
      function rgbToHsv(r,g,b){
        r/=255; g/=255; b/=255;
        const max = Math.max(r,g,b), min = Math.min(r,g,b);
        const d = max - min;
        let h=0;
        if(d===0) h=0;
        else if(max===r) h = 60 * (((g-b)/d) % 6);
        else if(max===g) h = 60 * (((b-r)/d) + 2);
        else h = 60 * (((r-g)/d) + 4);
        if(h<0) h += 360;
        const s = max===0 ? 0 : d/max;
        const v = max;
        return {h,s,v};
      }

      function commit(hex){
        // pipeline -> realtime apply (recents are pushed only on commit/end events)
        folderColorInput.value = hex;
        folderSetPreview(hex);
        folderSyncSwatches();
        folderApplyRealtime();
      }

      function drawSV(){
        const ctx = folderSvCanvas.getContext("2d");
        const w = folderSvCanvas.width, h = folderSvCanvas.height;
        ctx.clearRect(0,0,w,h);
        ctx.fillStyle = `hsl(${H}, 100%, 50%)`;
        ctx.fillRect(0,0,w,h);

        const gW = ctx.createLinearGradient(0,0,w,0);
        gW.addColorStop(0, "rgba(255,255,255,1)");
        gW.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = gW;
        ctx.fillRect(0,0,w,h);

        const gB = ctx.createLinearGradient(0,0,0,h);
        gB.addColorStop(0, "rgba(0,0,0,0)");
        gB.addColorStop(1, "rgba(0,0,0,1)");
        ctx.fillStyle = gB;
        ctx.fillRect(0,0,w,h);

        const x = S * w;
        const y = (1 - V) * h;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.95)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x, y, 7.5, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(0,0,0,0.45)";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function setFromHSV(){
        const {r,g,b} = hsvToRgb(H,S,V);
        commit(rgbToHex2(r,g,b));
      }

      function seedFromHex(hex){
        const rgb = hexToRgb(hex);
        if(rgb){
          const hsv = rgbToHsv(rgb.r,rgb.g,rgb.b);
          H = hsv.h; S = hsv.s; V = hsv.v;
          folderHueSlider.value = String(Math.round(H));
          drawSV();
          folderSetPreview(hex);
          if(folderHexInput) folderHexInput.value = hex;
        }
      }

      // expose for openFolderOverlay to seed
      window.__BB = window.__BB || {};
      window.__BB.seedFolderPickerFromHex = seedFromHex;

      folderHueSlider.addEventListener("input", ()=>{
        H = parseFloat(folderHueSlider.value || "0");
        drawSV();
        setFromHSV();
      });
      folderHueSlider.addEventListener("change", ()=>{
        folderMaybePushRecent(folderColorInput.value);
      });

      let dragging = false;
      function handleSV(ev){
        const rect = folderSvCanvas.getBoundingClientRect();
        const x = clamp01((ev.clientX - rect.left) / rect.width);
        const y = clamp01((ev.clientY - rect.top) / rect.height);
        S = x;
        V = 1 - y;
        drawSV();
        setFromHSV();
      }

      folderSvCanvas.addEventListener("mousedown", (e)=>{ dragging=true; handleSV(e); });
      window.addEventListener("mousemove", (e)=>{ if(dragging) handleSV(e); });
      window.addEventListener("mouseup", ()=>{
        if(dragging){
          dragging = false;
          folderMaybePushRecent(folderColorInput.value);
        }
      });

      folderSvCanvas.addEventListener("touchstart", (e)=>{ dragging=true; if(e.touches[0]) handleSV(e.touches[0]); }, {passive:true});
      window.addEventListener("touchmove", (e)=>{ if(dragging && e.touches[0]) handleSV(e.touches[0]); }, {passive:true});
      window.addEventListener("touchend", ()=>{
        if(dragging){
          dragging = false;
          folderMaybePushRecent(folderColorInput.value);
        }
      });

      folderHexInput.addEventListener("input", ()=>{
        const rgb = hexToRgb(folderHexInput.value);
        if(!rgb) return;
        const hex = rgbToHex2(rgb.r,rgb.g,rgb.b);
        commit(hex);
        seedFromHex(hex);
      });

      folderHexInput.addEventListener("blur", ()=>{
        folderMaybePushRecent(folderColorInput.value);
      });
      folderHexInput.addEventListener("keydown", (e)=>{
        if(e.key === "Enter"){
          e.preventDefault();
          folderHexInput.blur();
        }
      });

      // Seed initial
      seedFromHex(folderColorInput.value || "#ffffff");

    }catch(err){
      console.warn("Folder custom picker disabled:", err);
    }
  })();


  folderColorGrid?.addEventListener("click", (e)=>{
    const btn = e.target?.closest?.(".tabsSwatchBtn");
    if(!btn) return;

    const preset = btn.getAttribute("data-preset");
    const hexAttr = btn.getAttribute("data-hex");

    let v = "#ffffff";
    if(preset){
      v = folderPresetToHex(preset).trim();
    }else if(hexAttr){
      v = String(hexAttr).trim();
    }

    if(/^rgb/i.test(v)){
      try{ v = rgbToHex(v); }catch(_){}
    }
    if(!v.startsWith("#")) v = "#ffffff";

    if(folderColorInput){
      folderColorInput.value = v;
      folderSetPreview(v);
      folderSyncSwatches();
      folderMaybePushRecent(v);
      folderApplyRealtime();
    }
  });

  folderRecentGrid?.addEventListener("click", (e)=>{
    const btn = e.target?.closest?.(".tabsSwatchBtn");
    if(!btn) return;
    const hx = (btn.getAttribute("data-hex") || "").trim();
    if(!hx) return;
    folderColorInput.value = hx;
    try{ window.__BB?.seedFolderPickerFromHex?.(hx); }catch(_){ }
    folderSetPreview(hx);
    folderSyncSwatches();
    folderMaybePushRecent(hx);
    folderApplyRealtime();
  });



  findPrevBtn?.addEventListener("click", ()=> stepFind(-1));
  findNextBtn?.addEventListener("click", ()=> stepFind(1));
  findInput?.addEventListener("input", ()=> runFind(findInput.value));
  findInput?.addEventListener("keydown", (e)=>{
    if(e.key === "Enter"){
      e.preventDefault();
      stepFind(1);
    } else if(e.key === "Escape"){
      e.preventDefault();
      closeFindOverlay();
    }
  });

  // Clipboard helpers (cards only)
  function setClipboard(payload){
    try{ localStorage.setItem(CLIPBOARD_KEY, JSON.stringify(payload)); }catch(e){}
  }
  function getClipboard(){
    try{
      const raw = localStorage.getItem(CLIPBOARD_KEY);
      const parsed = raw ? JSON.parse(raw) : null;
      return parsed && Array.isArray(parsed.cards) ? parsed : null;
    }catch(e){ return null; }
  }

  function copyCards(){
    closeAllMenus();
    if(selected.size === 0) return;
    const selCards = cards.filter(c => selected.has(c.id));
    if(selCards.length === 0) return;

    const minX = Math.min(...selCards.map(c=>c.x));
    const minY = Math.min(...selCards.map(c=>c.y));

    setClipboard({
      ts: Date.now(),
      cards: selCards.map(c => {
        const cc = structuredClone(c);
        delete cc.id;
        cc.x = cc.x - minX;
        cc.y = cc.y - minY;
        return cc;
      })
    });
  }

  function cutCards(){
    closeAllMenus();
    if(selected.size === 0) return;
    copyCards();
    deleteSelected();
  }

  function pasteCards(){
    closeAllMenus();
    const clip = getClipboard();
    if(!clip || !clip.cards || clip.cards.length === 0) return;

    pushHistory();

    const anchor = worldFromClient(lastPointerClient.x, lastPointerClient.y);
    const baseX = Math.round(anchor.x);
    const baseY = Math.round(anchor.y);

    const newIds = [];
    for(const proto of clip.cards){
      const nc = {
        ...structuredClone(proto),
        id: uid(),
        x: baseX + (proto.x || 0),
        y: baseY + (proto.y || 0)
      };
      if(!("preset" in nc)) nc.preset = "neutral";
      if(!("customColor" in nc)) nc.customColor = null;
      if(!("noHeader" in nc)) nc.noHeader = false;
      if(!("locked" in nc)) nc.locked = false;
      if(!("struck" in nc)) nc.struck = false;
      cards.push(nc);
      newIds.push(nc.id);
    }

    selected = new Set(newIds);
    selectedId = newIds[newIds.length-1] || null;

    save();
    render();
  }

  function selectAllCards(){
    closeAllMenus();
    selected = new Set(cards.map(c=>c.id));
    selectedId = cards.length ? cards[cards.length-1].id : null;
    syncSelectionClasses();
  }

  function toggleLockSelected(){
    closeAllMenus();
    if(selected.size === 0) return;
    pushHistory();
    const selCards = cards.filter(c => selected.has(c.id));
    const allLocked = selCards.length > 0 && selCards.every(c=>c.locked);
    for(const c of selCards){
      c.locked = !allLocked;
    }
    save();
    render();
  }

  function toggleGrid(){
    closeAllMenus();
    gridVisible = !gridVisible;
    updateGridClass();
    save();
  }

  function enterPresentation(){
    if(isPresentation) return;
    closeAllMenus();
    isPresentation = true;
    _presentPrev = { gridVisible, view: { ...view } };
    document.body.classList.add("bbPresent");
    gridVisible = false;
    updateGridClass();
    zoomAt(window.innerWidth/2, window.innerHeight/2, 1.15);
  }

  function exitPresentation(){
    if(!isPresentation) return;
    isPresentation = false;
    document.body.classList.remove("bbPresent");
    if(_presentPrev){
      gridVisible = _presentPrev.gridVisible;
      view = _presentPrev.view;
      _presentPrev = null;
      applyView();
      updateGridClass();
      save();
      render();
    }
  }

  function togglePresentation(){
    if(isPresentation) exitPresentation();
    else enterPresentation();
  }

  function stripHtmlToText(html){
    const tmp = document.createElement("div");
    tmp.innerHTML = html || "";
    // Replace images with a readable placeholder so the board preview shows something.
    tmp.querySelectorAll("img").forEach(img=>{
      const label = img.getAttribute("alt") || "Image";
      const span = document.createElement("span");
      span.textContent = `ðŸ–¼ ${label} `;
      img.replaceWith(span);
    });
    return (tmp.innerText || "").replace(/\r\n/g,"\n");
  }

  function exportPNG(){
    closeAllMenus();
    if(cards.length === 0) return;

    const { w: cardW, h: cardH } = getCardDims();
    const pad = 60;
    const scale = 2;

    
const exportCards = cards.filter(c=>!c.struck);
if(exportCards.length === 0) return;

const minX = Math.min(...exportCards.map(c=>c.x));
const minY = Math.min(...exportCards.map(c=>c.y));
const maxX = Math.max(...exportCards.map(c=>c.x + cardW));
const maxY = Math.max(...exportCards.map(c=>c.y + cardH));

    const width = Math.ceil((maxX - minX) + pad*2);
    const height = Math.ceil((maxY - minY) + pad*2);

    const canvas = document.createElement("canvas");
    canvas.width = width * scale;
    canvas.height = height * scale;
    const ctx = canvas.getContext("2d");
    ctx.scale(scale, scale);

    const cs = getComputedStyle(document.documentElement);
    const bg = cs.getPropertyValue("--bg").trim() || "#0f1115";
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,width,height);

    function getPresetColor(preset){
      const key = `--${preset || "neutral"}`;
      const val = cs.getPropertyValue(key).trim();
      return val || cs.getPropertyValue("--neutral").trim() || "#c9c9c9";
    }

    function roundRect(x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }

    function wrapText(text, x, y, maxWidth, lineHeight, maxLines){
      const words = text.split(/\s+/);
      let line = "";
      let lines = 0;
      for(let i=0;i<words.length;i++){
        const test = line ? (line + " " + words[i]) : words[i];
        if(ctx.measureText(test).width > maxWidth && line){
          ctx.fillText(line, x, y);
          y += lineHeight;
          lines++;
          line = words[i];
          if(maxLines && lines >= maxLines) return;
        } else {
          line = test;
        }
      }
      if(line && (!maxLines || lines < maxLines)){
        ctx.fillText(line, x, y);
      }
    }

    const radius = parseInt(cs.getPropertyValue("--radius")) || 14;

    for(const c of cards){
      const x = (c.x - minX) + pad;
      const y = (c.y - minY) + pad;

      const fill = c.customColor ? c.customColor : getPresetColor(c.preset);
      roundRect(x,y,cardW,cardH,radius);
      ctx.fillStyle = fill;
      ctx.fill();

      ctx.strokeStyle = "rgba(0,0,0,0.18)";
      ctx.lineWidth = 1;
      ctx.stroke();

      const innerX = x + 16;
      const innerW = cardW - 32;

      let bodyTop = y + 18;
      if(!c.noHeader){
        const stripH = 44;
        roundRect(x,y,cardW,stripH,radius);
        ctx.fillStyle = "rgba(0,0,0,0.10)";
        ctx.fill();

        ctx.fillStyle = "rgba(0,0,0,0.18)";
        ctx.fillRect(x, y+stripH-1, cardW, 1);

        ctx.fillStyle = "rgba(0,0,0,0.82)";
        ctx.font = "800 13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textBaseline = "middle";
        const title = (c.title || "").toUpperCase() || "BEAT";
        ctx.fillText(title, innerX, y + stripH/2);
        bodyTop = y + stripH + 12;
      }

      ctx.fillStyle = "rgba(0,0,0,0.78)";
      ctx.font = "13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textBaseline = "top";
      const bodyText = stripHtmlToText(c.body || "");
      const linesMax = Math.floor((y + cardH - 16 - bodyTop) / 16);
      wrapText(bodyText.replace(/\n/g," "), innerX, bodyTop, innerW, 16, linesMax);

      if(c.locked){
        ctx.fillStyle = "rgba(0,0,0,0.30)";
        ctx.font = "12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textBaseline = "top";
        ctx.fillText("ðŸ”’", x + cardW - 24, y + 12);
      }
    }

    const a = document.createElement("a");
    const d = new Date();
    const pad2 = (n)=> String(n).padStart(2,"0");
    a.download = `beat-board-${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}.png`;
    a.href = canvas.toDataURL("image/png");
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  menuNewHeader?.addEventListener("click", ()=>{ closeAllMenus(); createAtBestSpot({}, (lastPointerClient ? worldFromClient(lastPointerClient.x, lastPointerClient.y) : null)); });
  menuNewBlank?.addEventListener("click",  ()=>{ closeAllMenus(); createAtBestSpot({ blank: true }); });

  menuSaveAs?.addEventListener("click", saveAs);
  menuOpenRecent?.addEventListener("click", openRecentOverlay);
  menuExportPng?.addEventListener("click", exportPNG);
  menuExportMd?.addEventListener("click", exportMarkdown);

  /* ---------- Import Images ---------- */
  function makeImgHtml(dataUrl, filename){
    const safeName = (filename || "Image").replace(/</g,"&lt;").replace(/>/g,"&gt;");
    return `<div><img src="${dataUrl}" alt="${safeName}"/></div><div>${safeName}</div>`;
  }

  function insertImageIntoEditor(dataUrl, filename){
    if(!editBody) return;
    editBody.innerHTML = sanitizeHtml((editBody.innerHTML || "") + makeImgHtml(dataUrl, filename));
  }

  async function getScaledImageDims(dataUrl){
    // Try to size new image cards based on the actual image aspect ratio.
    // Clamp to a comfortable range so large images don't dominate the board.
    const maxW = 1000, maxH = 800;
    const minW = 420, minH = 320;

    try{
      const img = new Image();
      img.decoding = "async";
        img.addEventListener("dragstart", (e)=>{ try{ e.preventDefault(); }catch(_){ } });
      img.src = dataUrl;
      await (img.decode ? img.decode() : new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; }));
      const nw = img.naturalWidth || 0;
      const nh = img.naturalHeight || 0;
      if(nw > 0 && nh > 0){
        const scale = Math.min(maxW / nw, maxH / nh, 1);
        let w = Math.round(nw * scale);
        let h = Math.round(nh * scale);
        // Ensure minimum size while keeping aspect
        const minScale = Math.max(minW / w, minH / h, 1);
        w = Math.round(w * minScale);
        h = Math.round(h * minScale);
        return { w: clamp(w, minW, maxW), h: clamp(h, minH, maxH) };
      }
    }catch(_){ }

    // Fallback
    return { w: 480, h: 360 };
  }

  function createImageCard(imgId, filename, worldPoint, size){
    const p = worldPoint || worldFromClient(window.innerWidth/2, window.innerHeight/2);
    const w0 = (size && size.w) ? size.w : 480;
    const h0 = (size && size.h) ? size.h : 360;

    // Create a dedicated image card type so we don't bloat regular text bodies with huge data URLs.
    const id = uid();
    const imgCard = {
      id,
      type: "image",
      title: (filename || "Image"),
      imgName: (filename || "Image"),
      imgId: imgId,
      x: Math.round(p.x - w0/2),
      y: Math.round(p.y - h0/2),
      // Image cards have their own sizing, independent of text cards
      w: w0,
      h: h0,
      body: "",
      preset: "neutral",
      customColor: null,
      noHeader: true,
      locked: false,
      struck: false,
      groupId: null
    };

    pushHistory();
    cards.push(imgCard);
    save(true);
    render();
    selectCard(id);
  }


  function isEditorOpen(){
    // modalOverlay exists in this build; it's shown when editing a card
    return (modalOverlay && modalOverlay.style.display !== "none" && !!editingCardId);
  }

  // Close menus after clicking the import label (lets native file picker open)
  menuImportImages?.addEventListener("click", ()=>{ setTimeout(closeAllMenus, 0); });


  // ---------- Open Project (.json) ----------
  openProject?.addEventListener("change", async (e)=>{
    try{
      const file = e.target && e.target.files && e.target.files[0];
      if(!file) return;
      const r = new FileReader();
      r.onload = ()=>{
        try{
          const parsed = JSON.parse(String(r.result || "{}"));
          if(!parsed || !Array.isArray(parsed.cards) || !parsed.view) throw new Error("Invalid project file.");
          pushHistory();
          view = parsed.view;
          gridVisible = !!parsed.gridVisible;
          cards = parsed.cards;

          // Migrations / defaults (match Open Recent behaviour)
          cards.forEach(c=>{
            if(!("preset" in c)) c.preset = c.color || "neutral";
            if(!("customColor" in c)) c.customColor = null;
            if(!("noHeader" in c)) c.noHeader = false;
            if(!("locked" in c)) c.locked = false;
            if(!("struck" in c)) c.struck = false;
            if(!("groupId" in c)) c.groupId = null;
            if(!("type" in c)) c.type = "text";
            if(!("w" in c)) c.w = null;
            if(!("h" in c)) c.h = null;

            if(c.type === "image"){
              if(!("imgId" in c)) c.imgId = null;
              if(!c.imgId && c.img){
                const mid = uid();
                putImageDataUrl(mid, c.img);
                c.imgId = mid;
                try{ delete c.img; }catch(_){ c.img = null; }
              }
              if(!("imgName" in c)) c.imgName = c.title || "Image";
              if(!("noHeader" in c)) c.noHeader = true;
            }
          });

          selected.clear();
          selectedId = null;

          // Add to recents using filename
          try{ addRecent(file.name || "Untitled", { view, cards, gridVisible }); }catch(_){}

          save(true);
          render();
        }catch(err){
          alert("Open failed:\n" + (err && err.message ? err.message : String(err)));
        }
      };
      r.onerror = ()=>{ alert("Open failed: could not read file."); };
      r.readAsText(file);
    }finally{
      try{ openProject.value = ""; }catch(_){}
    }
  });


  imgImport?.addEventListener("change", async (e)=>{
    const files = Array.from(e.target.files || []).filter(f => /^image\//i.test(f.type));
    if(files.length === 0) return;

    const editorOpen = isEditorOpen();
    const base = worldFromClient(window.innerWidth/2, window.innerHeight/2);

    for(let i=0; i<files.length; i++){
      const file = files[i];

      // Compress on import so large photos don't tank performance.
      let dataUrl = null;
      try{
        dataUrl = await compressImageFileToDataUrl(file, 1600, 0.78);
      } catch(err){
        console.warn("Image compress failed, falling back to raw read:", err);
        dataUrl = await new Promise((resolve, reject)=>{
          const r = new FileReader();
          r.onload = ()=>resolve(r.result);
          r.onerror = ()=>reject(new Error("Image read failed"));
          r.readAsDataURL(file);
        });
      }

      if(editorOpen){
        insertImageIntoEditor(dataUrl, file.name);
      } else {
        const imgId = uid();
        putImageDataUrl(imgId, dataUrl);

        const offset = 30 * i;
        const size = await getScaledImageDims(dataUrl);
        createImageCard(imgId, file.name, { x: base.x + offset, y: base.y + offset }, size);
      }
    }

    // Reset so selecting the same file again triggers change
    try{ imgImport.value = ""; } catch(e){}
    setTimeout(closeAllMenus, 0);
  });


  menuUndo?.addEventListener("click", ()=>{ closeAllMenus(); undo(); });
  menuRedo?.addEventListener("click", ()=>{ closeAllMenus(); redo(); });

  menuCut?.addEventListener("click", cutCards);
  menuCopy?.addEventListener("click", copyCards);
  menuPaste?.addEventListener("click", pasteCards);
  menuSelectAll?.addEventListener("click", selectAllCards);
  menuFind?.addEventListener("click", ()=> openFindOverlay(findInput ? findInput.value : ""));
  menuLockToggle?.addEventListener("click", toggleLockSelected);
  menuDuplicate?.addEventListener("click", ()=>{
    closeAllMenus();
    duplicateSelected();
  });
  menuDelete?.addEventListener("click", ()=>{ closeAllMenus(); deleteSelected(); });

  menuZoomIn?.addEventListener("click", ()=>{ closeAllMenus(); zoomAt(window.innerWidth/2, window.innerHeight/2, 1.10); });
  menuZoomOut?.addEventListener("click", ()=>{ closeAllMenus(); zoomAt(window.innerWidth/2, window.innerHeight/2, 0.90); });
  menuZoomReset?.addEventListener("click", ()=>{
    closeAllMenus();
    const cx = window.innerWidth/2, cy = window.innerHeight/2;
    const before = worldFromClient(cx, cy);
    view.scale = 1;
    const after = worldFromClient(cx, cy);
    view.x += (after.x - before.x) * view.scale;
    view.y += (after.y - before.y) * view.scale;
    applyView();
    save();
  });

  menuToggleGrid?.addEventListener("click", toggleGrid);
  menuPresentation?.addEventListener("click", togglePresentation);



menuTabsColor?.addEventListener("click", openTabsColorOverlay);
menuTabsStrikeToggle?.addEventListener("click", ()=>{ closeAllMenus(); toggleStrikeSelected(); });


  // Editor
  const modalOverlay = document.getElementById("modalOverlay");
  let __editorCloseOnClick = null;
  let __editorKeyHandler = null;
  const modalTitle = document.getElementById("modalTitle");
  const btnCloseModal = document.getElementById("btnCloseModal");
  const editTitle = document.getElementById("editTitle");
  const editBody = document.getElementById("editBody");

  // Enable native right-click menu for spelling suggestions inside the editor
  // (and prevent the board context menu from hijacking it).
  if(editTitle){
    editTitle.setAttribute("spellcheck","true");
    editTitle.addEventListener("contextmenu", (e)=>{ try{ e.stopPropagation(); }catch(_){} });
  }
  if(editBody){
    editBody.setAttribute("spellcheck","true");
    editBody.addEventListener("contextmenu", (e)=>{ try{ e.stopPropagation(); }catch(_){} });
  }


  // --- Make the writing area obvious (visible box + placeholder) ---
  function _isEffectivelyEmpty(el){
    if(!el) return true;
    // Treat whitespace-only, a lone <br>, or empty HTML as empty.
    const html = (el.innerHTML || "").replace(/\u200b/g, "");
    const cleaned = html
      .replace(/<br\s*\/?\s*>/gi, "")
      .replace(/&nbsp;/gi, " ")
      .trim();
    if(cleaned) return false;
    const text = (el.innerText || "").replace(/\u200b/g, "").trim();
    return !text;
  }

  function _syncEditBodyEmptyState(){
    if(!editBody) return;
    editBody.setAttribute("data-placeholder", "Write hereâ€¦");
    editBody.setAttribute("data-empty", _isEffectivelyEmpty(editBody) ? "true" : "false");
  }

  if(editBody){
    // Keep placeholder state correct while typing/pasting.
    ["input","keyup","paste","cut","blur","focus"].forEach(evt => {
      editBody.addEventListener(evt, _syncEditBodyEmptyState);
    });
    // Initial state
    _syncEditBodyEmptyState();
  }

  const btnBold = document.getElementById("btnBold");
  const btnUnderline = document.getElementById("btnUnderline");
  const btnItalic = document.getElementById("btnItalic");

  // Preserve selection inside the rich editor so clicking the button doesn't destroy it.
  let lastRange = null;
  function captureRange(){
    const sel = window.getSelection();
    if(!sel || sel.rangeCount === 0) return;
    const r = sel.getRangeAt(0);
    // Only capture if selection is inside the editor body
    if(editBody && editBody.contains(r.commonAncestorContainer)){
      lastRange = r.cloneRange();
    }
  }
  document.addEventListener("selectionchange", captureRange);

  function restoreRange(){
    if(!lastRange) return;
    const sel = window.getSelection();
    if(!sel) return;
    sel.removeAllRanges();
    sel.addRange(lastRange);
  }

  function sanitizeHtml(input){
    // Allow a small safe subset of tags for formatting.
    const allowed = new Set(["B","BR","DIV","EM","I","LI","OL","P","STRONG","U","UL","IMG"]);
    const tmp = document.createElement("div");
    tmp.innerHTML = input || "";
    const walk = (node) => {
      [...node.childNodes].forEach(ch => {
        if(ch.nodeType === 1){ // element
          if(!allowed.has(ch.tagName)){
            // unwrap disallowed tag but keep its children
            const frag = document.createDocumentFragment();
            while(ch.firstChild) frag.appendChild(ch.firstChild);
            ch.replaceWith(frag);
          } else {
            // strip attributes (except safe IMG src/alt)
            if(ch.tagName === "IMG"){
              const src = ch.getAttribute("src") || "";
              const alt = ch.getAttribute("alt") || "";
              // Allow only data:image/*, blob:, or http(s) URLs
              const ok = /^data:image\//i.test(src) || /^blob:/i.test(src) || /^https?:\/\//i.test(src);
              [...ch.attributes].forEach(a => ch.removeAttribute(a.name));
              if(ok) ch.setAttribute("src", src);
              if(alt) ch.setAttribute("alt", alt.slice(0, 200));
            } else {
              [...ch.attributes].forEach(a => ch.removeAttribute(a.name));
            }
            walk(ch);
          }
        } else if(ch.nodeType === 3){
          // text ok
        } else {
          // remove comments/other nodes
          ch.remove();
        }
      });
    };
    walk(tmp);
    return tmp.innerHTML;
  }

  function plainToHtml(text){
    const esc = (s)=> (s||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
    return esc(text||"").replace(/\n/g,"<br>");
  }

  function htmlToPlain(html){
    const tmp = document.createElement("div");
    tmp.innerHTML = html || "";
    return (tmp.innerText || "").replace(/\r\n/g,"\n");
  }

  function wrapBold(){
    if(!editBody || !lastRange) return;

    // Restore the user's selection
    const range = lastRange.cloneRange();
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    // Helper: find nearest STRONG ancestor inside editor
    const getStrongAncestor = (node) => {
      let n = node;
      while(n && n !== editBody){
        if(n.nodeType === 1 && (n.tagName === "STRONG" || n.tagName === "B")) return n;
        n = n.parentNode;
      }
      return null;
    };

    const aStrong = getStrongAncestor(range.startContainer);
    const bStrong = getStrongAncestor(range.endContainer);

    // If the selection is wholly inside the same STRONG/B, unwrap it (toggle off)
    if(aStrong && aStrong === bStrong){
      const strong = aStrong;

      // --- Preserve selection using temporary markers ---
      const markStart = document.createElement("span");
      const markEnd = document.createElement("span");
      markStart.setAttribute("data-bbmark","s");
      markEnd.setAttribute("data-bbmark","e");
      // Invisible markers that won't affect layout
      markStart.style.display = "inline-block";
      markStart.style.width = "0";
      markStart.style.height = "0";
      markStart.style.overflow = "hidden";
      markEnd.style.display = "inline-block";
      markEnd.style.width = "0";
      markEnd.style.height = "0";
      markEnd.style.overflow = "hidden";

      // Insert markers at the exact selection boundaries
      const r1 = range.cloneRange();
      r1.collapse(true);
      r1.insertNode(markStart);

      const r2 = range.cloneRange();
      r2.collapse(false);
      r2.insertNode(markEnd);

      // Unwrap: replace <strong> with its children
      const parent = strong.parentNode;
      while(strong.firstChild){
        parent.insertBefore(strong.firstChild, strong);
      }
      parent.removeChild(strong);

      // Restore selection between markers
      const s = editBody.querySelector('span[data-bbmark="s"]');
      const e = editBody.querySelector('span[data-bbmark="e"]');
      if(s && e){
        const newRange = document.createRange();
        newRange.setStartAfter(s);
        newRange.setEndBefore(e);
        sel.removeAllRanges();
        sel.addRange(newRange);

        // Clean up markers
        s.remove();
        e.remove();

        // Update stored range
        captureRange();
      } else {
        // Fallback: just recapture
        captureRange();
      }
      return;
    }

    // Otherwise wrap selection in <strong> (toggle on)
    const strong = document.createElement("strong");
    try{
      range.surroundContents(strong);
    } catch(e){
      const contents = range.extractContents();
      strong.appendChild(contents);
      range.insertNode(strong);
    }

    // Reselect wrapped content
    sel.removeAllRanges();
    const outRange = document.createRange();
    outRange.selectNodeContents(strong);
    sel.addRange(outRange);

    captureRange();
  }

  function wrapUnderline(){
    if(!editBody || !lastRange) return;

    const range = lastRange.cloneRange();
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    const getUAncestor = (node) => {
      let n = node;
      while(n && n !== editBody){
        if(n.nodeType === 1 && n.tagName === "U") return n;
        n = n.parentNode;
      }
      return null;
    };

    const aU = getUAncestor(range.startContainer);
    const bU = getUAncestor(range.endContainer);

    // Toggle off if selection is wholly inside same <u>
    if(aU && aU === bU){
      const u = aU;

      // markers to preserve selection
      const markStart = document.createElement("span");
      const markEnd = document.createElement("span");
      markStart.setAttribute("data-bbmark","us");
      markEnd.setAttribute("data-bbmark","ue");
      for(const m of [markStart, markEnd]){
        m.style.display = "inline-block";
        m.style.width = "0";
        m.style.height = "0";
        m.style.overflow = "hidden";
      }

      const r1 = range.cloneRange(); r1.collapse(true); r1.insertNode(markStart);
      const r2 = range.cloneRange(); r2.collapse(false); r2.insertNode(markEnd);

      const parent = u.parentNode;
      while(u.firstChild){
        parent.insertBefore(u.firstChild, u);
      }
      parent.removeChild(u);

      const s = editBody.querySelector('span[data-bbmark="us"]');
      const e = editBody.querySelector('span[data-bbmark="ue"]');
      if(s && e){
        const newRange = document.createRange();
        newRange.setStartAfter(s);
        newRange.setEndBefore(e);
        sel.removeAllRanges();
        sel.addRange(newRange);
        s.remove(); e.remove();
        captureRange();
      } else {
        captureRange();
      }
      return;
    }

    // Toggle on: wrap selection with <u>
    const u = document.createElement("u");
    try{
      range.surroundContents(u);
    } catch(e){
      const contents = range.extractContents();
      u.appendChild(contents);
      range.insertNode(u);
    }

    sel.removeAllRanges();
    const outRange = document.createRange();
    outRange.selectNodeContents(u);
    sel.addRange(outRange);

    captureRange();
  }

  function wrapItalic(){
    if(!editBody || !lastRange) return;

    const range = lastRange.cloneRange();
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);

    const getIAncestor = (node) => {
      let n = node;
      while(n && n !== editBody){
        if(n.nodeType === 1 && (n.tagName === "I" || n.tagName === "EM")) return n;
        n = n.parentNode;
      }
      return null;
    };

    const aI = getIAncestor(range.startContainer);
    const bI = getIAncestor(range.endContainer);

    // Toggle off if selection is wholly inside same <i>/<em>
    if(aI && aI === bI){
      const iEl = aI;

      const markStart = document.createElement("span");
      const markEnd = document.createElement("span");
      markStart.setAttribute("data-bbmark","is");
      markEnd.setAttribute("data-bbmark","ie");
      for(const m of [markStart, markEnd]){
        m.style.display = "inline-block";
        m.style.width = "0";
        m.style.height = "0";
        m.style.overflow = "hidden";
      }

      const r1 = range.cloneRange(); r1.collapse(true); r1.insertNode(markStart);
      const r2 = range.cloneRange(); r2.collapse(false); r2.insertNode(markEnd);

      const parent = iEl.parentNode;
      while(iEl.firstChild){
        parent.insertBefore(iEl.firstChild, iEl);
      }
      parent.removeChild(iEl);

      const s = editBody.querySelector('span[data-bbmark="is"]');
      const e = editBody.querySelector('span[data-bbmark="ie"]');
      if(s && e){
        const newRange = document.createRange();
        newRange.setStartAfter(s);
        newRange.setEndBefore(e);
        sel.removeAllRanges();
        sel.addRange(newRange);
        s.remove(); e.remove();
        captureRange();
      } else {
        captureRange();
      }
      return;
    }

    // Toggle on: wrap selection with <i>
    const iEl = document.createElement("i");
    try{
      range.surroundContents(iEl);
    } catch(e){
      const contents = range.extractContents();
      iEl.appendChild(contents);
      range.insertNode(iEl);
    }

    sel.removeAllRanges();
    const outRange = document.createRange();
    outRange.selectNodeContents(iEl);
    sel.addRange(outRange);

    captureRange();
  }

  // Prevent the button from stealing focus/selection on press.

  btnBold?.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    e.stopPropagation();
  });
  btnBold?.addEventListener("click", (e)=>{
    e.preventDefault();
    e.stopPropagation();
    wrapBold();
  });

  btnUnderline?.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    e.stopPropagation();
  });
  btnUnderline?.addEventListener("click", (e)=>{
    e.preventDefault();
    e.stopPropagation();
    wrapUnderline();
  });

  btnItalic?.addEventListener("pointerdown", (e)=>{
    e.preventDefault();
    e.stopPropagation();
  });
  btnItalic?.addEventListener("click", (e)=>{
    e.preventDefault();
    e.stopPropagation();
    wrapItalic();
  });


  // Editor colour picker (freeform)
  const editColorBtn = document.getElementById("editColorBtn");
  const editColorDot = document.getElementById("editColorDot");
  const editColorMenu = document.getElementById("editColorMenu");
  const editColorSwatches = document.getElementById("editColorSwatches");
  const editColorInput = document.getElementById("editColorInput");

  // Custom colour: styled in-app picker (falls back to system picker if unavailable)
  const editColorCustomLabel = document.getElementById("editColorCustomLabel");
  const customPickerPanel = document.getElementById("customPickerPanel");
  const customPickerClose = document.getElementById("customPickerClose");
  const customPickerApply = document.getElementById("customPickerApply");
  const customPickerSystem = document.getElementById("customPickerSystem");
  const hueSlider = document.getElementById("hueSlider");
  const svCanvas = document.getElementById("svCanvas");
  const customPreview = document.getElementById("customPreview");
  const hexInput = document.getElementById("hexInput");

  (function initCustomPicker(){
    try{
      if(!editColorCustomLabel || !editColorInput) return;

      let H = 210, S = 0.55, V = 1.0;
      const clamp01 = (x)=> Math.max(0, Math.min(1, x));

      function hsvToRgb(h, s, v){
        const c = v * s;
        const hh = (h % 360) / 60;
        const x = c * (1 - Math.abs((hh % 2) - 1));
        let r=0,g=0,b=0;
        if(hh>=0 && hh<1){ r=c; g=x; b=0; }
        else if(hh<2){ r=x; g=c; b=0; }
        else if(hh<3){ r=0; g=c; b=x; }
        else if(hh<4){ r=0; g=x; b=c; }
        else if(hh<5){ r=x; g=0; b=c; }
        else { r=c; g=0; b=x; }
        const m = v - c;
        return { r: Math.round((r+m)*255), g: Math.round((g+m)*255), b: Math.round((b+m)*255) };
      }

      function rgbToHex(r,g,b){
        const to = (n)=> n.toString(16).padStart(2,"0");
        return "#" + to(r) + to(g) + to(b);
      }

      function hexToRgb(hex){
        const h = String(hex||"").trim().replace(/^#/,"");
        if(h.length===3){
          return { r: parseInt(h[0]+h[0],16), g: parseInt(h[1]+h[1],16), b: parseInt(h[2]+h[2],16) };
        }
        if(h.length===6){
          return { r: parseInt(h.slice(0,2),16), g: parseInt(h.slice(2,4),16), b: parseInt(h.slice(4,6),16) };
        }
        return null;
      }

      function rgbToHsv(r,g,b){
        r/=255; g/=255; b/=255;
        const max = Math.max(r,g,b), min = Math.min(r,g,b);
        const d = max - min;
        let h=0;
        if(d===0) h=0;
        else if(max===r) h = 60 * (((g-b)/d) % 6);
        else if(max===g) h = 60 * (((b-r)/d) + 2);
        else h = 60 * (((r-g)/d) + 4);
        if(h<0) h += 360;
        const s = max===0 ? 0 : d/max;
        const v = max;
        return {h,s,v};
      }

      function setFromHSV(){
        const {r,g,b} = hsvToRgb(H,S,V);
        const hex = rgbToHex(r,g,b);
        editColorInput.value = hex; // keep existing pipeline
        if(customPreview) customPreview.style.background = hex;
        if(hexInput) hexInput.value = hex;
        // Live: update editor colour bar immediately while dragging
        try{ setEditorColorUI(hex); }catch(e){}
      }

      function drawSV(){
        if(!svCanvas) return;
        const ctx = svCanvas.getContext("2d");
        const w = svCanvas.width, h = svCanvas.height;

        ctx.clearRect(0,0,w,h);
        ctx.fillStyle = `hsl(${H}, 100%, 50%)`;
        ctx.fillRect(0,0,w,h);

        const gW = ctx.createLinearGradient(0,0,w,0);
        gW.addColorStop(0, "rgba(255,255,255,1)");
        gW.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = gW;
        ctx.fillRect(0,0,w,h);

        const gB = ctx.createLinearGradient(0,0,0,h);
        gB.addColorStop(0, "rgba(0,0,0,0)");
        gB.addColorStop(1, "rgba(0,0,0,1)");
        ctx.fillStyle = gB;
        ctx.fillRect(0,0,w,h);

        const x = S * w;
        const y = (1 - V) * h;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.95)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x, y, 7.5, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(0,0,0,0.45)";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function openPicker(){
        // if panel/canvas not present, fall back to system picker
        if(!customPickerPanel || !svCanvas || !hueSlider){
          editColorInput.click();
          return;
        }
        // seed from current
        const rgb = hexToRgb(editColorInput.value);
        if(rgb){
          const hsv = rgbToHsv(rgb.r,rgb.g,rgb.b);
          H = hsv.h; S = hsv.s; V = hsv.v;
        }
        hueSlider.value = String(Math.round(H));
        customPickerPanel.style.display = "block";
        drawSV();
        setFromHSV();
      }

      function closePicker(){
        if(customPickerPanel) customPickerPanel.style.display = "none";
      }

      editColorCustomLabel.addEventListener("click", (e)=>{
        e.preventDefault();
        openPicker();
      });

      if(customPickerClose) customPickerClose.addEventListener("click", (e)=>{ e.preventDefault(); closePicker(); });

      if(customPickerSystem) customPickerSystem.addEventListener("click", (e)=>{
        e.preventDefault();
        closePicker();
        editColorInput.click();
      });

      if(hueSlider) hueSlider.addEventListener("input", ()=>{
        H = parseFloat(hueSlider.value || "0");
        drawSV();
        setFromHSV();
      });

      let dragging = false;
      function handleSV(ev){
        const rect = svCanvas.getBoundingClientRect();
        const x = clamp01((ev.clientX - rect.left) / rect.width);
        const y = clamp01((ev.clientY - rect.top) / rect.height);
        S = x;
        V = 1 - y;
        drawSV();
        setFromHSV();
      }

      if(svCanvas){
        // Use pointer events + pointer capture so dragging ALWAYS stops on release.
        // This prevents the SV selector from getting "stuck" and following the mouse.
        try{ svCanvas.style.touchAction = "none"; }catch(_){}
        let activePointerId = null;

        const endDrag = ()=>{
          if(!dragging) return;
          dragging = false;
          activePointerId = null;
          // Push the selected colour into recents (use the current editor colour, not folder colour).
          try{ maybePushRecent(editColorInput.value); }catch(_){}
        };

        svCanvas.addEventListener("pointerdown", (e)=>{
          dragging = true;
          activePointerId = e.pointerId;
          try{ svCanvas.setPointerCapture(e.pointerId); }catch(_){}
          handleSV(e);
          e.preventDefault();
          e.stopPropagation();
        });

        svCanvas.addEventListener("pointermove", (e)=>{
          if(!dragging) return;
          if(activePointerId != null && e.pointerId !== activePointerId) return;
          handleSV(e);
        });

        svCanvas.addEventListener("pointerup", (e)=>{
          if(activePointerId != null && e.pointerId !== activePointerId) return;
          try{ svCanvas.releasePointerCapture(e.pointerId); }catch(_){}
          endDrag();
        });

        svCanvas.addEventListener("pointercancel", (e)=>{
          if(activePointerId != null && e.pointerId !== activePointerId) return;
          try{ svCanvas.releasePointerCapture(e.pointerId); }catch(_){}
          endDrag();
        });

        // Safety: if the window loses focus mid-drag, stop immediately.
        window.addEventListener("blur", endDrag, { passive: true });
      }

      if(hexInput){
        hexInput.addEventListener("input", ()=>{
          const rgb = hexToRgb(hexInput.value);
          if(!rgb) return;
          editColorInput.value = rgbToHex(rgb.r,rgb.g,rgb.b);
          if(customPreview) customPreview.style.background = editColorInput.value;
        });
      }

      if(customPickerApply){
        customPickerApply.addEventListener("click", (e)=>{
          e.preventDefault();
          closePicker();
          // Use existing pipeline so the rest of the UI stays in sync
          setEditorColorUI(editColorInput.value);
        });
      }
    }catch(err){
      // Absolute safety: if anything goes wrong, keep the native picker working
      try{
        if(editColorCustomLabel && editColorInput){
          editColorCustomLabel.addEventListener("click", () => editColorInput.click());
        }
      }catch(e){}
      console.warn("Custom picker disabled:", err);
    }
  })();
  const editColorClear = document.getElementById("editColorClear");
  const editColorBar = document.getElementById("editColorBar");

  let editingCardId = null;

  // Context menu
  const ctxMenu = document.getElementById("ctxMenu");
  const ctxNew = document.getElementById("ctxNew");
  const ctxDuplicate = document.getElementById("ctxDuplicate");
  const ctxGroup = document.getElementById("ctxGroup");
  const ctxUngroup = document.getElementById("ctxUngroup");
  const ctxReset = document.getElementById("ctxReset");
  const ctxDelete = document.getElementById("ctxDelete");
  let ctxAtWorld = {x: 0, y: 0};
  let ctxTargetCardId = null;
  let ctxSelectionSnapshot = [];

  // View transform
  let view = { x: 120, y: 100, scale: 1 };

  let gridVisible = true;
  let isPresentation = false;
  let _presentPrev = null;
  let lastPointerClient = { x: window.innerWidth/2, y: window.innerHeight/2 };
  let lastGroupHoverId = null; // folder under cursor (for Folders menu)


  const RECENTS_KEY = "beatboard.recents";
  const CLIPBOARD_KEY = "beatboard.clipboard";

  let isPanning = false;

  
    document.body.classList.remove("bbShiftPanning");let panStart = { x: 0, y: 0 };
  let viewStart = { x: 0, y: 0 };

  // Cards state
  let cards = [];

  // Folder (group) appearance settings
  let groupStyles = {}; // gid -> { color:"#rrggbb", opacity:0-1, name:"", showName:true }
  let activeFolderId = null;

  function clamp01(v){ return Math.max(0, Math.min(1, v)); }
  function hexToRgb(hex){
    if(!hex) return {r:255,g:255,b:255};
    const h = hex.replace("#","").trim();
    if(h.length===3){
      const r = parseInt(h[0]+h[0],16), g=parseInt(h[1]+h[1],16), b=parseInt(h[2]+h[2],16);
      return {r,g,b};
    }
    if(h.length>=6){
      const r = parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16);
      return {r,g,b};
    }
    return {r:255,g:255,b:255};
  }
  function rgbaFromHex(hex, a){
    const {r,g,b} = hexToRgb(hex);
    return `rgba(${r},${g},${b},${clamp01(a)})`;
  }
  function getGroupStyle(gid){
    const s = (groupStyles && groupStyles[gid]) ? groupStyles[gid] : null;
    const base = { color:"#ffffff", opacity:0.20, name:"", showName:false };
    return Object.assign(base, s || {});
  }

  let selectedId = null; // primary (last) selected card
  let selected = new Set(); // multi-selection set

  // Keyboard nudge: Arrow keys move selected cards.
  // Works with single selection (selectedId) and multi-selection (selected Set).
  // Intentionally ignores contenteditable focus; only disabled for real form fields and during active gestures.
  document.addEventListener("keydown", (e) => {
    const k = e.key;
    if (k !== "ArrowLeft" && k !== "ArrowRight" && k !== "ArrowUp" && k !== "ArrowDown") return;
    if (e.metaKey || e.ctrlKey || e.altKey) return;

    const ae = document.activeElement;
    const tag = ae && ae.tagName ? ae.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || tag === "select") return;

    // Don't fight active interactions
    if (drag && drag.active) return;
    if (resizing && resizing.active) return;
    if (typeof folderDrag !== "undefined" && folderDrag && folderDrag.active) return;
    if (typeof selecting !== "undefined" && selecting) return;

    const ids = (selected && selected.size) ? Array.from(selected) : (selectedId ? [selectedId] : []);
    if (!ids.length) return;

    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();

    const step = (typeof GRID === "number" ? GRID : 20);
    let dx = 0, dy = 0;
    if (k === "ArrowLeft") dx = -step;
    if (k === "ArrowRight") dx = step;
    if (k === "ArrowUp") dy = -step;
    if (k === "ArrowDown") dy = step;

    pushHistory();
    for (const id of ids) {
      const c = getCardById(id);
      if (!c || c.locked) continue;
      c.x = Math.round((c.x || 0) + dx);
      c.y = Math.round((c.y || 0) + dy);
    }

    // Smart snap after nudging: gently align the primary card to nearby cards (and/or grid),
    // then apply the same snap delta to the whole selection to preserve relative layout.
    try{
      const grid = (typeof GRID === "number" ? GRID : 20);
      const snapTol = Math.max(6, Math.round(grid * 0.4)); // ~8px when grid=20
      const rootStyle = getComputedStyle(document.documentElement);
      const baseW = parseFloat(rootStyle.getPropertyValue("--cardW")) || 335;
      const baseH = parseFloat(rootStyle.getPropertyValue("--cardH")) || 220;

      const moved = new Set(ids);

      const refId = (selectedId && moved.has(selectedId)) ? selectedId : ids[0];
      const ref = getCardById(refId);

      function wh(c){
        return {
          w: (c && typeof c.w === "number" && isFinite(c.w)) ? c.w : baseW,
          h: (c && typeof c.h === "number" && isFinite(c.h)) ? c.h : baseH
        };
      }

      if(ref){
        const rw = wh(ref).w, rh = wh(ref).h;

        const rLeft = ref.x || 0;
        const rTop  = ref.y || 0;
        const rRight = rLeft + rw;
        const rBottom = rTop + rh;
        const rCx = rLeft + rw/2;
        const rCy = rTop + rh/2;

        let bestDx = 0, bestDxAbs = Infinity;
        let bestDy = 0, bestDyAbs = Infinity;

        // Snap to grid as a candidate (helps when cards are slightly off lattice).
        if(grid > 0){
          const gx = Math.round(rLeft / grid) * grid;
          const gy = Math.round(rTop  / grid) * grid;
          const dxg = gx - rLeft;
          const dyg = gy - rTop;
          if(Math.abs(dxg) <= snapTol && Math.abs(dxg) < bestDxAbs){ bestDx = dxg; bestDxAbs = Math.abs(dxg); }
          if(Math.abs(dyg) <= snapTol && Math.abs(dyg) < bestDyAbs){ bestDy = dyg; bestDyAbs = Math.abs(dyg); }
        }

        for(const o of cards){
          if(!o || moved.has(o.id)) continue;
          if(o.groupId && ref.groupId && o.groupId !== ref.groupId) continue; // avoid cross-folder snapping
          const ow = wh(o).w, oh = wh(o).h;

          const oLeft = o.x || 0;
          const oTop  = o.y || 0;
          const oRight = oLeft + ow;
          const oBottom = oTop + oh;
          const oCx = oLeft + ow/2;
          const oCy = oTop + oh/2;

          // X: left-left, right-right, center-center
          const candDx = [oLeft - rLeft, oRight - rRight, oCx - rCx];
          for(const d of candDx){
            const ad = Math.abs(d);
            if(ad <= snapTol && ad < bestDxAbs){
              bestDx = d; bestDxAbs = ad;
            }
          }

          // Y: top-top, bottom-bottom, center-center
          const candDy = [oTop - rTop, oBottom - rBottom, oCy - rCy];
          for(const d of candDy){
            const ad = Math.abs(d);
            if(ad <= snapTol && ad < bestDyAbs){
              bestDy = d; bestDyAbs = ad;
            }
          }
        }

        // Apply the best snap deltas (if any) to all moved cards to keep the selection rigid.
        if(bestDxAbs !== Infinity || bestDyAbs !== Infinity){
          for(const id of ids){
            const c = getCardById(id);
            if(!c || c.locked) continue;
            if(bestDxAbs !== Infinity) c.x = Math.round((c.x || 0) + bestDx);
            if(bestDyAbs !== Infinity) c.y = Math.round((c.y || 0) + bestDy);
          }
        }
      }
    }catch(err){ /* snap is best-effort */ }

    save();
    render();
  }, true);

  // Find overlay state
  let findMatches = new Set();
  let findOrder = [];
  let findIndex = -1;
  let suppressNextClick = false; // used to prevent clear-on-drag
  let drag = { active:false, ids:[], start:null, starts:null, offsetX:0, offsetY:0, pushed:false, originGroupId:null, pendingGroupDrag:null };

  // Image-card resizing state
  let resizing = {
    active: false,
    id: null,
    startClientX: 0,
    startClientY: 0,
    startW: 0,
    startH: 0,

    // During a resize gesture, we keep a baseline of nearby cards so they can
    // move out of the way *and* slide back when you shrink the card again.
    baseline: null,   // Map(cardId -> {x,y})

    scopeIds: null,   // Array of card ids in scope for push-away during this resize
    followIds: null,  // Array of selected card ids to resize along with the primary
    followStarts: null, // Map id -> {w,h}
    smoothW: null,
    smoothH: null,
    lastSnapX: null,
    lastSnapY: null,
    // If true, resizing will not run the push-away collision solver (used for image cards).
    noPush: false
  };

  // Temporary grouping (like iOS app folders, but spatial + non-hierarchical)
  let groupTargetId = null;
  let groupTargetTimer = null;
  let groupHoverCandidate = null;
  const GROUP_HOVER_MS = 700;
  const GROUP_JIGGLE_MS = 220; // time to visibly "jiggle" before auto-grouping


  // History (undo/redo) â€” lightweight snapshots
  const HISTORY_MAX = 100;
  let undoStack = [];
  let redoStack = [];

  function snapshotState(){
    // Document-only snapshot: view (pan/zoom) is intentionally excluded
    // so undo/redo never changes the user's camera position.
    return {
      cards: JSON.parse(JSON.stringify(cards)),
      groupStyles: JSON.parse(JSON.stringify(groupStyles || {})),
      selectedIds: Array.from(selected),
      selectedId: selectedId
    };
  }

  function restoreState(s){
    if(!s) return;
    // Restore document state only. Keep current view.x/view.y/view.scale unchanged.
    cards = s.cards || [];
    groupStyles = s.groupStyles || {};
    selected = new Set(s.selectedIds || []);
    selectedId = s.selectedId || null;
    render();
    save();
  }

  function pushHistory(){
    undoStack.push(snapshotState());
    if(undoStack.length > HISTORY_MAX) undoStack.shift();
    redoStack.length = 0;
  }

  function canUndo(){ return undoStack.length > 0; }
  function canRedo(){ return redoStack.length > 0; }

  function undo(){
    if(!canUndo()) return;
    redoStack.push(snapshotState());
    const prev = undoStack.pop();
    restoreState(prev);
  }

  function redo(){
    if(!canRedo()) return;
    undoStack.push(snapshotState());
    const next = redoStack.pop();
    restoreState(next);
  }

  function isTypingContext(){
    // avoid stealing keys while editing text or in inputs
    if(modalOverlay && modalOverlay.style.display === "flex") return true;
    if(findOverlay && findOverlay.style.display === "flex") return true;
    const ae = document.activeElement;
    if(!ae) return false;
    const tag = (ae.tagName || "").toLowerCase();
if(tag === "input"){
  const type = (ae.getAttribute("type") || "").toLowerCase();
  // Treat the ink size slider as non-typing so Ctrl/Cmd+Z keeps working after adjusting it
  if(type === "range" && ae.closest && ae.closest("#inkPanel")) return false;
  return true;
}

  // -------------------------------------------------
  // Space-to-pan (hand tool)
  // - Hold Space: pan with left mouse drag
  // - Release Space: immediately stop panning
  // - Does not hijack typing in inputs/contenteditable
  // -------------------------------------------------
  if(tag === "textarea" || tag === "select") return true;
    if(ae.isContentEditable) return true;
    return false;
  }


// More granular check used by ink shortcuts: treat sliders in the ink UI as non-typing targets
function isTypingTarget(el){
  if(!el) return false;
  const tag = (el.tagName || "").toLowerCase();
  if(tag === "input"){
    const type = (el.getAttribute("type") || "").toLowerCase();
    // Allow Ctrl/Cmd+Z even if the ink size slider is focused
    if(type === "range" && el.closest && el.closest("#inkPanel")) return false;
    return true;
  }
  if(tag === "textarea" || tag === "select") return true;
  if(el.isContentEditable) return true;
  return false;
}


  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const uid = () => Math.random().toString(16).slice(2) + Date.now().toString(16);

  // Snap settings
  const GRID = 20;
  const SNAP_DIST = 10;

  const PALETTE = [
    "#9bbf7e","#7ea7c7","#c98983","#c9c9c9",
    "#d9c48c","#b8a1d9","#8ec7be","#d98fb7",
    "#8f99a7","#5f6b7a","#3f4955","#20262e",
    "#f2d7d5","#f1e7c7","#dbe7f2","#d7f2ec",
    "#a9d18e","#ffd966","#9dc3e6","#f4b183",
    "#c6e0b4","#ffe699","#bdd7ee","#f8cbad"
  ];

  function applyView(){
    board.style.transform = `translate(${view.x}px, ${view.y}px) scale(${view.scale})`;
    if (typeof updateBgWithView === "function") updateBgWithView();
    scheduleRedrawInk();
  }

  
  

  /* --- Background follows view (merged) --- */
  function updateBgWithView(){
    const bg = document.getElementById("bgPattern");
    if(!bg) return;
    const raw = getComputedStyle(document.documentElement).getPropertyValue("--bgp-size").trim();
    const base = parseFloat(raw) || 80;
    const scaled = Math.max(2, base * (view.scale || 1));
    bg.style.backgroundSize = `${scaled}px ${scaled}px`;
    bg.style.backgroundPosition = `${view.x}px ${view.y}px`;
  }


  /* ---------- Background pattern (UI + state) ---------- */
  (function(){
    const bgEl = document.getElementById("bgPattern");
    const variantEl = document.getElementById("bgVariant");
    const maskEl = document.getElementById("bgMask");
    const fillEl = document.getElementById("bgFill");
    const opacityEl = document.getElementById("bgOpacity");
    const sizeEl = document.getElementById("bgSize");
    const sizeLabel = document.getElementById("bgSizeLabel");
    const opacityLabel = document.getElementById("bgOpacityLabel");
    const colorWrap = document.getElementById("bgColorWrap");

    if(!bgEl || !variantEl || !maskEl || !fillEl || !opacityEl || !sizeEl) return;

    // Background colour control is now the native <input type="color"> in the menu.
    // Prevent it from closing the menu on click.
    (function bindBgFillInput(){
      if(!fillEl) return;
      fillEl.addEventListener("pointerdown", (e)=>{ e.stopPropagation(); }, true);
      fillEl.addEventListener("click", (e)=>{ e.stopPropagation(); }, true);

    // Background colour (native input overlay so it always opens)
    (function bindBgColorToggle(){
      const sw = document.getElementById("bgColorSwatch");
      if(sw && fillEl) sw.style.background = fillEl.value || "#ffffff";
      if(fillEl){
        fillEl.addEventListener("input", ()=>{ if(sw) sw.style.background = fillEl.value || "#ffffff"; });
      }
    })();

    })();

// State
    const KEY = "beatboard.bgPattern";
    const defaults = { enabled:true, variant:"grid", mask:"fade-edges", opacity: 0.5, size:80, fill:"#ffffff" };

    const read = ()=>{
      try{
        const raw = localStorage.getItem(KEY);
        if(!raw) return { ...defaults };
        const j = JSON.parse(raw);
        return { ...defaults, ...(j||{}) };
      }catch(e){ return { ...defaults }; }
    };
    const write = (s)=>{
      try{ localStorage.setItem(KEY, JSON.stringify(s)); }catch(e){}
    };

    const apply = (s)=>{
      bgEl.style.display = (s.enabled === false) ? "none" : "block";
      bgEl.style.opacity = String((s.opacity ?? 1));

      // classes
      bgEl.classList.remove(
        "variant-dots","variant-grid","variant-diagonal-stripes","variant-horizontal-lines","variant-vertical-lines","variant-checkerboard",
        "mask-none","mask-fade-edges","mask-fade-center","mask-fade-top","mask-fade-bottom","mask-fade-left","mask-fade-right","mask-fade-x","mask-fade-y"
      );
      bgEl.classList.add("variant-" + (s.variant || "grid"), "mask-" + (s.mask || "fade-edges"));

      // vars
      document.documentElement.style.setProperty("--bgp-size", `${Math.max(4, +s.size||80)}px`);
      document.documentElement.style.setProperty("--bgp-fill", (s.fill || "#ffffff"));

      // UI
      variantEl.value = (s.variant || "grid");
      maskEl.value = (s.mask || "fade-edges");
      fillEl.value = (s.fill || "#ffffff");
    const bgSw = document.getElementById("bgColorSwatch");
    if(bgSw) bgSw.style.background = (s.fill || "#ffffff");


      const op = (s.opacity ?? 1);
      opacityEl.value = String(op);
      if(opacityLabel) opacityLabel.textContent = `${Math.round(op*100)}%`;

      const sz = Math.max(8, Math.min(80, parseInt(s.size ?? 80, 10) || 80));
      sizeEl.value = String(sz);
      if(sizeLabel) sizeLabel.textContent = `${sz}px`;

      // Update colour dot
      const dot = document.getElementById("bgColorDot");
      if(dot){
        dot.style.background = (s.fill || "#ffffff");
        dot.style.borderColor = "rgba(255,255,255,0.22)";
      }

      try{ updateBgWithView(); }catch(e){}
    };

    // IMPORTANT: the user wants specific defaults on open.
    // So we apply defaults first, then (optionally) layer any stored values.
    let state = { ...defaults, ...(read() || {}) };
    // Force defaults (per request): Grid + Fade edges + 50% opacity + white + 80px
    state = { ...state, ...defaults };
    write(state);
    apply(state);

    const commit = (patch)=>{
      state = { ...state, ...(patch||{}) };
      write(state);
      apply(state);
    };

    variantEl.addEventListener("change", ()=> commit({ variant: variantEl.value }));
    maskEl.addEventListener("change", ()=> commit({ mask: maskEl.value }));
    fillEl.addEventListener("input", ()=>{
      try{ const d=document.getElementById("bgColorDot"); if(d) d.style.background = (fillEl.value || "#ffffff"); }catch(_){ }
      commit({ fill: (fillEl.value || "#ffffff") });
    });

    opacityEl.addEventListener("input", ()=>{
      const op = Math.max(0, Math.min(1, parseFloat(opacityEl.value||"1")));
      if(opacityLabel) opacityLabel.textContent = `${Math.round(op*100)}%`;
      commit({ opacity: op });
    });

    sizeEl.addEventListener("input", ()=>{
      const n = Math.max(8, Math.min(80, parseInt(sizeEl.value||"80",10)));
      if(sizeLabel) sizeLabel.textContent = `${n}px`;
      commit({ size: n });
    });
  })();
  /* ---------- /Background pattern ---------- */


  /* ---------- Ink (Pen tool) ---------- */
  const inkCanvas = document.getElementById("inkCanvas");
  const inkCtx = inkCanvas.getContext("2d", { alpha: true });

  // Tool state
  let penMode = false;
  let inkTool = "pen";        // "pen" | "eraser"
  let inkColor = "#ffffff";
  let inkWidth = 4;           // screen px (constant on-screen)
  let inkStrokes = [];        // [{color,width,alpha,points:[{x,y},...]}]
  let inkActions = [];        // undo stack: [{t:"add", stroke} | {t:"del", stroke, index} | {t:"clear", before:[] }]

  let _inkActive = null;
  let _inkDrawing = false;
  let _inkLast = null;
  let _inkRAF = 0;
  let _inkErasing = false;

  // Eraser outline cursor (visual only)
  let _inkCursor = { x: 0, y: 0, has: false, overUI: false };

  const eraserCursorEl = document.getElementById("eraserCursor");
  function updateEraserCursorDom(){
    if(!eraserCursorEl) return;
    const show = (penMode && inkTool === "eraser" && _inkCursor && _inkCursor.has && !_inkCursor.overUI);
    if(!show){
      if(eraserCursorEl.style.display !== "none") eraserCursorEl.style.display = "none";
      return;
    }
    const r = Math.max(2, (inkWidth || 4) * 0.5);
    const d = Math.max(4, r * 2);
    eraserCursorEl.style.width = d + "px";
    eraserCursorEl.style.height = d + "px";
    eraserCursorEl.style.display = "block";
    // center at cursor
    eraserCursorEl.style.transform = `translate(${Math.round(_inkCursor.x - r)}px, ${Math.round(_inkCursor.y - r)}px)`;
  }

  function resizeInkCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = viewport.clientWidth;
    const h = viewport.clientHeight;
    inkCanvas.width = Math.round(w * dpr);
    inkCanvas.height = Math.round(h * dpr);
    inkCanvas.style.width = w + "px";
    inkCanvas.style.height = h + "px";
    inkCtx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS px
    redrawInk();
  }

  function worldToScreen(pt){
    return { x: view.x + pt.x * view.scale, y: view.y + pt.y * view.scale };
  }

  function scheduleRedrawInk(){
    if(_inkRAF) return;
    _inkRAF = requestAnimationFrame(()=>{ _inkRAF = 0; redrawInk(); });
  }

  function redrawInk(){
    inkCtx.clearRect(0, 0, inkCanvas.width, inkCanvas.height);
    inkCtx.lineCap = "round";
    inkCtx.lineJoin = "round";

    const _toDraw = (Array.isArray(inkStrokes) ? inkStrokes.slice() : []);
    // Include in-progress stroke so redraws during drawing never "blink"
    if(_inkDrawing && _inkActive && _inkActive.points && _inkActive.points.length > 1){
      _toDraw.push(_inkActive);
    }

    for(const s of _toDraw){
      if(!s.points || s.points.length < 2) continue;
      inkCtx.beginPath();
      const p0 = worldToScreen(s.points[0]);
      inkCtx.moveTo(p0.x, p0.y);
      for(let i=1;i<s.points.length;i++){
        const p = worldToScreen(s.points[i]);
        inkCtx.lineTo(p.x, p.y);
      }
      inkCtx.globalAlpha = (s.alpha ?? 1);
      if(s.erase){
        inkCtx.globalCompositeOperation = "destination-out";
        inkCtx.strokeStyle = "rgba(0,0,0,1)";
      }else{
        inkCtx.globalCompositeOperation = "source-over";
        inkCtx.strokeStyle = s.color;
      }
      inkCtx.lineWidth = s.width; // screen-constant thickness
      inkCtx.stroke();
      inkCtx.globalCompositeOperation = "source-over";
    }
    // Eraser outline (visual guide) â€” not stored in history
    if(false && penMode && inkTool === "eraser" && _inkCursor && _inkCursor.has && !_inkCursor.overUI){
      inkCtx.save();
      inkCtx.globalAlpha = 1;
      inkCtx.globalCompositeOperation = "source-over";
      inkCtx.lineWidth = 1;
      inkCtx.strokeStyle = "rgba(255,255,255,0.85)";
      const r = Math.max(2, (inkWidth || 4) * 0.5);
      inkCtx.beginPath();
      inkCtx.arc(_inkCursor.x, _inkCursor.y, r, 0, Math.PI*2);
      inkCtx.stroke();
      inkCtx.restore();
    }
    inkCtx.globalAlpha = 1;
  }

  function setPenMode(on){
    penMode = !!on;
    document.body.classList.toggle("bbPenMode", penMode);
    // reflect button state
    inkPenBtn?.setAttribute("aria-pressed", (penMode && inkTool==="pen") ? "true" : "false");
    inkEraserBtn?.setAttribute("aria-pressed", (penMode && inkTool==="eraser") ? "true" : "false");
    if(penMode) viewport.focus?.();
    if(!penMode){
      _inkDrawing = false;
      _inkActive = null;
      _inkLast = null;
      _inkErasing = false;
      _inkCursor = { x: 0, y: 0, has: false, overUI: false };
      scheduleRedrawInk();
    }
  }

  function setInkTool(tool){
    const next = tool;
    if(penMode && inkTool === next){
      // toggle off if clicking the active tool
      setPenMode(false);
      return;
    }
    inkTool = next;
    setPenMode(true);
    scheduleRedrawInk();
    updateEraserCursorDom();
  }

  function pushInkAction(action){
    inkActions.push(action);
  }

  function undoInk(){
    // Cancel any in-progress gesture
    _inkDrawing = false;
    _inkActive = null;
    _inkLast = null;
    _inkErasing = false;

    const a = inkActions.pop();
    if(!a) return;

    if(a.t === "add"){
      // remove the most recently added stroke (by reference)
      const idx = inkStrokes.lastIndexOf(a.stroke);
      if(idx !== -1) inkStrokes.splice(idx, 1);
    }else if(a.t === "del"){
      const idx = clamp(a.index, 0, inkStrokes.length);
      inkStrokes.splice(idx, 0, a.stroke);
    }else if(a.t === "clear"){
      inkStrokes = a.before || [];
    }
    redrawInk();
  }

  // --- Eraser hit test (world space) ---
  function distPointToSegSq(px, py, ax, ay, bx, by){
    const abx = bx - ax, aby = by - ay;
    const apx = px - ax, apy = py - ay;
    const abLenSq = abx*abx + aby*aby;
    let t = 0;
    if(abLenSq > 0) t = (apx*abx + apy*aby) / abLenSq;
    t = Math.max(0, Math.min(1, t));
    const cx = ax + t*abx, cy = ay + t*aby;
    const dx = px - cx, dy = py - cy;
    return dx*dx + dy*dy;
  }

  function strokeHitTestWorld(stroke, p, radiusWorld){
    const r2 = radiusWorld * radiusWorld;
    const pts = stroke.points || [];
    for(let i=1;i<pts.length;i++){
      const a = pts[i-1], b = pts[i];
      if(distPointToSegSq(p.x, p.y, a.x, a.y, b.x, b.y) <= r2) return true;
    }
    return false;
  }

  function eraseAtWorld(p){
    // radius in world units based on current brush size in screen px
    const radiusWorld = (Math.max(6, inkWidth * 2.2)) / view.scale;
    // topmost stroke last
    for(let i=inkStrokes.length-1;i>=0;i--){
      const s = inkStrokes[i];
      if(strokeHitTestWorld(s, p, radiusWorld)){
        inkStrokes.splice(i, 1);
        pushInkAction({ t:"del", stroke: s, index: i });
        scheduleRedrawInk();
        return true;
      }
    }
    return false;
  }

  // UI wiring
  const inkPenBtn = document.getElementById("inkPen");
  const inkEraserBtn = document.getElementById("inkEraser");
  const inkColorGrid = document.getElementById("inkColorGrid");
  const inkColorInput = document.getElementById("inkColorInput");
  const inkColorCustomLabel = document.getElementById("inkColorCustomLabel");
  const inkCustomPickerPanel = document.getElementById("inkCustomPickerPanel");
  const inkCustomPickerClose = document.getElementById("inkCustomPickerClose");
  const inkColorInput2 = document.getElementById("inkColorInput2");
  const inkColorHex = document.getElementById("inkColorHex");
  const inkCustomDefault = document.getElementById("inkCustomDefault");
  const inkSizeEl = document.getElementById("inkSize");
  const inkSizeLabel = document.getElementById("inkSizeLabel");
  const inkUndoEl = document.getElementById("inkUndo");
  const inkClearEl = document.getElementById("inkClear");
  const inkColorToggle = document.getElementById("inkColorToggle");
  const inkColorDropdown = document.getElementById("inkColorDropdown");
  const inkColorSwatch = document.getElementById("inkColorSwatch");

  // Prevent ink mode from interfering with UI interactions (range dragging, dropdown clicks)
  const inkPanelEl = document.getElementById("inkPanel");
  /* --- Ink panel collapse --- */
  (function installInkPanelCollapse(){
    try{
      const key = "beatboard.inkCollapsed";
      const btn = document.getElementById("inkCollapseBtn");
      const panel = document.getElementById("inkPanel");
      if(!btn || !panel) return;

      const apply = (collapsed, persist=true)=>{
        panel.classList.toggle("inkCollapsed", !!collapsed);
        btn.setAttribute("aria-expanded", String(!collapsed));
        if(persist){
          try{ localStorage.setItem(key, collapsed ? "1" : "0"); }catch(_){}
        }
      };

      // Restore last state (default = expanded)
      try{
        const saved = localStorage.getItem(key);
        if(saved === "1") apply(true, false);
      }catch(_){}

      // Toggle
      btn.addEventListener("pointerdown", (e)=>{
        // Use pointerdown capture-style so this always wins over board handlers.
        try{ e.preventDefault(); e.stopPropagation(); }catch(_){}
        apply(!panel.classList.contains("inkCollapsed"));
      }, true);

      // Keyboard accessibility
      btn.addEventListener("keydown", (e)=>{
        if(e.key === "Enter" || e.key === " "){
          try{ e.preventDefault(); e.stopPropagation(); }catch(_){}
          apply(!panel.classList.contains("inkCollapsed"));
        }
      });
    }catch(_){}
  })();
  /* --- /Ink panel collapse --- */

  if(inkPanelEl){
    // Ensure UI elements (like the size slider) always receive pointer interaction,
    // even while the ink canvas is capturing input.
    inkPanelEl.addEventListener("pointerenter", ()=> document.body.classList.add("inkUiHover"));
    inkPanelEl.addEventListener("pointerleave", ()=> document.body.classList.remove("inkUiHover"));
// Extra safety: range inputs/buttons should never start a stroke.
    inkPanelEl.querySelectorAll("input, button, select, textarea, label").forEach(el=>{
      el.addEventListener("pointerdown", (e)=>{ e.stopPropagation(); }, true);
      el.addEventListener("mousedown", (e)=>{ e.stopPropagation(); }, true);
    });
  }

  function setInkColor(hex, { closeDropdown = false } = {}){
    if(!hex) return;
    inkColor = hex;
    if(inkColorSwatch) inkColorSwatch.style.background = inkColor;

    // update active state ring
    if(inkColorGrid){
      for(const btn of inkColorGrid.querySelectorAll(".tabsSwatchBtn")){
        const p = btn.getAttribute("data-preset");
        const h = btn.getAttribute("data-hex");
        const val = p ? getComputedStyle(document.documentElement).getPropertyValue(`--${p}`)?.trim() : h;
        btn.classList.toggle("active", (val || "").toLowerCase() === inkColor.toLowerCase());
      }
    }

    if(closeDropdown && inkColorDropdown){
      inkColorDropdown.hidden = true;
      if(inkColorToggle) inkColorToggle.setAttribute("aria-expanded","false");
    }
  }

  if(inkPenBtn) inkPenBtn.addEventListener("click", ()=> setInkTool("pen"));
  if(inkEraserBtn) inkEraserBtn.addEventListener("click", ()=> setInkTool("eraser"));

  if(inkColorGrid){
    inkColorGrid.addEventListener("click", (e)=>{
      const btn = e.target.closest(".tabsSwatchBtn");
      if(!btn) return;
      const preset = btn.getAttribute("data-preset");
      const hex = btn.getAttribute("data-hex");
      let val = hex;
      if(preset){
        val = getComputedStyle(document.documentElement).getPropertyValue(`--${preset}`).trim();
      }
      if(val) setInkColor(val);
    });
  }

  

  // Ink colour dropdown
  if(inkColorToggle && inkColorDropdown){
    inkColorToggle.addEventListener("click", (e)=>{
      e.stopPropagation();
      const willOpen = inkColorDropdown.hidden;
      inkColorDropdown.hidden = !willOpen;
      inkColorToggle.setAttribute("aria-expanded", willOpen ? "true" : "false");
    });

    // Close on outside click (capture so it wins over other handlers)
    document.addEventListener("pointerdown", (e)=>{
      if(inkColorDropdown.hidden) return;
      if(e.target.closest("#inkColorToggle") || e.target.closest("#inkColorDropdown")) return;
      inkColorDropdown.hidden = true;
      inkColorToggle.setAttribute("aria-expanded","false");
    }, true);
  }

  // Close button inside colour popup
  const inkColorCloseBtn = document.getElementById("inkColorCloseBtn");
  if(inkColorCloseBtn && inkColorDropdown && inkColorToggle){
    inkColorCloseBtn.addEventListener("click", (e)=>{
      e.preventDefault();
      inkColorDropdown.hidden = true;
      inkColorToggle.setAttribute("aria-expanded","false");
    });
  }

  /* Ink custom colour picker (Tabs-style UI) */
  (function initInkCustomPicker(){
    try{
      const inkSvCanvas = document.getElementById("inkSvCanvas");
      const inkHueSlider = document.getElementById("inkHueSlider");
      const inkCustomPreview = document.getElementById("inkCustomPreview");
      const inkHexInput = document.getElementById("inkHexInput");
      if(!inkColorInput || !inkSvCanvas || !inkHueSlider || !inkCustomPreview || !inkHexInput) return;

      let H = 210, S = 0.55, V = 1.0;
      const clamp01 = (x)=> Math.max(0, Math.min(1, x));

      function hsvToRgb(h, s, v){
        const c = v * s;
        const hh = (h % 360) / 60;
        const x = c * (1 - Math.abs((hh % 2) - 1));
        let r=0,g=0,b=0;
        if(hh>=0 && hh<1){ r=c; g=x; b=0; }
        else if(hh<2){ r=x; g=c; b=0; }
        else if(hh<3){ r=0; g=c; b=x; }
        else if(hh<4){ r=0; g=x; b=c; }
        else if(hh<5){ r=x; g=0; b=c; }
        else { r=c; g=0; b=x; }
        const m = v - c;
        return { r: Math.round((r+m)*255), g: Math.round((g+m)*255), b: Math.round((b+m)*255) };
      }
      function rgbToHex(r,g,b){
        const to = (n)=> n.toString(16).padStart(2,"0");
        return "#" + to(r) + to(g) + to(b);
      }
      function hexToRgb(hex){
        const h = String(hex||"").trim().replace(/^#/,"");
        if(h.length===3){
          return { r: parseInt(h[0]+h[0],16), g: parseInt(h[1]+h[1],16), b: parseInt(h[2]+h[2],16) };
        }
        if(h.length===6){
          return { r: parseInt(h.slice(0,2),16), g: parseInt(h.slice(2,4),16), b: parseInt(h.slice(4,6),16) };
        }
        return null;
      }
      function rgbToHsv(r,g,b){
        r/=255; g/=255; b/=255;
        const max = Math.max(r,g,b), min = Math.min(r,g,b);
        const d = max - min;
        let h=0;
        if(d===0) h=0;
        else if(max===r) h = 60 * (((g-b)/d) % 6);
        else if(max===g) h = 60 * (((b-r)/d) + 2);
        else h = 60 * (((r-g)/d) + 4);
        if(h<0) h += 360;
        const s = max===0 ? 0 : d/max;
        const v = max;
        return {h,s,v};
      }

      function commit(hex){
        inkColorInput.value = hex;
        inkCustomPreview.style.background = hex;
        inkHexInput.value = hex;
        setInkColor(hex, { closeDropdown:false });
      }

      function drawSV(){
        const ctx = inkSvCanvas.getContext("2d");
        const w = inkSvCanvas.width, h = inkSvCanvas.height;
        ctx.clearRect(0,0,w,h);
        ctx.fillStyle = `hsl(${H}, 100%, 50%)`;
        ctx.fillRect(0,0,w,h);

        const gW = ctx.createLinearGradient(0,0,w,0);
        gW.addColorStop(0, "rgba(255,255,255,1)");
        gW.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = gW;
        ctx.fillRect(0,0,w,h);

        const gB = ctx.createLinearGradient(0,0,0,h);
        gB.addColorStop(0, "rgba(0,0,0,0)");
        gB.addColorStop(1, "rgba(0,0,0,1)");
        ctx.fillStyle = gB;
        ctx.fillRect(0,0,w,h);

        const x = S * w;
        const y = (1 - V) * h;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.95)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(x, y, 7.5, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(0,0,0,0.45)";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function setFromHSV(){
        const {r,g,b} = hsvToRgb(H,S,V);
        commit(rgbToHex(r,g,b));
        drawSV();
      }

      function seedFromCurrent(){
        const rgb = hexToRgb(inkColorInput.value || inkColor || "#ffffff");
        if(rgb){
          const hsv = rgbToHsv(rgb.r,rgb.g,rgb.b);
          H = hsv.h; S = hsv.s; V = hsv.v;
        }
        inkHueSlider.value = String(Math.round(H));
        inkCustomPreview.style.background = inkColorInput.value || inkColor || "#ffffff";
        inkHexInput.value = (inkColorInput.value || inkColor || "#ffffff").toLowerCase();
        drawSV();
      }

      // Seed whenever popup opens
      if(inkColorToggle && inkColorDropdown){
        inkColorToggle.addEventListener("click", ()=>{ setTimeout(()=>{ if(inkColorDropdown && !inkColorDropdown.hidden) seedFromCurrent(); }, 0); });
      }else{
        seedFromCurrent();
      }

      inkHueSlider.addEventListener("input", ()=>{
        H = parseFloat(inkHueSlider.value || "0");
        setFromHSV();
      });

      // Robust pointer-based interaction (avoids mouse/touch edge cases + ensures it works under overlays)
      let dragging = false;
      let activePointerId = null;
      function handleSV(clientX, clientY){
        const rect = inkSvCanvas.getBoundingClientRect();
        const x = clamp01((clientX - rect.left) / rect.width);
        const y = clamp01((clientY - rect.top) / rect.height);
        S = x;
        V = 1 - y;
        setFromHSV();
      }

      inkSvCanvas.addEventListener("pointerdown", (e)=>{
        // Only respond to primary pointer / button
        if(e.button !== undefined && e.button !== 0) return;
        dragging = true;
        activePointerId = e.pointerId;
        try{ inkSvCanvas.setPointerCapture(activePointerId); }catch(_){ }
        handleSV(e.clientX, e.clientY);
        e.preventDefault();
        e.stopPropagation();
      });
      inkSvCanvas.addEventListener("pointermove", (e)=>{
        if(!dragging) return;
        if(activePointerId != null && e.pointerId !== activePointerId) return;
        handleSV(e.clientX, e.clientY);
        e.preventDefault();
      });
      inkSvCanvas.addEventListener("pointerup", (e)=>{
        if(activePointerId != null && e.pointerId !== activePointerId) return;
        try{ if(activePointerId!=null) inkSvCanvas.releasePointerCapture(activePointerId); }catch(_){ }
        dragging = false;
        activePointerId = null;
        e.preventDefault();
        e.stopPropagation();
      });
      inkSvCanvas.addEventListener("pointercancel", (e)=>{
  try{ if(activePointerId!=null) inkSvCanvas.releasePointerCapture(activePointerId); }catch(_){ }
  dragging = false;
  activePointerId = null;
});

// Global safety: if the pointer is released outside the canvas (or the dropdown closes),
// ensure we always stop tracking so the selector never feels "glued" to the mouse.
function endSvDrag(e){
  if(!dragging) return;
  if(activePointerId != null && e && e.pointerId != null && e.pointerId !== activePointerId) return;
  try{ if(activePointerId!=null) inkSvCanvas.releasePointerCapture(activePointerId); }catch(_){ }
  dragging = false;
  activePointerId = null;
}
window.addEventListener("pointerup", endSvDrag, true);
window.addEventListener("pointercancel", endSvDrag, true);
window.addEventListener("blur", ()=> endSvDrag(), true);

      inkHexInput.addEventListener("input", ()=>{
        const rgb = hexToRgb(inkHexInput.value);
        if(!rgb) return;
        commit(rgbToHex(rgb.r,rgb.g,rgb.b));
      });

      // Native fallback path (hidden)
      inkColorInput.addEventListener("input", (e)=> commit(e.target.value || "#ffffff"));

      // Initial seed
      seedFromCurrent();
    }catch(err){
      console.warn("Ink custom picker disabled:", err);
    }
  })();

  if(inkSizeEl){
    const syncSize = ()=>{
      inkWidth = Math.max(1, parseFloat(inkSizeEl.value)||4);
      if(inkSizeLabel) inkSizeLabel.textContent = `${Math.round(inkWidth)}px`;
    };
    inkSizeEl.addEventListener("input", syncSize);
    syncSize();
  }

  if(inkUndoEl){
    // Use pointerdown (capture) so the button always wins against marquee/board handlers.
    // DO NOT also bind click, otherwise a single user click can trigger two undos (pointerdown + click).
    const doUndo = (e)=>{ try{ e.preventDefault(); e.stopPropagation(); }catch(_){ } undoInk(); };
    inkUndoEl.addEventListener("pointerdown", doUndo, true);

    // Keyboard accessibility: Enter/Space triggers undo when the button is focused.
    inkUndoEl.addEventListener("keydown", (e)=>{
      if(e.key === "Enter" || e.key === " "){
        try{ e.preventDefault(); e.stopPropagation(); }catch(_){ }
        undoInk();
      }
    });
  }

  if(inkClearEl){
    inkClearEl.addEventListener("click", ()=>{
      if(!inkStrokes.length) return;
      // store deep copy references (strokes are plain objects)
      const before = inkStrokes.slice();
      pushInkAction({ t:"clear", before });
      inkStrokes = [];
      redrawInk();
    });
  }

  // Default active color highlight
  setInkColor(inkColor);

  
  // -------------------------------------------------
  // Shape Assist (hold-to-neaten)
  // - While drawing with the Pen, if the pointer stops moving briefly *while still held down*,
  //   we try to neaten the stroke into a clean primitive.
  // - Currently supports: Circle (closed-ish strokes) and Straight line (very linear strokes).
  // -------------------------------------------------
  const SHAPE_HOLD_MS = 260;     // how long the user must "hold" without moving
  const SHAPE_MIN_LEN = 18;      // minimum points before attempting
  const SHAPE_UNLOCK_DIST = 6;   // if user moves again beyond this, return to raw stroke
  let _inkHoldTimer = null;
  let _inkLastMoveAt = 0;

  function _dist(a,b){
    const dx = a.x-b.x, dy = a.y-b.y;
    return Math.hypot(dx,dy);
  }

  function _bbox(pts){
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    for(const p of pts){
      if(p.x<minX) minX=p.x;
      if(p.y<minY) minY=p.y;
      if(p.x>maxX) maxX=p.x;
      if(p.y>maxY) maxY=p.y;
    }
    return {minX,minY,maxX,maxY,w:maxX-minX,h:maxY-minY, cx:(minX+maxX)/2, cy:(minY+maxY)/2};
  }

  function _totalLength(pts){
    let L=0;
    for(let i=1;i<pts.length;i++) L += _dist(pts[i-1], pts[i]);
    return L;
  }

  function _r2LineFit(pts){
    // Simple linearity score using PCA-ish covariance (no heavy math libs).
    // Returns (lambda1 / (lambda1+lambda2)) where close to 1 => points lie on a line.
    const n = pts.length;
    let mx=0,my=0;
    for(const p of pts){ mx += p.x; my += p.y; }
    mx/=n; my/=n;
    let sxx=0, syy=0, sxy=0;
    for(const p of pts){
      const x=p.x-mx, y=p.y-my;
      sxx += x*x; syy += y*y; sxy += x*y;
    }
    // eigenvalues of 2x2 covariance (scale doesn't matter)
    const tr = sxx + syy;
    const det = sxx*syy - sxy*sxy;
    const disc = Math.max(0, tr*tr - 4*det);
    const l1 = (tr + Math.sqrt(disc)) / 2;
    const l2 = (tr - Math.sqrt(disc)) / 2;
    if(tr <= 0) return 0;
    return l1 / (l1 + l2 + 1e-9);
  }

  function _makeCirclePoints(cx, cy, r, n=64){
    const pts = [];
    for(let i=0;i<=n;i++){
      const t = (i/n) * Math.PI*2;
      pts.push({x: cx + Math.cos(t)*r, y: cy + Math.sin(t)*r});
    }
    return pts;
  }

  function _makeLinePoints(a,b,n=2){
    // Keep as 2 points; renderer uses segments.
    return [a,b];
  }

      function tryShapeAssist(){
    if(!penMode) return;
    if(!_inkDrawing || !_inkActive) return;
    if(_inkActive.erase) return;
    if(inkTool !== "pen") return;

    const pts = _inkActive.points || [];
    if(pts.length < SHAPE_MIN_LEN) return;
    if(_inkActive._shapeCorrected) return;

    const first = pts[0], last = pts[pts.length-1];
    const bb = _bbox(pts);
    const approxR = Math.max(bb.w, bb.h)/2;
    if(approxR < 10) return;

    const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
    const endDist = dist(first,last);
    const nearClosed = endDist < Math.max(approxR * 0.85, 26);

    // --- 1) Straight line ---
    const linearity = _r2LineFit(pts);
    if(linearity > 0.985){
      _inkActive._rawPoints = _inkActive._rawPoints || pts.slice();
      _inkActive.points = [first,last];
      _inkActive._shapeCorrected = "line";
      scheduleRedrawInk();
      return;
    }

    // --- 2) Dominant corner detection (simplified stroke) ---
    const sample = [];
    const step = Math.max(1, Math.floor(pts.length / 70));
    for(let i=0;i<pts.length;i+=step) sample.push(pts[i]);
    if(sample[sample.length-1] !== last) sample.push(last);

    const rawCorners = [];
    for(let i=1;i<sample.length-1;i++){
      const a=sample[i-1], b=sample[i], c=sample[i+1];
      const abx=b.x-a.x, aby=b.y-a.y;
      const bcx=c.x-b.x, bcy=c.y-b.y;
      const abL=Math.hypot(abx,aby)+1e-9;
      const bcL=Math.hypot(bcx,bcy)+1e-9;
      const dot=(abx*bcx+aby*bcy)/(abL*bcL);
      const ang=Math.acos(Math.max(-1,Math.min(1,dot)));
      if(ang > (Math.PI/3)) rawCorners.push(b); // >60Â° turn = real "corner"
    }

    // Cluster corners so tiny jitter doesn't inflate counts
    const dom = [];
    const minSep = Math.max(approxR*0.18, 16);
    for(const p of rawCorners){
      if(!dom.length || dist(p, dom[dom.length-1]) > minSep) dom.push(p);
    }
    // If ends are close, the first/last corners can duplicate; merge if needed
    if(dom.length > 2 && dist(dom[0], dom[dom.length-1]) < minSep) dom.pop();

    const domCornerCount = dom.length;

    // --- 3) If there are clear corners, prefer polygonal shapes and block circle/oval ---
    if(nearClosed && domCornerCount >= 3){
      // Triangle
      if(domCornerCount === 3){
        const tri = [dom[0], dom[1], dom[2], dom[0]];
        _inkActive._rawPoints = _inkActive._rawPoints || pts.slice();
        _inkActive.points = tri;
        _inkActive._shapeCorrected = "triangle";
        scheduleRedrawInk();
        return;
      }

      // Rectangle / Square (use bbox aligned for now, stable)
      if(domCornerCount >= 4){
        const isSquare = Math.abs(bb.w - bb.h) < Math.max(bb.w, bb.h) * 0.18;
        const rectPts = [
          {x: bb.minX, y: bb.minY},
          {x: bb.maxX, y: bb.minY},
          {x: bb.maxX, y: bb.maxY},
          {x: bb.minX, y: bb.maxY},
          {x: bb.minX, y: bb.minY},
        ];
        _inkActive._rawPoints = _inkActive._rawPoints || pts.slice();
        _inkActive.points = rectPts;
        _inkActive._shapeCorrected = isSquare ? "square" : "rectangle";
        scheduleRedrawInk();
        return;
      }
    }

    // --- 4) Circle / Oval (stricter, only when not cornered) ---
    // Turning
    let turn=0;
    for(let i=2;i<pts.length;i++){
      const a=pts[i-2], b=pts[i-1], c=pts[i];
      const abx=b.x-a.x, aby=b.y-a.y;
      const bcx=c.x-b.x, bcy=c.y-b.y;
      const abL=Math.hypot(abx,aby)+1e-9;
      const bcL=Math.hypot(bcx,bcy)+1e-9;
      const dot=(abx*bcx+aby*bcy)/(abL*bcL);
      const ang=Math.acos(Math.max(-1,Math.min(1, dot)));
      if(ang>0.06) turn += ang;
    }

    // Envelope + closure gating (require nearClosed for circles to avoid triangles being mistaken)
    const aspect = bb.w / (bb.h || 1);
    const roundish = (aspect > 0.55 && aspect < 1.85);
    if(!nearClosed) return;
    if(domCornerCount >= 3) return; // extra safety

    if(roundish && turn > 5.4){
      const cx=bb.cx, cy=bb.cy;
      const rx=bb.w/2, ry=bb.h/2;

      // Radial consistency check
      let rSum=0;
      for(const p of pts) rSum += Math.hypot(p.x-cx, p.y-cy);
      const rMean = rSum / pts.length;
      let v=0;
      for(const p of pts){
        const rr = Math.hypot(p.x-cx, p.y-cy);
        const d = rr - rMean;
        v += d*d;
      }
      const sd = Math.sqrt(v / pts.length);
      // Require consistent radius; squares/triangles tend to have big radius variance
      if(sd > rMean * 0.24) return;

      const isCircle = Math.abs(rx-ry) < Math.max(rx,ry)*0.22;
      const n=84;
      const out=[];
      for(let i=0;i<=n;i++){
        const t=i/n*Math.PI*2;
        out.push({
          x: cx + Math.cos(t)*(isCircle?Math.min(rx,ry):rx),
          y: cy + Math.sin(t)*(isCircle?Math.min(rx,ry):ry)
        });
      }
      _inkActive._rawPoints = _inkActive._rawPoints || pts.slice();
      _inkActive.points = out;
      _inkActive._shapeCorrected = isCircle ? "circle" : "oval";
      scheduleRedrawInk();
      return;
    }
  }

  function scheduleShapeAssist(){
    if(_inkHoldTimer) clearTimeout(_inkHoldTimer);
    _inkHoldTimer = setTimeout(()=>{
      // Ensure the user is still holding (still drawing) and has actually paused
      if(!_inkDrawing || !_inkActive) return;
      const now = performance.now();
      if(now - _inkLastMoveAt < SHAPE_HOLD_MS) return;
      tryShapeAssist();
    }, SHAPE_HOLD_MS + 5);
  }

  // Drawing / erasing handlers
  // Listen on window (capture) rather than the canvas so the ink UI (e.g. size slider)
  // always receives pointer interactions.
  window.addEventListener("pointerdown", (ev)=>{
    if(!penMode) return;

    _inkLastMoveAt = performance.now();
    if(_inkHoldTimer) clearTimeout(_inkHoldTimer);

    // HARD GUARD: if the pointer is over the ink UI panel, do not start drawing.
    // Some browser/stacking setups can still deliver the event to the canvas even when the UI is visually above.
    try{
      if(inkPanelEl){
        const r = inkPanelEl.getBoundingClientRect();
        if(ev.clientX >= r.left && ev.clientX <= r.right && ev.clientY >= r.top && ev.clientY <= r.bottom){
          return;
        }
      }
    }catch(_){/* no-op */}

    // Allow board panning gestures even while ink mode is on.
    // - Middle mouse drag
    // - Shift + left drag
    if(ev.button === 1 || (ev.button === 0 && ev.shiftKey)){
      try{
        const me = new MouseEvent("mousedown", {
          bubbles: true,
          cancelable: true,
          clientX: ev.clientX,
          clientY: ev.clientY,
          button: ev.button,
          buttons: ev.buttons,
          shiftKey: ev.shiftKey,
          ctrlKey: ev.ctrlKey,
          metaKey: ev.metaKey,
          altKey: ev.altKey,
        });
        viewport.dispatchEvent(me);
      }catch(_){/* no-op */}
      return;
    }

    // If we're interacting with UI (ink panel / menus / dialogs), don't draw.
    if(ev.target && ev.target.closest && ev.target.closest("#inkPanel, #menubar, .menuDropdown, .ctxMenu, .panel, .modal")) return;
    const elAt = document.elementFromPoint(ev.clientX, ev.clientY);
    if(elAt && elAt.closest && elAt.closest("#inkPanel, #menubar, .menuDropdown, .ctxMenu, .panel, .modal")) return;

    ev.preventDefault();
    ev.stopPropagation();

    const w = worldFromClient(ev.clientX, ev.clientY);


    if(inkTool === "eraser"){
      _inkActive = { erase: true, width: inkWidth, alpha: 1, points: [w] };
      _inkDrawing = true;
      _inkLast = w;
      return;
    }

    _inkActive = { color: inkColor, width: inkWidth, alpha: 1, points: [w] };
    _inkDrawing = true;
    _inkLast = w;
  }, true);

  window.addEventListener("pointermove", (ev)=>{
    if(!penMode) return;

    const __now = performance.now();
    _inkLastMoveAt = __now;
    // If we already auto-corrected a shape and the user moves again meaningfully,
    // revert to raw points and keep drawing normally.
    if(_inkDrawing && _inkActive && _inkActive._shapeCorrected && _inkActive._rawPoints && inkTool === "pen"){
      try{
        const w0 = worldFromClient(ev.clientX, ev.clientY);
        const lastPt = (_inkActive.points && _inkActive.points.length) ? _inkActive.points[_inkActive.points.length-1] : null;
        if(lastPt && Math.hypot(w0.x-lastPt.x, w0.y-lastPt.y) > SHAPE_UNLOCK_DIST){
          _inkActive.points = _inkActive._rawPoints.slice();
          _inkActive._shapeCorrected = null;
          scheduleRedrawInk();
        }
      }catch(_){ }
    }
    if(_inkDrawing && inkTool === "pen") scheduleShapeAssist();
    // If the pointer wanders over UI while drawing, stop cleanly (prevents accidental scribbles behind menus).
    if(_inkDrawing){
      const elAt = document.elementFromPoint(ev.clientX, ev.clientY);
      if(elAt && elAt.closest && elAt.closest("#menubar, .menuDropdown, .ctxMenu, .panel, .modal")){
        endInk(ev);
        return;
      }
    }
// Track cursor for eraser outline even when not drawing
    try{
      const vr = viewport.getBoundingClientRect();
      const inside = (ev.clientX >= vr.left && ev.clientX <= vr.right && ev.clientY >= vr.top && ev.clientY <= vr.bottom);
      _inkCursor.x = ev.clientX - vr.left;
      _inkCursor.y = ev.clientY - vr.top;
      _inkCursor.has = inside;
      const elAt = document.elementFromPoint(ev.clientX, ev.clientY);
      _inkCursor.overUI = !!(elAt && elAt.closest && elAt.closest("#inkPanel, #menubar, .menuDropdown, .ctxMenu, .panel, .modal"));
    }catch(_){
      _inkCursor.has = false;
      _inkCursor.overUI = false;
    }
    updateEraserCursorDom();


    if(!_inkDrawing || !_inkActive){
      // If we're just moving the cursor in eraser mode, refresh the outline.
      if(penMode && inkTool === "eraser") scheduleRedrawInk();
      return;
    }

    ev.preventDefault();
    ev.stopPropagation();

    const w = worldFromClient(ev.clientX, ev.clientY);

    // ignore ultra tiny moves
    const dx = w.x - _inkLast.x;
    const dy = w.y - _inkLast.y;
    if((dx*dx + dy*dy) < 0.25) return;

    _inkActive.points.push(w);

    // Draw incremental segment in screen space (fast)
    const a = worldToScreen(_inkLast);
    const b = worldToScreen(w);
    inkCtx.lineCap = "round";
    inkCtx.lineJoin = "round";
    inkCtx.globalAlpha = _inkActive.alpha ?? 1;
    if(_inkActive.erase){
      inkCtx.globalCompositeOperation = "destination-out";
      inkCtx.strokeStyle = "rgba(0,0,0,1)";
    }else{
      inkCtx.globalCompositeOperation = "source-over";
      inkCtx.strokeStyle = _inkActive.color;
    }
    inkCtx.lineWidth = _inkActive.width;
    inkCtx.beginPath();
    inkCtx.moveTo(a.x, a.y);
    inkCtx.lineTo(b.x, b.y);
    inkCtx.stroke();
    inkCtx.globalCompositeOperation = "source-over";
    inkCtx.globalAlpha = 1;

    _inkLast = w;
  }, true);

  function endInk(ev){
    if(!penMode) return;
    try{ if(_inkHoldTimer) clearTimeout(_inkHoldTimer); }catch(_){ }
    ev?.preventDefault?.();
    ev?.stopPropagation?.();
    if(!_inkDrawing) return;
    _inkDrawing = false;

    if(_inkActive && _inkActive.points.length > 1){
      inkStrokes.push(_inkActive);
      pushInkAction({ t:"add", stroke: _inkActive });
    }
    _inkActive = null;
    _inkLast = null;
    scheduleRedrawInk();
  }

  window.addEventListener("pointerup", endInk, true);
  window.addEventListener("pointercancel", endInk, true);
  inkCanvas.addEventListener("lostpointercapture", endInk);

  window.addEventListener("resize", resizeInkCanvas);

  // Keyboard toggles
  window.addEventListener("keydown", (e)=>{
    if(e.defaultPrevented) return;
    if(e.key === "Escape" && penMode){
      setPenMode(false);
      return;
    }

        // (Ink undo handled by global keyboard handler)

// Toggle pen mode (P) (but don't hijack typing)
    if((e.key === "p" || e.key === "P") && !e.ctrlKey && !e.metaKey && !e.altKey){
      if(isTypingTarget(document.activeElement)) return;
      e.preventDefault();
      if(penMode){
        setPenMode(false);
      }else{
        setInkTool("pen");
        setPenMode(true);
      }
      return;
    }
    if((e.key === "e" || e.key === "E") && !e.ctrlKey && !e.metaKey && !e.altKey){
      if(isTypingTarget(document.activeElement)) return;
      e.preventDefault();
      setInkTool("eraser");
      return;
    }
  });

  // Initial sizing (after layout)
  setTimeout(resizeInkCanvas, 0);
  /* ---------- /Ink ---------- */


function updateGridClass(){
    board.classList.toggle("gridOff", !gridVisible);
  }

  function worldFromClient(clientX, clientY){
    const rect = viewport.getBoundingClientRect();
    const x = (clientX - rect.left - view.x) / view.scale;
    const y = (clientY - rect.top  - view.y) / view.scale;
    return { x, y };
  }

  function cssEscapeId(id){
    if(window.CSS && typeof CSS.escape === "function") return CSS.escape(String(id));
    return String(id).replace(/[^a-zA-Z0-9_-]/g, (m)=>"\\"+m);
  }

  /* ---------- Image card resize (drag corner) ---------- */
  function startResize(id, ev){
    const c = cards.find(cc => cc.id === id);
    if(!c || c.locked) return;
    // One history entry for the whole resize gesture
    pushHistory();
    resizing.active = true;
    resizing.live = true;
    resizing.id = id;
    resizing.startClientX = ev.clientX;
    resizing.startClientY = ev.clientY;
    // Lock intent axis for the whole gesture (prevents diagonal lane confusion)
    resizing.axisLocked = null;
    resizing.axisNow = null;
    resizing.axisPhase = null;
    resizing.switchStreak = 0;
    resizing.seqFirst = null;
    resizing.orderNow = null;
    resizing.primaryOnly = false;
    resizing.prevDx = 0;
    resizing.prevDy = 0;

    // Images should resize without pushing adjacent cards around.
    // Text cards keep the push-away solver so layouts stay tidy.
    resizing.noPush = (c.type === "image");
        // Reset per-gesture caches so previous resize sessions can't "teleport" cards.
    resizing.lastPositions = new Map();
    resizing.prevW = null;
    resizing.prevH = null;
// Use the card's *current visual size* as the baseline, not the global layout size.
// Otherwise the first resize on a normal card can "jump" to match the largest resized card elsewhere.
const el0 = board.querySelector(`.card[data-id="${cssEscapeId(c.id)}"]`);
const baseDims = getBaseCardDims();
const curW = (el0 && el0.offsetWidth) ? el0.offsetWidth : baseDims.w;
const curH = (el0 && el0.offsetHeight) ? el0.offsetHeight : baseDims.h;

resizing.startW = (c.w != null ? c.w : curW);
resizing.startH = (c.h != null ? c.h : curH);


    // Multi-card resize: if multiple cards are selected, resize them together.
// Resize ALL selected cards (except locked). Followers do NOT run their own collision solver during the gesture;
// we solve collisions once from the primary resized card to keep adjacent cards deterministic.
const follow = [];
for(const sid of selected){
  if(sid === id) continue;
  const sc = cards.find(cc => cc.id === sid);
  if(!sc || sc.locked) continue;
  follow.push(sid);
}
resizing.followIds = follow;
    // Multi-resize stability: disable push-away while dragging a multi-selection (prevents solver cascades)
    if(resizing.followIds && resizing.followIds.length){ resizing.noPush = true; }
resizing.followStarts = new Map();
for(const fid of follow){
  const fc = cards.find(cc => cc.id === fid);
  if(!fc) continue;
  const elF = board.querySelector(`.card[data-id="${cssEscapeId(fc.id)}"]`);
  const b = getBaseCardDims();
  const vw = (elF && elF.offsetWidth) ? elF.offsetWidth : b.w;
  const vh = (elF && elF.offsetHeight) ? elF.offsetHeight : b.h;
  resizing.followStarts.set(fid, {
    w: (fc.w != null ? fc.w : vw),
    h: (fc.h != null ? fc.h : vh),
  });
}

// Multi-resize: capture starting positions so selected cards can make space for each other.
resizing.selfIds = [id, ...follow];
resizing.selfStartPos = new Map();
for(const sid of resizing.selfIds){
  const sc = cards.find(cc => cc.id === sid);
  if(!sc) continue;
  resizing.selfStartPos.set(sid, { x: sc.x, y: sc.y });
}


// Inertia smoothing state (only used when snapping is engaged)
    resizing.smoothW = resizing.startW;
    resizing.smoothH = resizing.startH;
    resizing.lastSnapX = null;
    resizing.lastSnapY = null;

    // Anchor rect at gesture start (used to keep neighbour cards in their original
    // row/column lanes during diagonal resizes).
    resizing.baseX = c.x;
    resizing.baseY = c.y;
    resizing.baseW = resizing.startW;
    resizing.baseH = resizing.startH;

    // Per-frame axis choice for push-away.
    resizing.axisNow = null;
    resizing.prevDx = 0;
    resizing.prevDy = 0;

    resizing.followIds = null;
    resizing.followStarts = null;

    // Multi-card resize: if this card is part of a multi-selection, all other selected cards
    // will follow the same delta (dw/dh) during this gesture.
    try{
      const selIds = Array.from(selected || []);
      if(selIds.includes(id) && selIds.length > 1){
        const followers = selIds.filter(sid => sid !== id);
        // Only keep followers that are not locked (locked cards should not change).
        const liveFollowers = [];
        const starts = new Map();
        const base = getBaseCardDims();
        for(const fid of followers){
          const fc = cards.find(cc => cc.id === fid);
          if(!fc || fc.locked) continue;
          const fel = __getCardEl(fid) || board.querySelector(`.card[data-id="${cssEscapeId(fid)}"]`);
          const fw = (fel && fel.offsetWidth) ? fel.offsetWidth : (typeof fc.w === "number" ? fc.w : base.w);
          const fh = (fel && fel.offsetHeight) ? fel.offsetHeight : (typeof fc.h === "number" ? fc.h : base.h);
          starts.set(fid, { w: fw, h: fh });
          liveFollowers.push(fid);
        }
        resizing.followIds = liveFollowers;
        resizing.followStarts = starts;
      }
    }catch(_){ /* ignore */ }

    resizing.smoothW = null;
    resizing.smoothH = null;
    resizing.lastSnapX = null;
    resizing.lastSnapY = null;
    resizing.lastDx = 0;
    resizing.lastDy = 0;

    // Baseline push-away: capture the starting positions of cards in the same scope.
// This lets them move out of the way while resizing, but return when shrinking.
// NOTE (multi-resize): exclude ALL selected cards from the scope so the solver only moves neighbours.
const selectedSet = new Set([c.id, ...(follow || [])]);
const scope = (c.groupId
  ? cards.filter(cc => cc.groupId === c.groupId && !selectedSet.has(cc.id))
  : cards.filter(cc => !cc.groupId && !selectedSet.has(cc.id))
);

resizing.baseline = new Map();
resizing.scopeIds = scope.map(s => s.id);
for(const s of scope){
  resizing.baseline.set(s.id, { x: s.x, y: s.y });
}

    // Pre-compute a stable 'lane' for each nearby card at the start of the gesture.
    // This prevents cards from changing row/column classification mid-resize (the root cause of teleporting).
    // Lanes are based on the tidy grid used by Arrange.
    (function computeResizeLanes(){
      // Stable, geometry-based lane classification for this resize gesture.
      // Uses rectangle overlap (not just centerline distance) so slightly misaligned
      // cards still behave like they are in the same visual row/column.
      resizing.lanes = new Map();
      resizing.gridIndex = new Map();
      resizing.gridOffset = new Map();

      const { w: baseW, h: baseH } = getBaseCardDims();

      // Keep this consistent with Arrange()/solver gap so we don't "invent" new lanes.
      const gap = 18;
      const stepX = baseW + gap;
      const stepY = baseH + gap;

      function modNorm(v, m){
        const r = v % m;
        return r < 0 ? r + m : r;
      }
      function modeOffset(values, step){
        if(!values.length) return 0;
        const counts = new Map();
        for(const v of values){
          const off = Math.round(modNorm(v, step));
          counts.set(off, (counts.get(off) || 0) + 1);
        }
        let best = 0, bestCount = -1;
        for(const [off, cnt] of counts.entries()){
          if(cnt > bestCount || (cnt === bestCount && off < best)){
            best = off; bestCount = cnt;
          }
        }
        return best;
      }

      const sampleX = [c.x, ...scope.map(s => s.x)];
      const sampleY = [c.y, ...scope.map(s => s.y)];
      const gridX0 = modeOffset(sampleX, stepX);
      const gridY0 = modeOffset(sampleY, stepY);

      // Store grid geometry for the whole gesture.
      resizing.grid = { x0: gridX0, y0: gridY0, stepX, stepY, gap };

      const colOf = (x) => Math.round((x - gridX0) / stepX);
      const rowOf = (y) => Math.round((y - gridY0) / stepY);

      const rRect = rectForCard(c);
      const rCol = colOf(c.x);
      const rRow = rowOf(c.y);

      const overlapFrac = (a0, a1, b0, b1) => {
        const o = Math.min(a1, b1) - Math.max(a0, b0);
        if(o <= 0) return 0;
        return o / Math.min(a1 - a0, b1 - b0);
      };

      for(const s of scope){
        const sRect = rectForCard(s);

        // Persist indices + offsets so pushed cards don't "snap" to a different lane
        // just because they're slightly off-grid.
        const col = colOf(s.x);
        const row = rowOf(s.y);
        resizing.gridIndex.set(s.id, { col, row });

        const snapX = gridX0 + col * stepX;
        const snapY = gridY0 + row * stepY;
        resizing.gridOffset.set(s.id, { ox: s.x - snapX, oy: s.y - snapY });

        const rowOverlap = overlapFrac(rRect.y, rRect.b, sRect.y, sRect.b);
        const colOverlap = overlapFrac(rRect.x, rRect.r, sRect.x, sRect.r);

        // If it overlaps meaningfully in Y, it reads as the same "row band".
        if(rowOverlap >= 0.28){
          resizing.lanes.set(s.id, "row");
        // If it overlaps meaningfully in X and sits below, it reads as the same "column band".
        // Column lane should be *strict*: only cards that started in the same snapped column
        // as the resized card are treated as "below" and X-locked.
        // Without this, a small card that sits near (or is partially covered by) a larger card
        // can be misclassified as column-below, then get pushed down through many cards,
        // which reads as a "teleport to the end of the column".
        }else if(colOverlap >= 0.28 && row > rRow && col === rCol){
          resizing.lanes.set(s.id, "col");
        }else{
          resizing.lanes.set(s.id, "free");
        }
      }
    })();


    try{ ev.target.setPointerCapture(ev.pointerId); }catch(_){ }
    // Book-keep capture so we can reliably release on end/cancel.
    resizing._captureEl = ev.target;
    resizing._pointerId = ev.pointerId;
  }

// Pack selected cards during multi-resize so they don't overlap each other.
// This ONLY adjusts positions of the selected set; it does not push non-selected neighbours (stable + predictable).
function __packMultiResizeSelection(resizing, gap=16){
  if(!resizing || !resizing.selfIds || resizing.selfIds.length < 2) return;

  // Group cards into vertical lanes based on their starting X (so columns stay columns).
  const laneTol = 48; // px tolerance to treat as same column
  const ids = resizing.selfIds.slice();

  // Build entries with start positions for stable ordering
  const entries = ids.map(id=>{
    const c = cards.find(cc=>cc.id===id);
    const sp = resizing.selfStartPos ? resizing.selfStartPos.get(id) : null;
    return { id, c, sx: sp?sp.x:(c?c.x:0), sy: sp?sp.y:(c?c.y:0) };
  }).filter(e=>e.c);

  entries.sort((a,b)=> (a.sx-b.sx) || (a.sy-b.sy));

  const lanes = [];
  for(const e of entries){
    let lane = null;
    for(const ln of lanes){
      if(Math.abs(ln.sx - e.sx) <= laneTol){ lane = ln; break; }
    }
    if(!lane){
      lane = { sx: e.sx, ids: [] };
      lanes.push(lane);
    }
    lane.ids.push(e);
  }

  // Sort lanes left-to-right by starting X
  lanes.sort((a,b)=>a.sx-b.sx);

  // Within each lane, stack top-to-bottom preserving original Y as a minimum
  for(const ln of lanes){
    ln.ids.sort((a,b)=>a.sy-b.sy);
    let cursorY = null;
    for(const e of ln.ids){
      const c = e.c;
      if(cursorY == null){
        // keep first card anchored near its original Y
        c.y = e.sy;
        cursorY = c.y + c.h + gap;
      }else{
        c.y = Math.max(e.sy, cursorY);
        cursorY = c.y + c.h + gap;
      }
    }
  }

  // Now resolve cross-lane horizontal overlaps by shifting entire lanes to the right if needed.
  // Compute each lane's bounding box (after vertical stacking).
  function laneBounds(ln){
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const e of ln.ids){
      const c = e.c;
      minX = Math.min(minX, c.x);
      minY = Math.min(minY, c.y);
      maxX = Math.max(maxX, c.x + c.w);
      maxY = Math.max(maxY, c.y + c.h);
    }
    return {minX,minY,maxX,maxY};
  }

  // First, set lane X to their starting X (anchored)
  for(const ln of lanes){
    for(const e of ln.ids){
      e.c.x = e.sx;
    }
  }

  // Iteratively push lanes right if they overlap earlier lanes
  for(let i=1;i<lanes.length;i++){
    let shift = 0;
    const cur = lanes[i];

    // Consider overlap with any previous lane
    for(let j=0;j<i;j++){
      const prev = lanes[j];
      const bPrev = laneBounds(prev);
      const bCur = laneBounds(cur);

      const vOverlap = !(bCur.maxY < bPrev.minY || bCur.minY > bPrev.maxY);
      const hOverlap = !(bCur.maxX < bPrev.minX || bCur.minX > bPrev.maxX);
      if(vOverlap && hOverlap){
        // Move current lane to the right of previous lane
        shift = Math.max(shift, (bPrev.maxX + gap) - bCur.minX);
      }
    }

    if(shift > 0){
      for(const e of cur.ids){
        e.c.x += shift;
      }
    }
  }

  // Apply DOM styles for moved selected cards (fast path)
  for(const e of entries){
    const c = e.c;
    const el = __getCardEl(c.id);
    if(el){
      el.style.left = `${c.x}px`;
      el.style.top  = `${c.y}px`;
    }
  }
}

// Live neighbour shifting during MULTI-resize (deterministic + stable).
// We only move NON-selected neighbours (scopeIds) using the existing lane-stable solver,
// but we run it during the drag so you can see where cards are going.
let __multiPushRaf = null;
function __liveMultiResizePush(resizing){
  if(!resizing || !resizing.followIds || !resizing.followIds.length) return;
  if(!resizing.scopeIds || !resizing.scopeIds.length) return;

  if(__multiPushRaf) return;
  __multiPushRaf = requestAnimationFrame(()=>{
    __multiPushRaf = null;

    // Ensure selected set is packed first so it doesn't self-overlap
    __packMultiResizeSelection(resizing);

    
      __liveMultiResizePush(resizing);
const ids = (resizing.selfIds && resizing.selfIds.length)
      ? resizing.selfIds.slice()
      : [resizing.id, ...(resizing.followIds||[])];

    // Deterministic order: top-to-bottom then left-to-right based on gesture start
    ids.sort((a,b)=>{
      const pa = resizing.selfStartPos ? resizing.selfStartPos.get(a) : null;
      const pb = resizing.selfStartPos ? resizing.selfStartPos.get(b) : null;
      const ax = pa?pa.x:0, ay = pa?pa.y:0;
      const bx = pb?pb.x:0, by = pb?pb.y:0;
      return (ay-by) || (ax-bx);
    });

    resizing.live = true;
    resizing.primaryOnly = false;
    resizing.noPush = false;

    for(const rid of ids){
      const rc = cards.find(cc => cc.id === rid);
      if(!rc) continue;
      resolveResizeCollisions(rc, resizing);
    }

    // Fast DOM update for moved neighbours
    for(const nid of resizing.scopeIds){
      const nc = cards.find(cc => cc.id === nid);
      if(!nc) continue;
      const el = __getCardEl(nc.id);
      if(el){
        el.style.left = `${nc.x}px`;
        el.style.top  = `${nc.y}px`;
      }
    }
    ensureBoardFits();
  });
}

  function resizeMove(ev){
    if(!resizing.active) return;
    const c = cards.find(cc => cc.id === resizing.id);
    if(!c) return;

    const dx = (ev.clientX - resizing.startClientX) / view.scale;
    const dy = (ev.clientY - resizing.startClientY) / view.scale;

    // Track gesture direction so push-away resolves in the expected axis.
    // We pick the push axis *per frame* from the user's current movement so
    // resizing down-then-sideways behaves intuitively.
    resizing.lastDx = dx;
    resizing.lastDy = dy;

    
// Track current intent axis for the solver (direction of resize)
// Horizontal => prefer shifting adjacent cards RIGHT, Vertical => prefer shifting adjacent cards DOWN.
const adx = Math.abs(dx), ady = Math.abs(dy);
resizing.axisNow = (adx > ady) ? "horizontal" : (ady > adx) ? "vertical" : resizing.axisNow;
const prevDx = (typeof resizing.prevDx === "number") ? resizing.prevDx : 0;
    const prevDy = (typeof resizing.prevDy === "number") ? resizing.prevDy : 0;
    const incDx  = dx - prevDx;
    const incDy  = dy - prevDy;
    resizing.prevDx = dx;
    resizing.prevDy = dy;

    // Decide push axis for this gesture (phase-based, can switch ONCE the user clearly changes direction).
    // This keeps movement deterministic (no per-card axis decisions), while still allowing L-shape (rightâ†’down / downâ†’right)
    // in a single continuous gesture.
    const dead = 2.5;
    const STEP_DEAD = 1.5;       // ignore tiny hand jitter per-frame
    const SWITCH_STREAK = 3;     // require a few consecutive steps before switching
    const SWITCH_TOTAL = dead*3; // require meaningful travel in the other axis before switching

    // Establish an initial phase once movement clears the dead zone.
    if(!resizing.axisPhase){
      const ax = Math.abs(dx), ay = Math.abs(dy);
      if(ax > dead || ay > dead){
        resizing.axisPhase = (ax >= ay) ? 'horizontal' : 'vertical';
        if(!resizing.seqFirst) resizing.seqFirst = resizing.axisPhase;
      }
    }
    if(!resizing.axisPhase){
      // Before we have enough motion to decide, keep everything stable.
      resizing.axisPhase = 'horizontal';
    }

    // Allow switching phases when the user *clearly* changes direction mid-gesture (L-shape).
    // We base this on incremental movement, not total dx/dy, so rightâ†’down works naturally.
    const stepAx = Math.abs(incDx), stepAy = Math.abs(incDy);
    const stepMag = stepAx + stepAy;
    const stepDom = (stepAx >= stepAy) ? 'horizontal' : 'vertical';

    if(stepMag > STEP_DEAD){
      if(stepDom !== resizing.axisPhase){
        resizing.switchStreak = (resizing.switchStreak || 0) + 1;
      }else{
        resizing.switchStreak = 0;
      }

      if((resizing.switchStreak || 0) >= SWITCH_STREAK){
        const otherTotal = (resizing.axisPhase === 'horizontal') ? Math.abs(dy) : Math.abs(dx);
        if(otherTotal > SWITCH_TOTAL){
          resizing.axisPhase = stepDom;
        }
        resizing.switchStreak = 0;
      }
    }

    resizing.axisNow = resizing.axisPhase;

    // L-shape support is handled by axisPhase switching above.
    // Keep the collision solver strictly single-axis each frame for neat, lane-stable movement.
    resizing.primaryOnly = true;
    resizing.orderNow = null;
    resizing.canLShape = false;


    const minW = 180, minH = 140;
    const maxW = 1400, maxH = 1100;

    let wantW = clamp(Math.round(resizing.startW + dx), minW, maxW);
    let wantH = clamp(Math.round(resizing.startH + dy), minH, maxH);

    const shiftSnap = (ev.shiftKey || __shiftDown);

    let snapLineX = null;
    let snapLineY = null;
    let targetW = wantW;
    let targetH = wantH;
    let snapActive = false;

    if(shiftSnap){
      const snapped = snapResizeWH(c, wantW, wantH);
      targetW = snapped.w;
      targetH = snapped.h;
      snapLineX = (snapped && snapped.snapLineX != null) ? snapped.snapLineX : null;
      snapLineY = (snapped && snapped.snapLineY != null) ? snapped.snapLineY : null;
      snapActive = !!(snapped && snapped.snapActive);
    }

    // Inertia smoothing only when a snap is actively engaged (so free-resize stays crisp)
    if(shiftSnap && snapActive){
      const a = 0.35; // smoothing factor
      resizing.smoothW = (typeof resizing.smoothW === "number") ? resizing.smoothW + (targetW - resizing.smoothW) * a : targetW;
      resizing.smoothH = (typeof resizing.smoothH === "number") ? resizing.smoothH + (targetH - resizing.smoothH) * a : targetH;
      wantW = clamp(Math.round(resizing.smoothW), minW, maxW);
      wantH = clamp(Math.round(resizing.smoothH), minH, maxH);
    }else{
      resizing.smoothW = targetW;
      resizing.smoothH = targetH;
      wantW = targetW;
      wantH = targetH;
    }

    c.w = wantW;
    c.h = wantH;

    // Apply delta resize to other selected cards (multi-card resize)
    if(resizing.followIds && resizing.followIds.length){
      const dw = wantW - resizing.startW;
      const dh = wantH - resizing.startH;
      for(const fid of resizing.followIds){
        const fc = cards.find(cc => cc.id === fid);
        if(!fc || fc.locked) continue;
        const st = resizing.followStarts ? resizing.followStarts.get(fid) : null;
        if(!st) continue;
        const nw = clamp(Math.round(st.w + dw), minW, maxW);
        const nh = clamp(Math.round(st.h + dh), minH, maxH);
        fc.w = nw;
        fc.h = nh;
        const fel = __getCardEl(fc.id);
        if(fel){
          fel.style.width = `${fc.w}px`;
          fel.style.height = `${fc.h}px`;
        }
        if(fc.groupId){ scheduleGroupDomUpdate(fc.groupId); }
          // IMPORTANT: During multi-resize, do NOT run the collision solver per follower.
  // That causes order-dependent cascades where adjacent cards "freak out" as multiple solvers fight.
  // We'll solve collisions once from the primary resized card after updating all sizes.
}
    }


// Multi-resize: make selected cards create space for each other (internal packing only).
if(resizing.followIds && resizing.followIds.length){
  __packMultiResizeSelection(resizing);
}

    // Update only the element sizing for smoothness (avoid full re-render + image re-decode)
    const el = __getCardEl(c.id);
    if(el){
      el.style.width = `${c.w}px`;
      el.style.height = `${c.h}px`;
      if(c.groupId){ scheduleGroupDomUpdate(c.groupId); }
    }

    // Ensure the board grows with the largest pushed/resized card so nothing appears to disappear.
    ensureBoardFits();

    // Push-away layout: while resizing, nudge overlapping cards out of the way.
    // This prevents accidental overlaps so you can resize without manually repositioning.
    if(!resizing.noPush && !(resizing.followIds && resizing.followIds.length)) scheduleResizePush(c.id);
  }

  function resizeEnd(ev){
    if(!resizing.active) return;
    // Safety: release pointer capture if we have it (prevents 'stuck' resizing).
    try{
      if(resizing._captureEl && resizing._pointerId != null){
        resizing._captureEl.releasePointerCapture(resizing._pointerId);
      }
    }catch(_){ }
    const lastId = resizing.id;
    const c = cards.find(cc => cc.id === lastId);
    // Finalize: do a last collision pass with lane snapping (subtle during drag, crisp on release)
    resizing.live = false;
    if(c && !resizing.noPush && !(resizing.followIds && resizing.followIds.length)) resolveResizeCollisions(c, resizing);
    resizing.active = false;
    resizing.id = null;
    resizing._captureEl = null;
    resizing._pointerId = null;

    resizing.baseline = null;
    resizing.scopeIds = null;
    resizing.axisNow = null;
    resizing.baseX = null;
    resizing.baseY = null;
    resizing.baseW = null;
    resizing.baseH = null;
    resizing.prevDx = 0;
    resizing.prevDy = 0;
    resizing.noPush = false;

    // Keep any folder halo in sync after final size
    if(c && c.groupId){ scheduleGroupDomUpdate(c.groupId); }

    // Snap selection classes back in case DOM was updated directly
    syncSelectionClasses();
    save(true);
  }



/* ---------- Resize Push-Away (no-overlap while resizing) ---------- */
let __resizePushRaf = null;
let __resizePushId = null;

// Cache card DOM nodes by id so we don't querySelector() repeatedly during drag/resize.
// (querySelector inside tight loops becomes noticeable once images exist.)
let __cardElCache = new Map();

function __getCardEl(id){
  if(!id) return null;
  const key = String(id);
  const el = __cardElCache.get(key);
  if(el && el.isConnected) return el;
  const found = board.querySelector(`.card[data-id="${cssEscapeId(key)}"]`);
  if(found) __cardElCache.set(key, found);
  return found || null;
}

function scheduleResizePush(cardId){
  __resizePushId = cardId;
  if(__resizePushRaf) return;
  __resizePushRaf = requestAnimationFrame(()=>{
    __resizePushRaf = null;
    if(!__resizePushId) return;
    const c = cards.find(cc => cc.id === __resizePushId);
    __resizePushId = null;
    if(!c) return;
// Resolve collisions for the current axisPhase (single-axis per frame).
// L-shape behaviour comes from phase switching in resizeMove (no two-pass packing here).
//
// Multi-resize: we must resolve overlaps for EACH resized card, otherwise followers can
// pass through other cards and cause late, chaotic shuffles.
if(resizing && Array.isArray(resizing.followIds) && resizing.followIds.length){
  const ids = [c.id, ...resizing.followIds];
  // Deterministic order: top-to-bottom, then left-to-right by gesture baseline.
  ids.sort((a,b)=>{
    const ba = resizing.baseline && resizing.baseline.get(a);
    const bb = resizing.baseline && resizing.baseline.get(b);
    const ay = ba ? ba.y : 0, by = bb ? bb.y : 0;
    if(ay !== by) return ay - by;
    const ax = ba ? ba.x : 0, bx = bb ? bb.x : 0;
    return ax - bx;
  });
  // Allow axis selection per overlap (do NOT force primaryOnly during group solve).
  resizing.primaryOnly = false;
  for(const id of ids){
    const rc = cards.find(cc => cc.id === id);
    if(rc) resolveResizeCollisions(rc, resizing);
  }
}else{
  if(resizing){ resizing.primaryOnly = true; }
  resolveResizeCollisions(c, resizing);
}
  });
}

function rectForCard(c){
  const { w, h } = getCardDimsFor(c);
  return { x: c.x, y: c.y, w, h, r: c.x + w, b: c.y + h };
}

function rectsOverlap(a, b){
  return a.x < b.r && a.r > b.x && a.y < b.b && a.b > b.y;
}

function updateCardDomPos(c){
  const el = __getCardEl(c.id);
  if(el){
    el.style.left = `${c.x}px`;
    el.style.top  = `${c.y}px`;
  }
}


function ensureBoardFits(){
  // Prevent "disappearing" cards by expanding the board when layout pushes cards past current bounds.
  // (Board is a big absolute surface; if cards get pushed beyond it, they look like they vanished.)
  const BASE_W = 6000, BASE_H = 4000;
  const PAD = 900; // extra breathing room beyond farthest card
  let maxR = BASE_W, maxB = BASE_H;

  for(const c of cards){
    const d = (typeof getCardDimsFor === "function") ? getCardDimsFor(c) : getCardDims();
    const w = Math.max(1, d.w || 0);
    const h = Math.max(1, d.h || 0);
    maxR = Math.max(maxR, (c.x || 0) + w);
    maxB = Math.max(maxB, (c.y || 0) + h);
  }

  // Round up to reduce DOM churn
  const w2 = Math.ceil((maxR + PAD) / 200) * 200;
  const h2 = Math.ceil((maxB + PAD) / 200) * 200;

  if(board.__bbW !== w2){
    board.style.width = `${w2}px`;
    board.__bbW = w2;
  }
  if(board.__bbH !== h2){
    board.style.height = `${h2}px`;
    board.__bbH = h2;
  }
}



function resolveResizeCollisions(resized, resizeCtx){
  // Deterministic, lane-stable solver:
  //   - Cards in the resized card's baseline ROW lane only move RIGHT (Y locked).
  //   - Cards in the resized card's baseline COLUMN-below lane only move DOWN (X locked).
  //   - Other cards may move RIGHT or DOWN, but NEVER left/up, and never swap lanes mid-gesture.
  //
  // This removes the "teleport / sucked underneath" behaviour caused by per-frame reclassification.

  // IMPORTANT: keep this in sync with Arrange() so lanes + packing behave consistently.
  const GAP = 18;

  
  const live = !(resizeCtx && resizeCtx.live === false);
  const grid = (resizeCtx && resizeCtx.grid) ? resizeCtx.grid : null;
  const gridX0 = grid ? grid.x0 : 0;
  const gridY0 = grid ? grid.y0 : 0;
  const stepX  = grid ? grid.stepX : 0;
  const stepY  = grid ? grid.stepY : 0;

  const gridOffset = (resizeCtx && resizeCtx.gridOffset) ? resizeCtx.gridOffset : null;
  const gridIndex  = (resizeCtx && resizeCtx.gridIndex) ? resizeCtx.gridIndex : null;

  function snapXFor(id, minX){
    if(!grid || !stepX) return minX;
    const off = (gridOffset && id != null) ? gridOffset.get(id) : null;
    const ox = off ? off.ox : 0;
    // Choose the smallest column such that (gridX0 + col*stepX + ox) >= minX.
    // Incorporate ox inside the ceil so slightly off-grid cards don't "teleport" to the next lane.
    const col = Math.ceil((minX - gridX0 - ox) / stepX);
    return gridX0 + col * stepX + ox;
  }
  function snapYFor(id, minY){
    if(!grid || !stepY) return minY;
    const off = (gridOffset && id != null) ? gridOffset.get(id) : null;
    const oy = off ? off.oy : 0;
    // Choose the smallest row such that (gridY0 + row*stepY + oy) >= minY.
    // Incorporate oy inside the ceil so slightly off-grid cards don't "teleport" to the next lane.
    const row = Math.ceil((minY - gridY0 - oy) / stepY);
    return gridY0 + row * stepY + oy;
  }
const baseline = (resizeCtx && resizeCtx.baseline) ? resizeCtx.baseline : null;
  const scopeIds = (resizeCtx && resizeCtx.scopeIds) ? resizeCtx.scopeIds : null;
  if(!baseline || !scopeIds) return;

  const lanes = (resizeCtx && resizeCtx.lanes) ? resizeCtx.lanes : new Map();

  // Current user intent during this gesture (computed in resizeMove).
  // "horizontal" => prefer pushing cards right, "vertical" => prefer pushing cards down.
  const intentAxis = (resizeCtx && resizeCtx.axisNow) ? resizeCtx.axisNow : null;
  const primaryOnly = !!(resizeCtx && resizeCtx.primaryOnly);

  // Remember last solved positions while growing so things don't jitter.
  const prevW = (resizeCtx && typeof resizeCtx.prevW === "number") ? resizeCtx.prevW : resized.w;
  const prevH = (resizeCtx && typeof resizeCtx.prevH === "number") ? resizeCtx.prevH : resized.h;
  const isShrinking = (typeof resized.w === "number" && resized.w < prevW) || (typeof resized.h === "number" && resized.h < prevH);
  resizeCtx.prevW = (typeof resized.w === "number") ? resized.w : prevW;
  resizeCtx.prevH = (typeof resized.h === "number") ? resized.h : prevH;

  if(resizeCtx && !resizeCtx.lastPositions) resizeCtx.lastPositions = new Map();
  const lastPos = (resizeCtx && resizeCtx.lastPositions) ? resizeCtx.lastPositions : null;

  const dimsOf = (c) => {
    const d = (typeof getCardDimsFor === "function") ? getCardDimsFor(c) : getCardDims();
    return { w: Math.max(1, d.w || 0), h: Math.max(1, d.h || 0) };
  };
  const rectAt = (x,y,w,h) => ({ x, y, w, h, r: x + w, b: y + h });
  const overlaps = (a,b) => a.x < b.r && a.r > b.x && a.y < b.b && a.b > b.y;
  // Treat "too close" as a collision by expanding the other rect by GAP in all directions.
  // This guarantees a consistent visual gutter during live dragging/resizing.
  // Axis-aware "too close" test. We only enforce the GAP in the axis we might push in,
  // and only when there is real overlap in the orthogonal axis. This keeps motion subtle
  // and prevents runaway cascades that can push cards far off-screen.
    // Axis-aware "too close" test with a *minimum orthogonal overlap*.
  // This prevents the "suction" effect where a tiny diagonal drift makes cards in a nearby lane
  // get treated as colliding and shoved out of the way.
  const ORTHO_MIN = 18; // px of real overlap required in the orthogonal axis
  // Entering another lane should feel intentional, not "scared".
  // Require a deeper overlap before we treat a neighbouring lane as blocking.
  const LANE_ENTER = 48; // px of overlap to count as "intentional lane entry"
  const overlapAmtX = (a,b) => Math.min(a.r,b.r) - Math.max(a.x,b.x);
  const overlapAmtY = (a,b) => Math.min(a.b,b.b) - Math.max(a.y,b.y);

  const tooClose = (a, b, pad, axis) => {
    if(axis === "horizontal"){
      // Only matters if we overlap vertically by a meaningful amount. Enforce horizontal gutter.
      const oy = overlapAmtY(a,b);
      if(oy < ORTHO_MIN) return false;
      const nearX = a.x < (b.r + pad) && a.r > (b.x - pad);
      return nearX;
    }
    // vertical
    const ox = overlapAmtX(a,b);
    if(ox < ORTHO_MIN) return false;
    const nearY = a.y < (b.b + pad) && a.b > (b.y - pad);
    return nearY;
  };

  // Collect scope cards with a stable baseline order.
  const scope = [];
  for(const id of scopeIds){
    const c = cards.find(cc => cc.id === id);
    if(!c) continue;
    const b = baseline.get(id);
    if(!b) continue;

    // Start from last solved position when growing, otherwise revert to baseline for shrink.
    const lp = (!isShrinking && lastPos) ? lastPos.get(id) : null;
    c.x = (lp ? lp.x : b.x);
    c.y = (lp ? lp.y : b.y);

    scope.push(c);
  }

  scope.sort((A,B)=>{
    const a0 = baseline.get(A.id) || {x:A.x,y:A.y};
    const b0 = baseline.get(B.id) || {x:B.x,y:B.y};

    // Stable lane ordering prevents "teleporting" when a slightly misaligned card
    // sits between two others. We sort along the user's active axis, using the
    // lane indices captured at resize-start (gridIndex), not recomputed per-frame.
    const ai = gridIndex ? (gridIndex.get(A.id) || null) : null;
    const bi = gridIndex ? (gridIndex.get(B.id) || null) : null;
    const aRow = ai ? ai.row : (grid && stepY ? Math.round((a0.y - gridY0) / stepY) : 0);
    const bRow = bi ? bi.row : (grid && stepY ? Math.round((b0.y - gridY0) / stepY) : 0);
    const aCol = ai ? ai.col : (grid && stepX ? Math.round((a0.x - gridX0) / stepX) : 0);
    const bCol = bi ? bi.col : (grid && stepX ? Math.round((b0.x - gridX0) / stepX) : 0);

    if(intentAxis === "horizontal"){
      return (aRow - bRow) || (a0.x - b0.x) || String(A.id).localeCompare(String(B.id));
    }
    if(intentAxis === "vertical"){
      return (aCol - bCol) || (a0.y - b0.y) || String(A.id).localeCompare(String(B.id));
    }
    return (aRow - bRow) || (aCol - bCol) || (a0.y - b0.y) || (a0.x - b0.x) || String(A.id).localeCompare(String(B.id));
  });


// --- Overlay-cluster safe resizing ---
// If multiple cards are already overlapping (even partially), treat that overlap set as a single
// rigid "cluster" while solving resize collisions. Otherwise, an overlapped pile can chain-react
// and explode apart as the solver tries to de-overlap cards that the user intentionally stacked.
const CLUSTER_MIN = 8;  // px of overlap in both axes to count as a real overlay
const rectForBaseline = (c0) => {
  const b0 = baseline.get(c0.id) || { x: c0.x, y: c0.y };
  const d0 = dimsOf(c0);
  return { id: c0.id, x: b0.x, y: b0.y, w: d0.w, h: d0.h, r: b0.x + d0.w, b: b0.y + d0.h };
};

function ufMake(n){
  const p = Array.from({length:n}, (_,i)=>i);
  const r = Array(n).fill(0);
  const find = (a)=>{ while(p[a]!==a){ p[a]=p[p[a]]; a=p[a]; } return a; };
  const uni = (a,b)=>{
    a=find(a); b=find(b);
    if(a===b) return;
    if(r[a]<r[b]){ p[a]=b; }
    else if(r[a]>r[b]){ p[b]=a; }
    else { p[b]=a; r[a]++; }
  };
  return { find, uni };
}

const baseRects = scope.map(rectForBaseline);
const uf = ufMake(baseRects.length);

// Union any pair that is *already* overlapping at gesture start.
for(let i=0;i<baseRects.length;i++){
  const A = baseRects[i];
  for(let j=i+1;j<baseRects.length;j++){
    const B = baseRects[j];
    const ox = overlapAmtX(A,B);
    const oy = overlapAmtY(A,B);
    if(ox > CLUSTER_MIN && oy > CLUSTER_MIN){
      uf.uni(i,j);
    }
  }
}

// Build clusters in the same order as `scope` (deterministic).
const clusters = new Map();
for(let i=0;i<baseRects.length;i++){
  const root = uf.find(i);
  if(!clusters.has(root)) clusters.set(root, []);
  clusters.get(root).push(scope[i]);
}

const items = [];
for(const members of clusters.values()){
  if(!members || !members.length) continue;

  // Cluster origin is the top-left of the union at gesture start (prevents negative offsets).
  let minX = Infinity, minY = Infinity, maxR = -Infinity, maxB = -Infinity;
  let lane = "free";
  for(const m of members){
    const rb = rectForBaseline(m);
    minX = Math.min(minX, rb.x);
    minY = Math.min(minY, rb.y);
    maxR = Math.max(maxR, rb.r);
    maxB = Math.max(maxB, rb.b);

    const l = lanes.get(m.id) || "free";
    if(l === "row") lane = "row";
    else if(l === "col" && lane !== "row") lane = "col";
  }

  const originB = { x: minX, y: minY };
  const offsets = new Map();
  for(const m of members){
    const b0 = baseline.get(m.id) || { x: m.x, y: m.y };
    offsets.set(m.id, { ox: b0.x - originB.x, oy: b0.y - originB.y });
  }

  // Anchor is the first member in sorted scope (stable behaviour + snapping key).
  const anchor = members[0];

  items.push({
    anchor,
    originB,
    members,
    offsets,
    w: Math.max(1, maxR - minX),
    h: Math.max(1, maxB - minY),
    lane
  });
}
  const resizedDims = dimsOf(resized);
  const placed = [{ id: resized.id, rect: rectAt(resized.x, resized.y, resizedDims.w, resizedDims.h) }];

  // Place each card by searching the first non-overlapping slot that is >= its baseline
  // (so it can only move right/down).
  for(const item of items){
    const c = item.anchor;
    const b0 = item.originB || (baseline.get(c.id) || {x:c.x, y:c.y});
    const lane = item.lane || (lanes.get(c.id) || "free");
    const d = { w: item.w, h: item.h };

    // Lane locks.
    const lockY = (lane === "row");
    const lockX = (lane === "col");

    let x0 = lockX ? b0.x : Math.max(b0.x, c.x);
    let y0 = lockY ? b0.y : Math.max(b0.y, c.y);

    // Hard gap clamp (prevents "almost overlap" during large vertical resizes):
    // Even if two rectangles don't technically overlap yet, we never allow a card that sits below
    // the resized card in its column/lane (or horizontally overlapping band) to get closer than GAP.
    const rRes = placed[0].rect; // resized card rect is always first
    const baselineBelowResized = (b0.y >= rRes.y - 1);
    const isRowLane = (lane === "row");
    const isColLane = (lane === "col");
    if(!isRowLane && baselineBelowResized){
      // Always enforce for the column-below lane (X locked => this is "directly below" behaviour).
      // Also enforce for free cards that overlap horizontally with the resized card.
      const horizOverlap = (Math.min(x0 + d.w, rRes.r) - Math.max(x0, rRes.x)) >= LANE_ENTER; // require intentional overlap to avoid lane "suction"
      // IMPORTANT: if the user is currently resizing horizontally (including the common
      // "L-shape" gesture: down then right), we must NOT force right-side neighbours to
      // drop down just because their baseline lane isn't perfectly aligned.
      // Only enforce the vertical gutter for:
      //  - true column-below lane cards, or
      //  - free cards when the intent is NOT horizontal.
      const intentIsHorizontal = (intentAxis === "horizontal");
      if(isColLane || (horizOverlap && !intentIsHorizontal)){
        const minY = rRes.b + GAP;
        if(y0 < minY) y0 = minY;
      }
    }

    // Deterministic stepping: try to resolve by pushing along the allowed axis only.
    let x = x0, y = y0;
    let r = rectAt(x, y, d.w, d.h);

    // Hard cap to avoid runaway loops in extreme edge cases.
    for(let iter=0; iter<500; iter++){
      let hit = null;
      // Check "too close" only in the axis we are likely to push in. This avoids
      // chain-reaction pushes that can send cards far away (which feels like vanishing).
      let axisCheck = "both";
      if(lockY && !lockX) axisCheck = "horizontal";
      else if(lockX && !lockY) axisCheck = "vertical";
      else if(primaryOnly && (intentAxis === "horizontal" || intentAxis === "vertical")) axisCheck = intentAxis;
      for(const p of placed){
        const pr = p.rect;
        const h = tooClose(r, pr, GAP, "horizontal");
        const v = tooClose(r, pr, GAP, "vertical");
        const close = (axisCheck === "horizontal") ? h : (axisCheck === "vertical") ? v : (h || v);
        if(close) { hit = pr; break; }
      }
      if(!hit) break;

      // If lane-locked, only move in that axis.
      if(lockY && !lockX){
        x = (live ? (hit.r + GAP) : snapXFor(c.id, hit.r + GAP)); // right only (snap to lane grid)
      }else if(lockX && !lockY){
        y = (live ? (hit.b + GAP) : snapYFor(c.id, hit.b + GAP)); // down only (snap to lane grid)
      }else{
        // Free: follow the user's dominant axis when possible.
        const candX = live ? (hit.r + GAP) : snapXFor(c.id, hit.r + GAP);
        const candY = live ? (hit.b + GAP) : snapYFor(c.id, hit.b + GAP);

        const preferH = (intentAxis === "horizontal");
        const preferV = (intentAxis === "vertical");

        // If the user is clearly moving along one axis, avoid diagonal drift.
        // Still allow a late fallback to the other axis in extreme cases so we can always de-overlap.
        const allowFallback = (!primaryOnly) || (iter > 360);

        if(preferH && (!preferV || allowFallback)){
          x = candX;
        }else if(preferV && (!preferH || allowFallback)){
          y = candY;
        }else{
          // No strong intent: choose the smaller displacement.
          const dx = candX - x;
          const dy = candY - y;
          if(dx <= dy) x = candX;
          else y = candY;
        }
      }

      // Enforce right/down constraints
      if(x < x0) x = x0;
      if(y < y0) y = y0;
      r = rectAt(x, y, d.w, d.h);
    }

    // Apply solved anchor position to every card in the stack (keeps stacks stable).
    let minX = Infinity, minY = Infinity, maxR = -Infinity, maxB = -Infinity;
    for(const m2 of item.members){
      const off = item.offsets.get(m2.id) || { ox: 0, oy: 0 };
      m2.x = r.x + off.ox;
      m2.y = r.y + off.oy;
      const md = dimsOf(m2);
      minX = Math.min(minX, m2.x);
      minY = Math.min(minY, m2.y);
      maxR = Math.max(maxR, m2.x + md.w);
      maxB = Math.max(maxB, m2.y + md.h);
      if(lastPos) lastPos.set(m2.id, { x: m2.x, y: m2.y });
      updateCardDomPos(m2);
    }

    const unionRect = { x: minX, y: minY, w: Math.max(1, maxR - minX), h: Math.max(1, maxB - minY) };
    unionRect.r = unionRect.x + unionRect.w;
    unionRect.b = unionRect.y + unionRect.h;
    placed.push({ id: c.id, rect: unionRect });
  }

  ensureBoardFits();
}




  window.addEventListener("pointermove", resizeMove, { passive: true });
  window.addEventListener("pointerup", resizeEnd, { passive: true });
  window.addEventListener("pointercancel", resizeEnd, { passive: true });

  // Fallbacks: some environments can miss pointerup (e.g. release outside window).
  window.addEventListener("mouseup", resizeEnd, { passive: true });
  window.addEventListener("touchend", resizeEnd, { passive: true });
  window.addEventListener("touchcancel", resizeEnd, { passive: true });
  window.addEventListener("blur", resizeEnd, { passive: true });
  document.addEventListener("visibilitychange", ()=>{ if(document.hidden) resizeEnd({}); }, { passive: true });

  // Saving gets expensive once images exist (huge base64 strings). Debounce localStorage writes.
  let __saveTimer = null;
  function save(immediate=false){
    // Avoid expensive serialization during active pointer interactions (drag/resize).
    try{ if(drag && drag.active) { immediate=false; } }catch(_){ }
    try{ if(resizing && resizing.active) { immediate=false; } }catch(_){ }
    const doWrite = () => {
      const payload = { view, cards, gridVisible, groupStyles };
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      }catch(err){
        // If storage is blocked (e.g., file:// restrictions or privacy mode), donâ€™t break core UX.
        console.warn("Save skipped (localStorage unavailable):", err);
      }
    };

    if(immediate){
      if(__saveTimer){ clearTimeout(__saveTimer); __saveTimer = null; }
      doWrite();
      return;
    }

    if(__saveTimer) clearTimeout(__saveTimer);
    __saveTimer = setTimeout(()=>{
      __saveTimer = null;
      doWrite();
    }, 280);
  }

  function load(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return false;
    try{
      const parsed = JSON.parse(raw);
      if(parsed && parsed.cards && parsed.view){
        view = parsed.view;
        cards = parsed.cards;
        if(typeof parsed.gridVisible === "boolean") gridVisible = parsed.gridVisible;
        groupStyles = parsed.groupStyles || {};
        // migrate older fields if present
        cards.forEach(c => {
          if(!("preset" in c)) c.preset = c.color || "neutral";
          if(!("customColor" in c)) c.customColor = null;
          if(!("noHeader" in c)) c.noHeader = false;
          if(!("locked" in c)) c.locked = false;
              if(!("struck" in c)) c.struck = false;
          delete c.time; // remove time if imported from old
        });
        return true;
      }
    }catch(e){}
    return false;
  }

  function syncSelectionClasses(){
    document.querySelectorAll(".card").forEach(el => {
      const id = el.dataset.id;
      el.classList.toggle("multiSelected", selected.has(id));
      el.classList.toggle("selected", id === selectedId);
    });
  }

  // Expose minimal hooks for box-select overlay (kept simple + stable).
  // This avoids scope issues when the overlay code lives outside this IIFE.
  window.__BB = window.__BB || {};
  window.__BB.getSelected = () => selected;
  window.__BB.setSelected = (nextSet) => { selected = nextSet; syncSelectionClasses(); };
  window.__BB.getSelectedId = () => selectedId;
  window.__BB.setSelectedId = (id) => { selectedId = id; syncSelectionClasses(); };
window.__BB.clearSelection = () => { selected.clear(); selectedId = null; syncSelectionClasses(); };
  window.__BB.syncSelectionClasses = () => syncSelectionClasses();
  window.__BB.worldFromClient = (x,y) => worldFromClient(x,y);
  window.__BB.startFolderDrag = (gid, cx, cy) => startFolderDrag(gid, cx, cy);
  window.__BB.getGroupAtWorldPoint = (wx, wy) => getGroupAtWorldPoint(wx, wy);
  window.__BB.getSuppressNextClick = () => suppressNextClick;
  window.__BB.setSuppressNextClick = (v) => { suppressNextClick = !!v; };

  function selectCard(id, additive=false){
    if(!id){
      selected.clear();
      selectedId = null;
      syncSelectionClasses();
      return;
    }

    if(additive){
      if(selected.has(id)){
        // toggle off
        selected.delete(id);
        if(selectedId === id){
          // pick another selected card as primary, if any
          selectedId = selected.size ? Array.from(selected).at(-1) : null;
        }
      } else {
        // toggle on
        selected.add(id);
        selectedId = id;
      }
    } else {
      // select only this id
      selected.clear();
      selected.add(id);
      selectedId = id;
    }

    syncSelectionClasses();
  }

  function cardBgStyle(c){
    const bg = c.customColor ? c.customColor : null;
    return bg;
  }
  function getCardById(id){ return cards.find(c => c.id === id) || null; }

  function getGroupMembersById(groupId){
    if(!groupId) return [];
    return cards.filter(c => c.groupId === groupId);
  }

  function dissolveGroupIfTiny(groupId){
    if(!groupId) return;
    const mem = getGroupMembersById(groupId);
    if(mem.length <= 1){
      for(const c of mem) c.groupId = null;
    }
  }

  function mergeGroups(gA, gB){
    if(!gA || !gB || gA === gB) return gA || gB;
    for(const c of cards){
      if(c.groupId === gB) c.groupId = gA;
    }
    dissolveGroupIfTiny(gB);
    return gA;
  }

  function placeGroupedCardAdjacent(anchorId, movedId){
    const anchor = getCardById(anchorId);
    const moved = getCardById(movedId);
    if(!anchor || !moved) return;
    const { w: cardW, h: cardH } = getCardDims();

    const gapX = snapToGrid(cardW + 24);
    const gapY = snapToGrid(cardH + 24);

    const ignore = new Set([moved.id]);

    function overlapsAny(x, y){
      for(const c of cards){
        if(!c || ignore.has(c.id)) continue;
        if(x < c.x + cardW && x + cardW > c.x && y < c.y + cardH && y + cardH > c.y) return true;
      }
      return false;
    }

    // Prefer placing the moved card to the RIGHT of the anchor (matches iOS "folder" feel),
    // then fall back to other adjacent slots.
    const cand = [
      {x: anchor.x + gapX, y: anchor.y},
      {x: anchor.x, y: anchor.y + gapY},
      {x: anchor.x - gapX, y: anchor.y},
      {x: anchor.x, y: anchor.y - gapY},
      {x: anchor.x + gapX, y: anchor.y + gapY},
      {x: anchor.x - gapX, y: anchor.y + gapY},
      {x: anchor.x + gapX, y: anchor.y - gapY},
      {x: anchor.x - gapX, y: anchor.y - gapY},
    ];

    for(const p of cand){
      const x = snapToGrid(p.x);
      const y = snapToGrid(p.y);
      if(!overlapsAny(x, y)){
        moved.x = x;
        moved.y = y;
        return;
      }
    }

    // Worst case: nudge right until we find an opening.
    let x = snapToGrid(anchor.x + gapX);
    let y = snapToGrid(anchor.y);
    let tries = 0;
    while(overlapsAny(x, y) && tries < 40){
      x += GRID;
      tries++;
    }
    moved.x = x;
    moved.y = y;
  }

  
function groupCards(aId, bId){
  const a = getCardById(aId);
  const b = getCardById(bId);
  if(!a || !b) return null;

  const ga = a.groupId;
  const gb = b.groupId;

  if(ga && gb){
    if(ga !== gb) mergeGroups(ga, gb);
    return a.groupId || b.groupId;
  }

  const gid = ga || gb || uid();
  a.groupId = gid;
  b.groupId = gid;

  return gid;
}

// Lay out a temporary group into a neat, iOS-like cluster (no hierarchy).
// Anchor card stays put; other members pack to the right/down in a small grid.

function layoutGroup(gid, anchorId=null){
  if(!gid) return;
  const mem = getGroupMembersById(gid).filter(c => c && !c.locked);
  if(mem.length < 2) return;

  const gap = 24;

  // Pick anchor (kept visually stable)
  let anchor = anchorId ? getCardById(anchorId) : null;
  if(!anchor || anchor.groupId !== gid){
    anchor = mem.slice().sort((p,q)=> (p.x+p.y) - (q.x+q.y))[0];
  }
  if(!anchor) return;

  // Build items: anchor first, then rest in reading order (top-left first)
  const others = mem.filter(c => c.id !== anchor.id)
    .sort((p,q)=> (p.y-q.y) || (p.x-q.x));

  const items = [anchor, ...others].map(c=>{
    const d = getCardDimsFor(c);
    // Desired position (relative to anchor) so we keep layouts feeling "nearest / neatest"
    return { c, w: d.w, h: d.h, relx: (c.x - anchor.x), rely: (c.y - anchor.y) };
  });

  // Heuristic width target so we pack compactly (prevents drifting far right)
  const base = getCardDims(); // base sizing for "feel"
  const n = items.length;
  const targetCols = Math.min(3, Math.max(2, Math.ceil(Math.sqrt(n))));
  const widthsSorted = items.map(it=>it.w).sort((a,b)=>b-a);
  const targetW = Math.max(
    widthsSorted[0] || base.w,
    widthsSorted.slice(0, targetCols).reduce((s,v)=>s+v,0) + gap*(targetCols-1),
    base.w * targetCols + gap*(targetCols-1)
  );

  // Skyline-ish greedy packing:
  // For each item, try candidate top-left points derived from existing rects.
  const placed = [];
  const candidates = new Set();
  const key = (x,y)=> `${x}|${y}`;
  const addCand = (x,y)=>{
    x = Math.round(x);
    y = Math.round(y);
    candidates.add(key(x,y));
  };

  addCand(0,0);

  const overlaps = (x,y,w,h)=>{
    for(const r of placed){
      if(x < r.x + r.w + gap &&
         x + w + gap > r.x &&
         y < r.y + r.h + gap &&
         y + h + gap > r.y){
        return true;
      }
    }
    return false;
  };

  const placeItem = (it)=>{
    // sort candidates top-to-bottom, then left-to-right
    let candList = Array.from(candidates).map(s=>{
      const [xs,ys]=s.split("|");
      return {x: +xs, y:+ys};
    });

    // Add dynamic candidates around already-placed rects so we can pack left/up as well (not just top-left).
    for(const r of placed){
      candList.push({x: r.x + r.w + gap, y: r.y});                 // to the right
      candList.push({x: r.x,             y: r.y + r.h + gap});     // below
      candList.push({x: r.x - it.w - gap, y: r.y});                // to the left
      candList.push({x: r.x,              y: r.y - it.h - gap});   // above
      candList.push({x: r.x - it.w - gap, y: r.y - it.h - gap});   // above-left
      candList.push({x: r.x + r.w + gap,  y: r.y - it.h - gap});   // above-right
      candList.push({x: r.x - it.w - gap, y: r.y + r.h + gap});    // below-left
    }

    // Prefer trying near the card's existing position first
    candList.push({x: (it.relx||0), y: (it.rely||0)});

    // Dedupe + stable ordering
    const seen = new Set();
    candList = candList.map(p=>({x: Math.round(p.x), y: Math.round(p.y)}))
      .filter(p=>{
        const k = p.x+"|"+p.y;
        if(seen.has(k)) return false;
        seen.add(k);
        return true;
      })
      .sort((a,b)=> (a.y-b.y) || (a.x-b.x));

let best = null;
    let bestScore = Infinity;

    for(const p of candList){
      const x = p.x, y = p.y;
      if(overlaps(x,y,it.w,it.h)) continue;

      // Score: keep the card as close as possible to where it already was (relative to anchor),
      // while still biasing toward compactness and avoiding runaway width.
      const overflow = Math.max(0, (x + it.w) - targetW);
      const dx0 = (x - (it.relx || 0));
      const dy0 = (y - (it.rely || 0));
      const dist2 = dx0*dx0 + dy0*dy0;

      // Small secondary biases (very small so distance dominates)
      const compactBias = (y*0.001) + (x*0.0005);
      const overflowBias = overflow*overflow*0.25;

      const score = dist2 + overflowBias + compactBias;

      if(score < bestScore){
        bestScore = score;
        best = {x,y};
        // Early exit if it's perfectly within target width and very top-left-ish
        if(overflow === 0 && y === 0) break;
      }
    }

    if(!best){
      // Fallback: push down below current packed height
      const maxY = placed.reduce((m,r)=>Math.max(m, r.y + r.h), 0);
      best = { x: 0, y: maxY + gap };
    }

    const rect = { x: best.x, y: best.y, w: it.w, h: it.h, id: it.c.id };
    placed.push(rect);

    // Add new candidate points on right and bottom edges
    addCand(rect.x + rect.w + gap, rect.y);
    addCand(rect.x, rect.y + rect.h + gap);

    // Also add a "next row" candidate aligned under the current rect start
    addCand(0, rect.y + rect.h + gap);

    return rect;
  };

  // Place items (anchor first at 0,0)
  const anchorRect = placeItem(items[0]);
  for(let i=1;i<items.length;i++){
    placeItem(items[i]);
  }

  // Translate so anchor stays at its current world position
  const dx = anchor.x - anchorRect.x;
  const dy = anchor.y - anchorRect.y;

  for(const r of placed){
    const card = getCardById(r.id);
    if(!card) continue;
    card.x = Math.round(dx + r.x);
    card.y = Math.round(dy + r.y);
  }

  // Keep folder halo/frame in sync (lightweight update)
  try{
    if(typeof updateGroupHalo === "function") updateGroupHalo(gid);
  }catch(_){}
}


function pointInRect(px, py, r){
  return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
}

function getGroupBounds(gid, excludeId=null){
  const mem = getGroupMembersById(gid).filter(c => c && c.id !== excludeId);
  if(mem.length === 0) return null;
  const { w: cardW, h: cardH } = getCardDims();
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const c of mem){
    minX = Math.min(minX, c.x);
    minY = Math.min(minY, c.y);
    const d = getCardDimsFor(c);
        maxX = Math.max(maxX, c.x + d.w);
        maxY = Math.max(maxY, c.y + d.h);
  }
  const pad = 70;
  return { x:minX-pad, y:minY-pad, w:(maxX-minX)+pad*2, h:(maxY-minY)+pad*2, count: mem.length };
}


// Live-update folder halo when member cards move/resize without full re-render (perf).
const __pendingGroupDomUpdates = new Set();
let __groupDomRaf = null;

function getGroupVisualBounds(gid){
  const mem = getGroupMembersById(gid).filter(c => c);
  if(mem.length === 0) return null;
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const c of mem){
    minX = Math.min(minX, c.x);
    minY = Math.min(minY, c.y);
    const d = getCardDimsFor(c);
    maxX = Math.max(maxX, c.x + d.w);
    maxY = Math.max(maxY, c.y + d.h);
  }
  const pad = 28; // match render() folder halo padding
  return {
    left: minX - pad,
    top:  minY - pad,
    width:  (maxX - minX) + pad*2,
    height: (maxY - minY) + pad*2,
    labelLeft: (minX - pad) + 12,
    labelTop:  (minY - pad) - 6
  };
}

function updateGroupDomNow(gid){
  const b = getGroupVisualBounds(gid);
  if(!b) return;

  const halo = board.querySelector(`.groupHalo[data-gid="${cssEscapeId(gid)}"]`);
  if(halo){
    halo.style.left = `${b.left}px`;
    halo.style.top  = `${b.top}px`;
    halo.style.width  = `${b.width}px`;
    halo.style.height = `${b.height}px`;
  }

  const lab = board.querySelector(`.groupLabel[data-gid="${cssEscapeId(gid)}"]`);
  if(lab){
    lab.style.left = `${b.labelLeft}px`;
    lab.style.top  = `${b.labelTop}px`;
  }

  // If a groupFrame exists (clickable drag frame), keep it in sync too.
  const frame = board.querySelector(`.groupFrame[data-gid="${cssEscapeId(gid)}"]`);
  if(frame){
    frame.style.left = `${b.left}px`;
    frame.style.top  = `${b.top}px`;
    frame.style.width  = `${b.width}px`;
    frame.style.height = `${b.height}px`;
    // Also update its parts if present (they're absolute inside the frame)
    try{
      const parts = frame.querySelectorAll('.groupFramePart');
      if(parts && parts.length){
        const t = 24; // thickness used when building the frame
        parts.forEach(p=>{
          const side = p.dataset.side;
          if(side === "top"){ p.style.left="0px"; p.style.top="0px"; p.style.width="100%"; p.style.height=`${t}px`; }
          if(side === "bottom"){ p.style.left="0px"; p.style.bottom="0px"; p.style.width="100%"; p.style.height=`${t}px`; }
          if(side === "left"){ p.style.left="0px"; p.style.top="0px"; p.style.width=`${t}px`; p.style.height="100%"; }
          if(side === "right"){ p.style.right="0px"; p.style.top="0px"; p.style.width=`${t}px`; p.style.height="100%"; }
        });
      }
    }catch(_){}
  }
}

function scheduleGroupDomUpdate(gid){
  if(!gid) return;
  __pendingGroupDomUpdates.add(gid);
  if(__groupDomRaf) return;
  __groupDomRaf = requestAnimationFrame(()=>{
    __groupDomRaf = null;
    const ids = Array.from(__pendingGroupDomUpdates);
    __pendingGroupDomUpdates.clear();
    ids.forEach(updateGroupDomNow);
  });
}


// Start dragging a whole folder/group from a background/halo grab.
function startFolderDrag(gid, clientX, clientY){
  const members = getGroupMembersById(gid).filter(cc => cc && !cc.locked);
  if(members.length < 2) return false;

  // Select group members (temporary)
  selected = new Set(members.map(cc => cc.id));
  selectedId = members[0].id;
  syncSelectionClasses();

  const p = worldFromClient(clientX, clientY);
  drag.active = true;
  drag.pushed = false;
  drag.originGroupId = null; // dragging the folder itself
  drag.ids = Array.from(selected);
  drag.start = { x: p.x, y: p.y };
  drag.starts = new Map(drag.ids.map(id => {
    const cc = cards.find(x => x.id === id);
    return [id, { x: cc ? cc.x : 0, y: cc ? cc.y : 0 }];
  }));

  // Reset any grouping hover state for this drag
  groupTargetId = null;
  if(groupTargetTimer){ clearTimeout(groupTargetTimer); groupTargetTimer = null; }
  groupHoverCandidate = null;
  return true;
}

// Hit-test a folder/group by world point (lets you drag a folder by empty space inside it).
function getGroupAtWorldPoint(wx, wy){
  const gids = Array.from(new Set(cards.filter(c=>c.groupId).map(c=>c.groupId)));
  // Hit-test should match what you *see* as the folder halo, which is more generous than the tight bounds.
  // We inflate bounds here so the translucent halo area is draggable even if you're not right next to a card.
  const INFLATE = 240; // px in world space
  for(const gid of gids){
    const b0 = getGroupBounds(gid, null);
    if(!b0 || b0.count < 1) continue;
    const b = { x: b0.x - INFLATE, y: b0.y - INFLATE, w: b0.w + INFLATE*2, h: b0.h + INFLATE*2 };
    if(pointInRect(wx, wy, b)) return gid;
  }
  return null;
}

// Tighter bounds for "drag out to remove" checks (less forgiving so it feels responsive).
function getGroupBoundsTight(gid, excludeId=null, pad=10){
  const mem = getGroupMembersById(gid).filter(c => c && c.id !== excludeId);
  if(mem.length === 0) return null;
  const { w: cardW, h: cardH } = getCardDims();
  let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
  for(const c of mem){
    minX = Math.min(minX, c.x);
    minY = Math.min(minY, c.y);
    const d = getCardDimsFor(c);
    maxX = Math.max(maxX, c.x + d.w);
    maxY = Math.max(maxY, c.y + d.h);
  }
  return { x:minX-pad, y:minY-pad, w:(maxX-minX)+pad*2, h:(maxY-minY)+pad*2, count: mem.length };
}


  function ungroupIds(ids){
    const set = new Set(ids);
    const touchedGroups = new Set();

    for(const c of cards){
      if(set.has(c.id) && c.groupId){
        touchedGroups.add(c.groupId);
        c.groupId = null; // keep card position where it is
      }
    }

    // Tidy up & repack any remaining members so the halo stays tight.
    for(const g of touchedGroups){
      dissolveGroupIfTiny(g);
      }
  }


  function render(){
    board.innerHTML = "";
    try{ __cardElCache.clear(); }catch(_){ __cardElCache = new Map(); }

    // Draw lightweight halos behind temporary groups
    const { w: cardW, h: cardH } = getCardDims();
    const groups = new Map();
    for(const c of cards){
      if(c.groupId){
        if(!groups.has(c.groupId)) groups.set(c.groupId, []);
        groups.get(c.groupId).push(c);
      }
    }
    for(const [gid, mem] of groups.entries()){
      if(mem.length < 2) continue;
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for(const c of mem){
        minX = Math.min(minX, c.x);
        minY = Math.min(minY, c.y);
        const d = getCardDimsFor(c);
        maxX = Math.max(maxX, c.x + d.w);
        maxY = Math.max(maxY, c.y + d.h);
      }
      const pad = 28;
      const halo = document.createElement("div");
      halo.className = "groupHalo";
      halo.dataset.gid = gid;
      // Apply per-folder appearance
      const gs = getGroupStyle(gid);
      halo.style.background = rgbaFromHex(gs.color, gs.opacity);
      halo.style.borderColor = rgbaFromHex(gs.color, Math.max(0.18, Math.min(0.55, gs.opacity + 0.18)));
      halo.style.boxShadow = `inset 0 0 0 1px ${rgbaFromHex("#000000",0.14)}`;

      halo.addEventListener("mousedown",(e)=>{
        if(e.button!==0) return;
        e.stopPropagation();
        e.preventDefault();
        hideCtx();
        hideColorPopover();
        activeFolderId = gid;
        activeFolderId = gid;
          startFolderDrag(gid, e.clientX, e.clientY);
      });
      // Double-click the folder halo to open Folder settings
      halo.addEventListener("dblclick",(e)=>{
        try{
          e.preventDefault();
          e.stopPropagation();
          hideCtx();
          hideColorPopover();
          activeFolderId = gid;
          openFolderOverlay(gid);
        }catch(_){ }
      });
      halo.style.left = `${minX - pad}px`;
      halo.style.top  = `${minY - pad}px`;
      halo.style.width  = `${(maxX - minX) + pad*2}px`;
      halo.style.height = `${(maxY - minY) + pad*2}px`;

      // Optional folder label
      try{
        const gs2 = getGroupStyle(gid);
        if(gs2 && gs2.showName && (gs2.name||"").trim().length){
          const lab = document.createElement("div");
          lab.className = "groupLabel";
          lab.dataset.gid = gid;
          lab.textContent = gs2.name.trim();
          lab.style.left = `${(minX - pad) + 12}px`;
          lab.style.top  = `${(minY - pad) - 6}px`;
          // tint label border slightly to match
          lab.style.borderColor = rgbaFromHex(gs2.color, 0.28);
          board.appendChild(lab);
        }
      }catch(_){ }
      // Make halo purely visual (cards remain fully interactive inside)
      halo.style.pointerEvents = "auto";

      // Clickable frame around folder edges (so you can drag the folder without blocking cards)
      
      // Clickable frame parts around folder edges (siblings, so pointer-events always work)
      const t = 38; // grab thickness (px)

      function mkPart(cls, x, y, w, h){
        const part = document.createElement("div");
        part.className = `groupFramePart ${cls}`;
        part.dataset.gid = gid;
        part.style.left = `${x}px`;
        part.style.top = `${y}px`;
        part.style.width = `${w}px`;
        part.style.height = `${h}px`;
        part.style.zIndex = "10";
        part.addEventListener("mousedown",(e)=>{
          if(e.button!==0) return;
          // Only start folder drag if the click isn't on a card (cards should win).
          if(e.target && e.target.closest && e.target.closest(".card")) return;
          e.stopPropagation();
          e.preventDefault();
          hideCtx();
          hideColorPopover();
          activeFolderId = gid;
          startFolderDrag(gid, e.clientX, e.clientY);
        });

        // Double-click any folder border segment to open folder settings
        part.addEventListener("dblclick",(e)=>{
          try{
            if(e.target && e.target.closest && e.target.closest(".card")) return;
            e.preventDefault();
            e.stopPropagation();
            hideCtx();
            hideColorPopover();
            activeFolderId = gid;
            openFolderOverlay(gid);
          }catch(_){ }
        });

        board.appendChild(part);
      }

      const fx = (minX - pad);
      const fy = (minY - pad);
      const fw = (maxX - minX) + pad*2;
      const fh = (maxY - minY) + pad*2;

      // Top, bottom, left, right rings (interior remains clickable for cards)
      mkPart("top",    fx, fy, fw, t);
      mkPart("bottom", fx, fy + fh - t, fw, t);
      mkPart("left",   fx, fy, t, fh);
      mkPart("right",  fx + fw - t, fy, t, fh);

      board.appendChild(halo);

    }

    for(const c of cards){
      const el = document.createElement("div");

      const preset = c.preset || "neutral";
      const isCustom = !!c.customColor;

      el.className = `card ${!isCustom ? preset : "neutral"}${c.noHeader ? " noHeader" : ""}${c.locked ? " locked" : ""}${c.struck ? " struck" : ""}`;
      el.style.left = `${c.x}px`;
      el.style.top = `${c.y}px`;
      el.dataset.id = c.id;
      try{ __cardElCache.set(String(c.id), el); }catch(_){ }
      if(groupTargetId && c.id === groupTargetId) el.classList.add("groupTarget");
      // Find highlight
      if(findMatches && findMatches.has(c.id)) el.classList.add("findMatch");

      el.classList.toggle("locked", !!c.locked);
      el.classList.toggle("struck", !!c.struck);

      const customBg = cardBgStyle(c);
      if(customBg) el.style.background = customBg;
      else el.style.background = "";      // Sizing
      // Text cards follow the global CSS vars (--cardW/--cardH).
      // Image cards keep their own independent size.
      if(c.type === "image"){
        const { w: defaultW, h: defaultH } = getCardDims();
        const cw = (c.w != null ? c.w : defaultW);
        const ch = (c.h != null ? c.h : defaultH);
        el.style.width  = `${cw}px`;
        el.style.height = `${ch}px`;

        // Size-aware padding so shrinking an image card doesn't leave a huge "frame".
        // 3% of the smaller dimension, clamped to 2..14px.
        const pad = Math.max(2, Math.min(14, Math.round(Math.min(cw, ch) * 0.03)));
        el.style.setProperty("--imgPad", `${pad}px`);
      }else{
        // Text cards normally follow global CSS vars (--cardW/--cardH),
        // but if the user resized a specific card, respect its per-card w/h.
        if(c.w != null || c.h != null){
          const { w: defaultW, h: defaultH } = getCardDims();
          const cw = (c.w != null ? c.w : defaultW);
          const ch = (c.h != null ? c.h : defaultH);
          el.style.width  = `${cw}px`;
          el.style.height = `${ch}px`;
        }else{
          el.style.width = "";
          el.style.height = "";
        }
        el.style.removeProperty("--imgPad");
      }
// Content
      if(c.type === "image"){
        el.classList.add("imageCard");
        // Build DOM safely to avoid huge data URLs inside innerHTML strings.
        const body = document.createElement("div");
        body.className = "body";
        const img = document.createElement("img");
        img.draggable = false;
        img.alt = c.imgName || c.title || "Image";
        // Hint the browser to decode async to reduce main-thread jank
        img.loading = "lazy";
        img.decoding = "async";
        const src = getImageDataUrl(c.imgId) || c.img || null;
        if(src) img.src = src;

        const cap = document.createElement("div");
        cap.className = "imgCaption";
        cap.textContent = c.imgName || c.title || "Image";

        body.appendChild(img);
        body.appendChild(cap);
        el.appendChild(body);
      }else{
        el.innerHTML = `${c.noHeader ? "" : `<div class="title">${escapeHtml(c.title || "BEAT")}</div>`}
          <div class="body">${sanitizeHtml(c.body || "")}</div>
        `;

      }


      // Resize handle (bottom-right). Visible when selected.
      const rh = document.createElement("div");
      rh.className = "resizeHandle";
      rh.title = c.locked ? "Locked" : "Drag to resize";
      rh.addEventListener("pointerdown", (ev)=>{
        if(c.locked) return;
        // Prevent card drag from starting.
        ev.stopPropagation();
        ev.preventDefault();
        hideCtx();
        hideColorPopover();
        // Preserve existing multi-selection: only select this card if it isn't already selected.
        if(!selected.has(c.id)) selectCard(c.id, false);
        startResize(c.id, ev);
      });
      el.appendChild(rh);

      // Selecting + dragging
      el.addEventListener("mousedown", (e) => {
        if(e.button !== 0) return;
        e.stopPropagation();
        hideCtx();
        hideColorPopover();

        const additive = (e.metaKey || e.ctrlKey);

        // Cmd/Ctrl-click toggles selection membership.
        // Plain click on an already-selected card keeps the current multi-selection (just updates primary).
        if(additive){
          selectCard(c.id, true);
        } else if(!selected.has(c.id)){
          selectCard(c.id, false);
        } else {
          selectedId = c.id;
          syncSelectionClasses();
        }


        // Locked cards: selectable + editable, but cannot be dragged.
        if(c.locked){
          drag.active = false;
          return;
        }

        const p = worldFromClient(e.clientX, e.clientY);

        // Start multi-drag for all selected cards
        if(c.locked){
          // allow selection but do not start a drag
          return;
        }

        // Folder drag is handled ONLY via the folder halo/handle.
        drag.pendingGroupDrag = null;

        drag.active = true;
        drag.pushed = false;
        drag.ids = Array.from(selected).filter(id => {
          const cc = cards.find(x => x.id === id);
          return cc && !cc.locked;
        });
        drag.start = { x: p.x, y: p.y };
        drag.starts = new Map(drag.ids.map(id => {
          const cc = cards.find(x => x.id === id);
          return [id, { x: cc ? cc.x : 0, y: cc ? cc.y : 0 }];
        }));
        drag.originGroupId = c.groupId || null;
        // Reset any grouping hover state for this drag
        groupTargetId = null;
        if(groupTargetTimer){ clearTimeout(groupTargetTimer); groupTargetTimer = null; }
        groupHoverCandidate = null;

        // Keep legacy offsets for single-card behavior (optional)
        drag.offsetX = p.x - c.x;
        drag.offsetY = p.y - c.y;
      });

      // Double click to edit (writing focused)
      el.addEventListener("dblclick", (e) => {
        e.stopPropagation();
        hideColorPopover();
        hideCtx();

        // Shift + double-click: snap-arrange the current multi-selection near where it already sits.
        if(selected.size > 1 && selected.has(c.id)){
          arrangeSelectedSnap(24);
          return;
        }

        openEditor(c.id);
      });

      // Right click (context menu)
      el.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        e.stopPropagation();
        // If you right-click a card that is already part of the current multi-selection,
        // keep the selection (donâ€™t collapse to a single card).
        if(!(selected && selected.has && selected.has(c.id)) || (selected && selected.size===0)){
          selectCard(c.id);
        } else {
          selectedId = c.id;
        }
        openCtx(e.clientX, e.clientY, c.id);
      });

      board.appendChild(el);
    }

    syncSelectionClasses();
    applyView();
    updateGridClass();
  }

  function unifyCardHeights(){ /* disabled: caused global resizing */ }

  function escapeHtml(str){
    return String(str)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function createCardAt(x, y, opts = {}){
    pushHistory();
    const n = cards.length + 1;

    const blank = !!opts.blank;
    const noHeader = !!opts.noHeader || blank;

    cards.push({
      id: uid(),
      x: Math.round(x),
      y: Math.round(y),
      preset: "neutral",
      customColor: null,
      noHeader,
      locked: false,
      struck: false,
      groupId: null,
      title: blank ? "" : `${n}. BEAT`,
      body: ""
    });

    save();
    render();
    selectCard(cards[cards.length - 1].id);
  }


  function duplicateSelected(){
    if(selected.size === 0) return;
    pushHistory();

    // Duplicate every selected card, keeping relative positions.
    const selCards = cards.filter(c => selected.has(c.id));
    if(selCards.length === 0) return;

    const offset = 30;
    const newIds = [];
    for(const src of selCards){
      const copy = structuredClone(src);
      copy.id = uid();
      copy.x = src.x + offset;
      copy.y = src.y + offset;
      cards.push(copy);
      newIds.push(copy.id);
    }

    selected = new Set(newIds);
    selectedId = newIds[newIds.length-1] || null;

    save();
    render();
  }

  function duplicateCard(id){
    pushHistory();
    const src = cards.find(c => c.id === id);
    if(!src) return;
    cards.push({
      ...structuredClone(src),
      id: uid(),
      x: src.x + 30,
      y: src.y + 30
    });
    save();
    render();
  }

  function deleteCard(id){
    // single-delete helper (no history push here; call pushHistory() in the caller)
    cards = cards.filter(c => c.id !== id);
    selected.delete(id);
    if(selectedId === id) selectedId = null;
  }

  function deleteCardsByIds(ids){
    const set = new Set(ids);

    // If we're deleting image cards, also delete their stored image blobs.
    for(const c of cards){
      if(set.has(c.id) && c && c.type === "image" && c.imgId){
        deleteImageDataUrl(c.imgId);
      }
    }

    cards = cards.filter(c => !set.has(c.id));
    for(const id of set) selected.delete(id);
    if(selectedId && set.has(selectedId)) selectedId = null;
  }

  function deleteSelected(){
    if(selected.size === 0) return;
    pushHistory();
    deleteCardsByIds(Array.from(selected));
    // Clear selection after delete
    selected.clear();
    selectedId = null;
    save();
    render();
  }


  /* ---------- Arrange (Shift + Double-Click) ---------- */
  function getBaseCardDims(){
    const cs = getComputedStyle(document.documentElement);
    const w = parseInt(cs.getPropertyValue("--cardW")) || 335;
    const h = parseInt(cs.getPropertyValue("--cardH")) || 220;
    return { w, h };
  }

  function getCardDims(){
    // Layout dimensions used for snapping/arranging must always be at least as large as
    // the biggest (resized) normal card, otherwise smaller cards will overlap it.
    const { w: baseW, h: baseH } = getBaseCardDims();
    let w = baseW;
    let h = baseH;

    // Include ALL normal cards (including those inside folders). Image cards have independent sizing.
    for(const c of cards){
      if(!c) continue;
      if(c.type === "image") continue;
      if(c.w != null) w = Math.max(w, c.w);
      if(c.h != null) h = Math.max(h, c.h);
    }

    return { w, h };
  }

  // Per-card dimensions (all cards can have independent sizes)
  function getCardDimsFor(c){
    const { w: bw, h: bh } = getBaseCardDims();
    if(!c) return { w: bw, h: bh };
    // If the user resized this card, prefer its stored w/h.
    const cw = (c.w != null ? c.w : bw);
    const ch = (c.h != null ? c.h : bh);
    return { w: cw, h: ch };
  }

  // Snaps each selected card to the nearest tidy grid slot near where it already is.
  // This preserves the "shape" of the selection instead of re-ordering cards.
  function arrangeSelectedSnap(gap=24){
    if(selected.size < 2) return;

    const selCards = cards.filter(c => selected.has(c.id));
    if(selCards.length < 2) return;

    const unselected = cards.filter(c => !selected.has(c.id));

    // IMPORTANT:
    // Keep the "classic" gap feel by using BASE grid steps (not the largest resized card),
    // then expand only the columns/rows that actually contain larger cards.
    const { w: baseW, h: baseH } = getBaseCardDims();
    const stepX = baseW + gap;
    const stepY = baseH + gap;

    // Keep the snap grid aligned with nearby existing cards:
    // choose the most common (x mod stepX) and (y mod stepY) among UNSELECTED cards.
    function modNorm(v, m){
      const r = v % m;
      return r < 0 ? r + m : r;
    }
    function modeOffset(values, step){
      if(!values.length) return 0;
      const counts = new Map();
      for(const v of values){
        const off = Math.round(modNorm(v, step)); // tolerate small jitter
        counts.set(off, (counts.get(off) || 0) + 1);
      }
      let best = 0, bestCount = -1;
      for(const [off, cnt] of counts.entries()){
        if(cnt > bestCount || (cnt === bestCount && off < best)){
          best = off; bestCount = cnt;
        }
      }
      return best;
    }

    const sampleX = (unselected.length ? unselected : cards).map(c => c.x);
    const sampleY = (unselected.length ? unselected : cards).map(c => c.y);
    const gridX0 = modeOffset(sampleX, stepX);
    const gridY0 = modeOffset(sampleY, stepY);

    const colOf = (x) => Math.round((x - gridX0) / stepX);
    const rowOf = (y) => Math.round((y - gridY0) / stepY);
    const xOfBase = (col) => gridX0 + col * stepX;
    const yOfBase = (row) => gridY0 + row * stepY;
    const key = (c,r) => `${c},${r}`;

    // Overlap test vs unselected cards (axis-aligned rects) using REAL per-card sizes
    function overlapsUnselected(x, y, w, h){
      for(const o of unselected){
        const od = getCardDimsFor(o);
        if(x < o.x + od.w && x + w > o.x && y < o.y + od.h && y + h > o.y) return true;
      }
      return false;
    }

    // Compute desired cell for each selected card (nearest)
    const desired = selCards.map(c => {
      const col = colOf(c.x);
      const row = rowOf(c.y);
      const tx = xOfBase(col);
      const ty = yOfBase(row);
      const dist = Math.hypot(c.x - tx, c.y - ty);
      return { card:c, col, row, dist };
    });

    // Place most-confident first, to minimize movement
    desired.sort((a,b) => (a.dist - b.dist) || (a.card.y - b.card.y) || (a.card.x - b.card.x));

    const taken = new Set(); // cells taken by selected arrangement
    const assign = new Map(); // id -> {col,row}

    function nearestOpenCell(startCol, startRow, card){
      const MAX_R = 140;
      const cd = getCardDimsFor(card);

      for(let r=0; r<=MAX_R; r++){
        let best = null;
        for(let dc=-r; dc<=r; dc++){
          const dr1 = r - Math.abs(dc);
          for(const dr of [dr1, -dr1]){
            const col = startCol + dc;
            const row = startRow + dr;
            const k = key(col,row);
            if(taken.has(k)) continue;

            const tx = xOfBase(col);
            const ty = yOfBase(row);
            if(overlapsUnselected(tx, ty, cd.w, cd.h)) continue;

            const d = Math.hypot(card.x - tx, card.y - ty);
            if(best === null || d < best.d){
              best = { col, row, k, d };
            }
          }
        }
        if(best) return best;
      }

      // If space is packed, fall back to first untaken slot (even if overlapping)
      for(let r=0; r<=MAX_R; r++){
        for(let dc=-r; dc<=r; dc++){
          const dr1 = r - Math.abs(dc);
          for(const dr of [dr1, -dr1]){
            const col = startCol + dc;
            const row = startRow + dr;
            const k = key(col,row);
            if(taken.has(k)) continue;
            return { col, row, k, d:0 };
          }
        }
      }
      return { col:startCol, row:startRow, k:key(startCol,startRow), d:0 };
    }

    for(const d of desired){
      const spot = nearestOpenCell(d.col, d.row, d.card);
      taken.add(spot.k);
      assign.set(d.card.id, { col: spot.col, row: spot.row });
    }

    // Place cards using base grid targets, but only expand spacing locally
// to avoid overlaps caused by individually resized cards.
// This keeps the "classic" tight gaps while still being collision-safe.
const rowsMap = new Map(); // row -> [{card,col,row}]
const colsMap = new Map(); // col -> [{card,col,row}]
for(const c of selCards){
  const a = assign.get(c.id);
  if(!a) continue;
  if(!rowsMap.has(a.row)) rowsMap.set(a.row, []);
  if(!colsMap.has(a.col)) colsMap.set(a.col, []);
  rowsMap.get(a.row).push({ card:c, col:a.col, row:a.row });
  colsMap.get(a.col).push({ card:c, col:a.col, row:a.row });
}

// Start everyone at their base-grid position.
const pos = new Map(); // id -> {x,y,w,h,col,row}
for(const c of selCards){
  const a = assign.get(c.id);
  if(!a) continue;
  const d = getCardDimsFor(c);
  pos.set(c.id, {
    x: xOfBase(a.col),
    y: yOfBase(a.row),
    w: d.w,
    h: d.h,
    col: a.col,
    row: a.row
  });
}

// Resolve horizontal spacing row-by-row (tight packing with constant gap).
// IMPORTANT: don't preserve empty grid columns (that creates huge gaps on the right).
// Anchor each row near its left-most base slot, then pack cards left-to-right by col.
for(const [row, items] of rowsMap.entries()){
  items.sort((A,B)=> (A.col - B.col) || (pos.get(A.card.id).x - pos.get(B.card.id).x));

  let startX = Infinity;
  for(const it of items){
    startX = Math.min(startX, xOfBase(it.col));
  }
  if(!Number.isFinite(startX)) startX = xOfBase(items[0].col);

  let cursorX = startX;
  for(const it of items){
    const p = pos.get(it.card.id);
    if(!p) continue;
    p.x = cursorX;
    cursorX = p.x + p.w + gap;
  }
}

// Resolve vertical spacing col-by-col (tight packing with constant gap).
// IMPORTANT: don't preserve empty grid rows; anchor near the top-most base slot then pack downward.
for(const [col, items] of colsMap.entries()){
  items.sort((A,B)=> (A.row - B.row) || (pos.get(A.card.id).y - pos.get(B.card.id).y));

  let startY = Infinity;
  for(const it of items){
    startY = Math.min(startY, yOfBase(it.row));
  }
  if(!Number.isFinite(startY)) startY = yOfBase(items[0].row);

  let cursorY = startY;
  for(const it of items){
    const p = pos.get(it.card.id);
    if(!p) continue;
    p.y = cursorY;
    cursorY = p.y + p.h + gap;
  }
}

// Final safety: if any selected cards still overlap each other, push them down minimally.
// (This can happen when a very large card spans into the next row/col visually.)
const arranged = selCards.map(c => ({ c, p: pos.get(c.id) })).filter(x => x.p);
arranged.sort((a,b)=> (a.p.y - b.p.y) || (a.p.x - b.p.x));
for(let i=0;i<arranged.length;i++){
  for(let j=0;j<i;j++){
    const A = arranged[j].p;
    const B = arranged[i].p;
    if(!A || !B) continue;
    const overlapX = (B.x < A.x + A.w) && (B.x + B.w > A.x);
    const overlapY = (B.y < A.y + A.h) && (B.y + B.h > A.y);
    if(overlapX && overlapY){
      // push B down just past A
      B.y = (A.y + A.h + gap);
    }
  }
}

pushHistory();
for(const c of selCards){
  const p = pos.get(c.id);
  if(!p) continue;
  c.x = Math.round(p.x);
  c.y = Math.round(p.y);
}

    save();
    render();
    syncSelectionClasses();
  }



  function setCardCustomColor(id, hex){
    const c = cards.find(x => x.id === id);
    if(!c) return;
    c.preset = "neutral";      // label stays NOTE (no CUSTOM)
    c.customColor = hex;
    save();
    render();
  }

  
  // (Color popover removed in v3.8.3)
  function hideColorPopover(){ /* no-op */ }  function openColorPopover(){ /* no-op */ }


/* ---------- Editor ---------- */

  // Palette used in editor colour menu (tones only, no act assumptions)
  const EDIT_PALETTE = [
    // Bright / light
    "#ffe699","#ffd966","#f1e7c7","#dbe7f2","#d7f2ec","#f2d7d5",
    "#c6e0b4","#bdd7ee","#f8cbad","#d98fb7","#b8a1d9","#a9d18e",

    // Mid tones
    "#9dc3e6","#8ec7be","#9bbf7e","#7ea7c7","#f4b183","#d9c48c",
    "#c98983","#8f99a7","#c9c9c9",

    // Dark / muted
    "#5f6b7a","#3f4955","#20262e"
  ];

  /* --- Recent colours (editor colour menu) --- */
  const RECENT_COLORS_KEY = "beatboard.recentColors.v1";
  const RECENT_COLORS_MAX = 12;

  function _loadRecentColors(){
    try{
      const raw = localStorage.getItem(RECENT_COLORS_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr.filter(Boolean) : [];
    }catch(e){
      return [];
    }
  }

  function _saveRecentColors(arr){
    try{ localStorage.setItem(RECENT_COLORS_KEY, JSON.stringify(arr)); }catch(e){}
  }

  function pushRecentColor(hex){
    if(!hex) return;
    const h = String(hex).trim().toLowerCase();
    if(!h) return;
    let arr = _loadRecentColors().map(x => String(x).trim().toLowerCase()).filter(Boolean);
    arr = arr.filter(x => x !== h);
    arr.unshift(h);
    if(arr.length > RECENT_COLORS_MAX) arr = arr.slice(0, RECENT_COLORS_MAX);
    _saveRecentColors(arr);
    try{ if(tabsColorOverlay && tabsColorOverlay.style.display !== "none"){ renderTabsRecentColors((tabsHexInput && tabsHexInput.value) ? tabsHexInput.value : (tabsColorInput ? tabsColorInput.value : null)); } }catch(e){}
  }

  function renderRecentColors(activeHex){
    const wrap = document.getElementById("editRecentWrap");
    const row = document.getElementById("editRecentRow");
    if(!wrap || !row) return;

    const arr = _loadRecentColors();
    if(!arr.length){
      wrap.style.display = "none";
      row.innerHTML = "";
      return;
    }

    wrap.style.display = "block";
    row.innerHTML = "";
    arr.forEach(hex => {
      const d = document.createElement("div");
      d.className = "editSwatch";
      d.style.background = hex;
      d.dataset.hex = hex;
      d.title = hex;
      d.addEventListener("click", (e) => {
        e.preventDefault();
        setEditorColorUI(hex);
      });
      row.appendChild(d);
    });

    // active highlight will be handled by setEditorColorUI
    if(activeHex) setEditorColorUI(activeHex);
  }

  
  function renderTabsRecentColors(activeHex){
    const wrap = document.getElementById("tabsRecentWrap");
    const row  = document.getElementById("tabsRecentRow");
    if(!wrap || !row) return;

    const arr = _loadRecentColors().slice(0,6);
    if(!arr.length){
      wrap.style.display = "none";
      row.innerHTML = "";
      return;
    }

    wrap.style.display = "block";
    row.innerHTML = "";
    arr.forEach(hex => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "tabsSwatchBtn";
      btn.dataset.hex = hex;
      btn.title = hex;

      const sw = document.createElement("span");
      sw.className = "tabsSwatch";
      sw.style.background = hex;

      btn.appendChild(sw);
      btn.classList.toggle("active", (activeHex || "").toLowerCase() === String(hex).toLowerCase());

      btn.addEventListener("click", (e)=>{
        e.preventDefault();
        applyColorToSelected({ custom: hex }, { push: true });
        pushRecentColor(hex);
        closeTabsColorOverlay();
      });

      row.appendChild(btn);
    });
  }

function setEditorColorUI(hex){
    const value = (hex || "#c9c9c9").toLowerCase();
    editColorDot.style.background = value;
    editColorInput.value = value;
    if(editColorBar){
      editColorBar.style.background = value;
    }
    // highlight swatches
    [...editColorSwatches.querySelectorAll(".editSwatch")].forEach(el => {
      el.classList.toggle("active", (el.dataset.hex || "").toLowerCase() === value);
    });
  }

  function buildEditorSwatches(activeHex){
    editColorSwatches.innerHTML = "";
    EDIT_PALETTE.forEach(hex => {
      const s = document.createElement("div");
      s.className = "editSwatch";
      s.style.background = hex;
      s.dataset.hex = hex;
      s.title = hex;
      s.addEventListener("click", (e) => {
        e.preventDefault();
        setEditorColorUI(hex);
      });
      editColorSwatches.appendChild(s);
    });
    setEditorColorUI(activeHex);
  }

  function openEditorColorMenu(){
    renderRecentColors(editColorInput?.value || "#c9c9c9");
    editColorMenu.style.display = "block";
    editColorMenu.setAttribute("aria-hidden","false");
  }
  function closeEditorColorMenu(){
    editColorMenu.style.display = "none";
    editColorMenu.setAttribute("aria-hidden","true");
  }

  function openEditor(cardId){
    editingCardId = cardId;
    const c = cards.find(x => x.id === cardId);
    if(!c) return;

    modalTitle.textContent = "Edit";
    editTitle.value = c.title || "";
    // Headerless cards: hide title field (body-only)
    if(c.noHeader){
      editTitle.style.display = "none";
    } else {
      editTitle.style.display = "";
    }
    // Load body as rich HTML (backwards compatible with plain text)
    const raw = (c.body || "");
    const looksHtml = /<\w+[^>]*>|<br\s*\/?\s*>/i.test(raw);
    editBody.innerHTML = sanitizeHtml(looksHtml ? raw : plainToHtml(raw));
    try{ _syncEditBodyEmptyState(); }catch(e){}
// Init colour UI for this card (freeform)
    buildEditorSwatches(c.customColor || "#c9c9c9");
    setEditorColorUI(c.customColor || "#c9c9c9");

    // Wire editor colour menu interactions
    editColorBtn.onclick = (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      const isOpen = editColorMenu.style.display === "block";
      if(isOpen) closeEditorColorMenu();
      else openEditorColorMenu();
    };
    editColorInput.oninput = () => setEditorColorUI(editColorInput.value);

    editColorClear.onclick = (ev) => {
      ev.preventDefault();
      setEditorColorUI("#c9c9c9");
    };

    // Click outside the menu (but inside modal) closes it
    const closeOnClick = (ev) => {
      const menu = editColorMenu;
      const btn = editColorBtn;
      if(!menu || !btn) return;
      const r = menu.getBoundingClientRect();
      const br = btn.getBoundingClientRect();
      const insideMenu = ev.clientX >= r.left && ev.clientX <= r.right && ev.clientY >= r.top && ev.clientY <= r.bottom;
      const insideBtn = ev.clientX >= br.left && ev.clientX <= br.right && ev.clientY >= br.top && ev.clientY <= br.bottom;
      if(!insideMenu && !insideBtn){
        closeEditorColorMenu();
      }
    };
    // attach temporary listener while modal open
    if(__editorCloseOnClick){ try{ modalOverlay.removeEventListener("mousedown", __editorCloseOnClick); }catch(_){ } }
    __editorCloseOnClick = closeOnClick;
    modalOverlay.addEventListener("mousedown", __editorCloseOnClick, { passive: true });

    modalOverlay.style.display = "flex";
    // Focus title for header cards, body for blank/headerless cards
    if(editTitle.style.display === "none") editBody.focus();
    else editTitle.focus();

    btnCloseModal.onclick = () => { applyEditor(); closeEditor(); };

    // Close only on a deliberate click on the backdrop.
    // Prevent accidental close while selecting/highlighting text inside the editor.
    modalOverlay.onclick = (e) => {
      if(e.target !== modalOverlay) return;

      try{
        const sel = window.getSelection && window.getSelection();
        if(sel && sel.rangeCount){
          const r = sel.getRangeAt(0);
          const insideEditor = (editBody && editBody.contains(r.commonAncestorContainer));
          const hasSelection = (sel.toString && sel.toString().length > 0);
          if(insideEditor && hasSelection){
            // User is selecting text; don't close.
            return;
          }
        }
      }catch(_){}

      applyEditor();
      closeEditor();
    };

    if(__editorKeyHandler){ try{ window.removeEventListener("keydown", __editorKeyHandler); }catch(_){ } }
    __editorKeyHandler = (e)=>{
      if(modalOverlay.style.display === "flex" && e.key === "Escape"){
        e.preventDefault();
        applyEditor();
        closeEditor();
      }
    };
    window.addEventListener("keydown", __editorKeyHandler);
  }

  function applyEditor(){
    pushHistory();
    const c = cards.find(x => x.id === editingCardId);
    if(!c) return;
    if(!c.noHeader){ c.title = editTitle.value || ""; } else { c.title = ""; }
    // Save rich body as sanitized HTML
    c.body = sanitizeHtml(editBody.innerHTML || "");
// Persist editor colour (freeform). Keep preset neutral to avoid act assumptions.
    c.preset = "neutral";
    c.customColor = (editColorInput?.value || "#c9c9c9");

    
    pushRecentColor(c.customColor);
save();
    render();
  }

  function closeEditor(){
    closeEditorColorMenu();
    if(editColorBar){ editColorBar.style.background = "#c9c9c9"; }
    modalOverlay.style.display = "none";
    editingCardId = null;
  }

  /* ---------- Context menu ---------- */
  function openCtx(clientX, clientY, cardId){
    // Hard-cancel any in-progress drag state so context actions don't "stick" to the cursor.
    try{
      drag.active = false;
      drag.ids = [];
      drag.start = null;
      drag.starts = null;
      drag.pendingGroupDrag = null;
      drag.originGroupId = null;
      drag.ofsX = 0; drag.ofsY = 0;
      suppressNextClick = true;
    }catch(_){}
    try{
      if(groupTargetTimer){ clearTimeout(groupTargetTimer); groupTargetTimer = null; }
      groupTargetId = null;
      groupHoverCandidate = null;
    }catch(_){}

    hideColorPopover();
    ctxTargetCardId = cardId || null;
    // If the visual selection (DOM) disagrees with our `selected` Set (can happen with context menu timing),
    // reconcile from DOM so context actions apply to the full current selection.
    try{
      // `.multiSelected` is the full selection set; `.selected` is just the primary.
      let domSel = Array.from(document.querySelectorAll(".card.multiSelected")).map(el=>el.dataset && el.dataset.id).filter(Boolean);
      if(domSel.length === 0){
        const primary = document.querySelector(".card.selected");
        if(primary && primary.dataset && primary.dataset.id) domSel = [primary.dataset.id];
      }
      if(domSel.length > 0){
        // If there are multiple visibly-selected cards, trust that.
        if(domSel.length > 1){
          selected = new Set(domSel);
          // Prefer the right-clicked card as primary if it's included.
          if(cardId && selected.has(cardId)) selectedId = cardId;
          else selectedId = domSel[domSel.length-1] || selectedId;
        } else if(domSel.length === 1 && selected.size === 0){
          selected.add(domSel[0]);
          selectedId = domSel[0];
        }
      }
    }catch(_){}

    // Snapshot selection at the moment the context menu opens.
    try{ ctxSelectionSnapshot = Array.from(selected); }catch(_){ ctxSelectionSnapshot = []; }

    // If right-clicking a card that's not selected, select it so actions (Ungroup, Delete, etc.) apply intuitively.
    if(cardId && !selected.has(cardId)){
      selected.clear();
      selected.add(cardId);
      // Note: render will happen after action; context menu visibility relies on `selected` immediately.
    }


    // position
    const pad = 10;
    ctxMenu.style.display = "block";
    const rect = ctxMenu.getBoundingClientRect();
    let x = clientX;
    let y = clientY;
    if(x + rect.width > window.innerWidth - pad) x = window.innerWidth - rect.width - pad;
    if(y + rect.height > window.innerHeight - pad) y = window.innerHeight - rect.height - pad;
    ctxMenu.style.left = `${x}px`;
    ctxMenu.style.top = `${y}px`;

    // Compute world point where menu opened (for New)
    ctxAtWorld = worldFromClient(clientX, clientY);
// Toggle items depending on target
    ctxDelete.style.display = ctxTargetCardId ? "" : "none";
    ctxDuplicate.style.display = ctxTargetCardId ? "" : "none";

    // Group/Ungroup visibility
    const selCount = selected.size;
    const targetGrouped = (()=> {
      if(!ctxTargetCardId) return false;
      const c = cards.find(x => x.id === ctxTargetCardId);
      return !!(c && c.groupId);
    })();
    if(ctxGroup) ctxGroup.style.display = (selCount >= 2) ? "" : "none";
    // Only show Ungroup when right-clicking a grouped card
    if(ctxUngroup) ctxUngroup.style.display = targetGrouped ? "" : "none";

    // Fix context-menu separators: only show dividers between visible items
    // (and never allow double separators when multiple sections are hidden)
    try{
      const kids = Array.from(ctxMenu.children);
      // First hide all separators
      kids.forEach(el => {
        if(el.classList && el.classList.contains("ctxSep")) el.style.display = "none";
      });
      const isVisibleItem = (el) => {
        if(!el || !el.classList) return false;
        if(!el.classList.contains("ctxItem")) return false;
        return el.style.display !== "none";
      };
      // Pass 1: show only separators that have a visible item before AND after
      for(let i=0;i<kids.length;i++){
        const el = kids[i];
        if(!(el.classList && el.classList.contains("ctxSep"))) continue;
        let prev = null;
        for(let j=i-1;j>=0;j--){
          if(kids[j].classList && kids[j].classList.contains("ctxSep")) continue;
          if(isVisibleItem(kids[j])) { prev = kids[j]; break; }
        }
        let next = null;
        for(let j=i+1;j<kids.length;j++){
          if(kids[j].classList && kids[j].classList.contains("ctxSep")) continue;
          if(isVisibleItem(kids[j])) { next = kids[j]; break; }
        }
        if(prev && next) el.style.display = "";
      }
      // Pass 2: collapse any adjacent visible separators (keep the first, hide the rest)
      let lastWasSep = false;
      for(let i=0;i<kids.length;i++){
        const el = kids[i];
        if(!el || !el.classList) continue;
        const isSep = el.classList.contains("ctxSep");
        const isShown = el.style.display !== "none";
        if(isSep && isShown){
          if(lastWasSep){
            el.style.display = "none";
          }else{
            lastWasSep = true;
          }
          continue;
        }
        if(isVisibleItem(el)){
          lastWasSep = false;
        }
      }
    }catch(_){}

  }

  function hideCtx(){
    ctxMenu.style.display = "none";
    ctxTargetCardId = null;
    ctxSelectionSnapshot = [];
  }
  // Close context menu when clicking anywhere outside it
  document.addEventListener("pointerdown", (e) => {
    if(!ctxMenu || ctxMenu.style.display === "none") return;
    const inside = e.target && e.target.closest && e.target.closest("#ctxMenu");
    if(!inside) hideCtx();
  });


  
// Helper: read current multi-selection from DOM.
// IMPORTANT: this board uses `.multiSelected` for the full selection set and `.selected`
// for the single "primary" card. Context actions should operate on the full set.
function getSelectedIdsFromDOM(){
  try{
    const els = Array.from(document.querySelectorAll('.card.multiSelected'));
    // Fallback: if only the primary is marked (shouldn't happen), include it.
    if(els.length === 0){
      const primary = document.querySelector('.card.selected');
      if(primary) els.push(primary);
    }
    return els
      .map(el => el && el.dataset ? el.dataset.id : null)
      .filter(Boolean);
  }catch(_){ return []; }
}

ctxNew.addEventListener("click", () => {
    createAtBestSpot({}, ctxAtWorld);
    hideCtx();
  });

  const ctxNewBlank = document.getElementById("ctxNewBlank");
  if(ctxNewBlank){
    ctxNewBlank.addEventListener("click", () => {
      createAtBestSpot({ blank: true }, ctxAtWorld);
      hideCtx();
    });
  }

  ctxDuplicate.addEventListener("click", () => {
    // Use the selection snapshot captured when the menu opened.
    const ids = (ctxSelectionSnapshot && ctxSelectionSnapshot.length) ? ctxSelectionSnapshot.slice() : Array.from(selected || []);
    if(ids.length > 1){
      selected = new Set(ids);
      // keep primary as the right-clicked card if present
      if(ctxTargetCardId && selected.has(ctxTargetCardId)) selectedId = ctxTargetCardId;
      else selectedId = ids[ids.length-1] || selectedId;
      duplicateSelected();
      hideCtx();
      return;
    }

    // Single-card fallback: duplicate the right-clicked card, or the current primary
    const one = (ctxTargetCardId || (ids[0] || selectedId));
    if(one){
      selected.clear();
      selected.add(one);
      selectedId = one;
      duplicateSelected();
    }
    hideCtx();
  });


  
  // --- Group into a folder (right-click menu) ---
  function groupSelectedIntoFolder(){
    if(!selected || selected.size < 2) return;

    pushHistory();

    const ids = Array.from(selected);

    // If any selected card is already in a folder, group INTO that folder (merge behavior).
    let gid = null;
    for(const id of ids){
      const c = getCardById(id);
      if(c && c.groupId){ gid = c.groupId; break; }
    }
    if(!gid) gid = uid();

    // Apply groupId
    for(const id of ids){
      const c = getCardById(id);
      if(!c || c.locked) continue;
      const prev = c.groupId;
      c.groupId = gid;
      if(prev && prev !== gid){
        try{ mergeGroups(gid, prev); }catch(_){}
      }
    }
    // Preserve current layout when creating/merging folders (no auto re-pack)
    try{ dissolveGroupIfTiny(gid); }catch(_){}

    // Save should never break UI
    try{ save(); }catch(_){}
    render();
  }

  if(ctxGroup){
    // Use pointerdown to avoid "click" being eaten by outside handlers on some browsers.
    const onGroup = (e) => {
      try{ e.preventDefault(); e.stopPropagation(); }catch(_){}
      groupSelectedIntoFolder();
      hideCtx();
    };
    ctxGroup.addEventListener("pointerdown", onGroup);
    ctxGroup.addEventListener("click", (e)=>{ try{ e.preventDefault(); e.stopPropagation(); }catch(_){}
      groupSelectedIntoFolder(); hideCtx();
    });
  }

if(ctxUngroup){
    const onUngroup = (e)=>{
      try{ e.preventDefault(); e.stopPropagation(); }catch(_){}
      if(selected.size){
        pushHistory();
        ungroupIds(Array.from(selected));
        save();
        render();
      }
      hideCtx();
    };
    ctxUngroup.addEventListener("pointerdown", onUngroup);
    ctxUngroup.addEventListener("click", onUngroup);
  }

  
  function resetCardToBase(cardId){
    const c = getCardById(cardId);
    if(!c) return;
    // Preserve position + grouping + locked state. Reset content + styling to the same defaults as a new header card.
    const keep = { x: c.x, y: c.y, groupId: c.groupId ?? null, locked: !!c.locked };

    // Base "new card" defaults
    c.x = keep.x;
    c.y = keep.y;
    c.groupId = keep.groupId;
    c.locked = keep.locked;

    c.preset = "neutral";
    c.customColor = null;
    c.noHeader = false;
    c.struck = false;

    c.type = "text";
    c.w = null;
    c.h = null;
    c.imgId = null;

    c.title = "BEAT";
    c.body = "";
  }

  if(ctxReset){
    const onReset = () => {
      const ids = (ctxSelectionSnapshot && ctxSelectionSnapshot.length) ? ctxSelectionSnapshot.slice() : Array.from(selected || []);
      const targetIds = (ids.length > 0) ? ids : (ctxTargetCardId ? [ctxTargetCardId] : (selectedId ? [selectedId] : []));
      if(targetIds.length === 0){ hideCtx(); return; }

      pushHistory();
      for(const id of targetIds){
        const c = getCardById(id);
        if(!c) continue;
        if(c.locked) continue;
        resetCardToBase(id);
      }
      save();
      render();
      hideCtx();
    };
    ctxReset.addEventListener("pointerdown", onReset);
    ctxReset.addEventListener("click", onReset);
  }

ctxDelete.addEventListener("click", () => {
    // Use the selection snapshot captured when the menu opened.
    const ids = (ctxSelectionSnapshot && ctxSelectionSnapshot.length) ? ctxSelectionSnapshot.slice() : Array.from(selected || []);
    const targetIds = (ids.length > 0) ? ids : (ctxTargetCardId ? [ctxTargetCardId] : (selectedId ? [selectedId] : []));
    if(targetIds.length === 0){ hideCtx(); return; }

    // Delete all in selection if multi; otherwise delete the target.
    if(targetIds.length > 1){
      selected = new Set(targetIds);
      selectedId = targetIds[targetIds.length-1] || selectedId;
      deleteSelected();
      hideCtx();
      return;
    }

    const one = targetIds[0];
    if(one){
      selected.clear();
      selected.add(one);
      selectedId = one;
      deleteSelected();
    }
    hideCtx();
  });


  window.addEventListener("mousedown", (e) => {
    if(ctxMenu.style.display !== "block") return;
    const r = ctxMenu.getBoundingClientRect();
    const inside = e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom;
    if(!inside) hideCtx();
  });

  /* ---------- Dragging / panning / snapping ---------- */
viewport.addEventListener("mousedown", (e) => {
    // Pan: middle-mouse drag OR Shift + left-drag (same behavior / code path)
    if(e.button === 1 || (e.button === 0 && e.shiftKey)){
      e.preventDefault();

      // If an editor/modal is open, ignore
      const hitModal = e.target.closest && e.target.closest(".modal");
      if(hitModal) return;

      hideCtx();
      hideColorPopover();

      isPanning = true;
      document.body.classList.add("bbShiftPanning");
      panStart.x = e.clientX;
      panStart.y = e.clientY;
      viewStart.x = view.x;
      viewStart.y = view.y;
      return;
    }


    // Left mouse only below
    if(e.button !== 0) return;
    // Folder drag: click empty space inside a folder halo to move the whole folder.
    try{
      const hitCard0 = e.target.closest && e.target.closest(".card");
      const hitModal0 = e.target.closest && e.target.closest(".modal");
      if(!hitCard0 && !hitModal0){
        const pW = worldFromClient(e.clientX, e.clientY);
        const gid = getGroupAtWorldPoint(pW.x, pW.y);
        if(gid){
          hideCtx();
          hideColorPopover();
          activeFolderId = gid;
          startFolderDrag(gid, e.clientX, e.clientY);
          e.preventDefault();
          e.stopPropagation();
          return;
        }
      }
    }catch(_){}

    // (Pan is handled above via Shift+drag / middle-mouse.)
    // If we're here, allow normal background interactions (marquee selection, etc.).
    return;

    // Background interactions (marquee select / click-to-clear) are handled by the overlay.
    return;
  });

/* ---------- Touch / mobile basics (pan + pinch zoom) ---------- */
let __touchPanActive = false;
let __touchPinchActive = false;
let __touchPanStart = { x:0, y:0 };
let __touchViewStart = { x:0, y:0, scale:1 };
let __pinchStartDist = 0;
let __pinchStartCenter = { x:0, y:0 };
let __pinchWorldBefore = { x:0, y:0 };

function __touchDist(t1, t2){
  const dx = (t2.clientX - t1.clientX);
  const dy = (t2.clientY - t1.clientY);
  return Math.hypot(dx, dy);
}
function __touchCenter(t1, t2){
  return { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
}

viewport.addEventListener("touchstart", (e)=>{
  if(!e.touches || e.touches.length === 0) return;

  // Don't interfere with modal interactions
  const hitModal = e.target && e.target.closest && e.target.closest(".modal");
  if(hitModal) return;

  hideCtx();
  hideColorPopover();

  if(e.touches.length === 2){
    // Pinch start
    __touchPinchActive = true;
    __touchPanActive = false;

    const t1 = e.touches[0], t2 = e.touches[1];
    __pinchStartDist = __touchDist(t1, t2);
    __touchViewStart = { x: view.x, y: view.y, scale: view.scale };

    const c = __touchCenter(t1, t2);
    __pinchStartCenter = c;
    __pinchWorldBefore = worldFromClient(c.x, c.y);

    e.preventDefault();
    return;
  }

  if(e.touches.length === 1){
    // One-finger pan only when touching background (not a card)
    const hitCard = e.target && e.target.closest && e.target.closest(".card");
    if(hitCard) return;

    __touchPanActive = true;
    __touchPinchActive = false;
    __touchPanStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
    __touchViewStart = { x: view.x, y: view.y, scale: view.scale };
    e.preventDefault();
    return;
  }
}, { passive: false });

viewport.addEventListener("touchmove", (e)=>{
  if(!e.touches || e.touches.length === 0) return;

  // Pinch zoom
  if(__touchPinchActive && e.touches.length >= 2){
    const t1 = e.touches[0], t2 = e.touches[1];
    const dist = __touchDist(t1, t2);
    const factor = (__pinchStartDist > 0) ? (dist / __pinchStartDist) : 1;
    const nextScale = clamp(__touchViewStart.scale * factor, 0.25, 3.0);

    // Keep the world point under the pinch center stable
    const c = __touchCenter(t1, t2);

    view.x = __touchViewStart.x;
    view.y = __touchViewStart.y;
    view.scale = nextScale;

    const after = worldFromClient(c.x, c.y);
    view.x += (after.x - __pinchWorldBefore.x) * view.scale;
    view.y += (after.y - __pinchWorldBefore.y) * view.scale;

    applyView();
    e.preventDefault();
    return;
  }

  // One-finger pan
  if(__touchPanActive && e.touches.length === 1){
    const t = e.touches[0];
    view.x = __touchViewStart.x + (t.clientX - __touchPanStart.x);
    view.y = __touchViewStart.y + (t.clientY - __touchPanStart.y);
    applyView();
    e.preventDefault();
    return;
  }
}, { passive: false });

viewport.addEventListener("touchend", (e)=>{
  if(__touchPinchActive && (!e.touches || e.touches.length < 2)){
    __touchPinchActive = false;
    save();
  }
  if(__touchPanActive && (!e.touches || e.touches.length === 0)){
    __touchPanActive = false;
    save();
  }
}, { passive: true });

  // Prevent middle-click auto-scroll / focus oddities
  viewport.addEventListener("auxclick", (e) => {
    if(e.button === 1) e.preventDefault();
  });

  // Double-click empty space inside a folder to open folder settings.
  // Works at any zoom because we hit-test in world-space.
  viewport.addEventListener("dblclick", (e)=>{
    try{
      // Ignore dblclicks on cards or modals (cards have their own editor)
      const hitCard = e.target && e.target.closest && e.target.closest(".card");
      const hitModal = e.target && e.target.closest && e.target.closest(".modal");
      if(hitCard || hitModal) return;

      const pW = worldFromClient(e.clientX, e.clientY);
      const gid = getGroupAtWorldPoint(pW.x, pW.y);
      if(!gid) return;

      e.preventDefault();
      e.stopPropagation();
      hideCtx();
      hideColorPopover();
      activeFolderId = gid;
      openFolderOverlay(gid);
    }catch(_){ }
  });

  viewport.addEventListener("contextmenu", (e) => {
    // Allow the browser's native context menu inside editable text fields
    // (spellcheck, copy/paste, etc.).
    try{
      const t = e.target;
      const isEditable = t && t.closest && (
        t.closest('[contenteditable="true"]') ||
        t.closest("input, textarea, select") ||
        t.closest(".editorModal")
      );
      if(isEditable){
        return; // native context menu
      }
    }catch(_){}

    e.preventDefault();
    // Right-click background menu
    openCtx(e.clientX, e.clientY, null);
  });

  function snapToGrid(n){ return Math.round(n / GRID) * GRID; }

  function snapAlign(x, y, cardId){
    let sx = snapToGrid(x);
    let sy = snapToGrid(y);

    // Use CSS vars for dimensions
    const w = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--cardW")) || 335;
    const h = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--cardH")) || 220;

    const my = { left:sx, right:sx+w, cx:sx+w/2, top:sy, bottom:sy+h, cy:sy+h/2 };

    let bestX = sx, bestY = sy;
    let bestDX = SNAP_DIST + 1, bestDY = SNAP_DIST + 1;

    for(const c of cards){
      if(c.id === cardId) continue;
      const ox = c.x, oy = c.y;

      const other = { left:ox, right:ox+w, cx:ox+w/2, top:oy, bottom:oy+h, cy:oy+h/2 };

      const xCands = [
        { d: Math.abs(my.left - other.left), set: other.left },
        { d: Math.abs(my.left - other.right), set: other.right },
        { d: Math.abs(my.cx - other.cx), set: other.cx - w/2 },
      ];
      for(const cand of xCands){
        if(cand.d < bestDX && cand.d <= SNAP_DIST){ bestDX = cand.d; bestX = cand.set; }
      }

      const yCands = [
        { d: Math.abs(my.top - other.top), set: other.top },
        { d: Math.abs(my.top - other.bottom), set: other.bottom },
        { d: Math.abs(my.cy - other.cy), set: other.cy - h/2 },
      ];
      for(const cand of yCands){
        if(cand.d < bestDY && cand.d <= SNAP_DIST){ bestDY = cand.d; bestY = cand.set; }
      }
    }
    return { x: bestX, y: bestY };
  }

  function _sizeForSnap(card){
    const base = getBaseCardDims();
    const w = (card && card.w != null) ? card.w : base.w;
    const h = (card && card.h != null) ? card.h : base.h;
    return { w, h };
  }


  function snapResizeWH(card, wantW, wantH){
    // Snap the moving edges (right/bottom) and centers (cx/cy),
    // keeping top-left anchored at card.x/card.y.
    const x0 = card.x, y0 = card.y;
    let w = wantW, h = wantH;

    const myRight = x0 + w;
    const myBottom = y0 + h;
    const myCx = x0 + w/2;
    const myCy = y0 + h/2;

    // Best deltas for each target
    let bestRight = { d: SNAP_DIST + 1, delta: 0 };
    let bestCx    = { d: SNAP_DIST + 1, delta: 0 }; // delta in center-space
    let bestBottom= { d: SNAP_DIST + 1, delta: 0 };
    let bestCy    = { d: SNAP_DIST + 1, delta: 0 };

    // Grid candidates
    const gridRight  = snapToGrid(myRight);
    const gridBottom = snapToGrid(myBottom);
    const gridCx     = snapToGrid(myCx);
    const gridCy     = snapToGrid(myCy);

    bestRight = { d: Math.abs(myRight - gridRight),  delta: (gridRight - myRight) };
    bestBottom= { d: Math.abs(myBottom - gridBottom),delta: (gridBottom - myBottom) };
    bestCx    = { d: Math.abs(myCx - gridCx),        delta: (gridCx - myCx) };
    bestCy    = { d: Math.abs(myCy - gridCy),        delta: (gridCy - myCy) };

    for(const other of cards){
      if(!other || other.id === card.id) continue;

      const sameScope = (card.groupId ? (other.groupId === card.groupId) : (!other.groupId));
      if(!sameScope) continue;

      const od = _sizeForSnap(other);
      const oLeft = other.x;
      const oRight = other.x + od.w;
      const oCx = other.x + od.w/2;
      const oTop = other.y;
      const oBottom = other.y + od.h;
      const oCy = other.y + od.h/2;

      // Right edge snaps
      const rCands = [oLeft, oRight, oCx];
      for(const tx of rCands){
        const d = Math.abs(myRight - tx);
        if(d < bestRight.d){ bestRight = { d, delta: (tx - myRight) }; }
      }

      // Center X snaps
      const cxCands = [oCx, oLeft, oRight];
      for(const tx of cxCands){
        const d = Math.abs(myCx - tx);
        if(d < bestCx.d){ bestCx = { d, delta: (tx - myCx) }; }
      }

      // Bottom edge snaps
      const bCands = [oTop, oBottom, oCy];
      for(const ty of bCands){
        const d = Math.abs(myBottom - ty);
        if(d < bestBottom.d){ bestBottom = { d, delta: (ty - myBottom) }; }
      }

      // Center Y snaps
      const cyCands = [oCy, oTop, oBottom];
      for(const ty of cyCands){
        const d = Math.abs(myCy - ty);
        if(d < bestCy.d){ bestCy = { d, delta: (ty - myCy) }; }
      }
    }

    // Apply best snaps (prefer whichever is closer per axis)
    let snapW = w;
    let snapH = h;

    if(bestRight.d <= SNAP_DIST || bestCx.d <= SNAP_DIST){
      if(bestRight.d <= bestCx.d){
        snapW = w + bestRight.delta;
      }else{
        // cx = x0 + w/2 => snapping cx by delta means w += 2*delta
        snapW = w + (bestCx.delta * 2);
      }
    }

    if(bestBottom.d <= SNAP_DIST || bestCy.d <= SNAP_DIST){
      if(bestBottom.d <= bestCy.d){
        snapH = h + bestBottom.delta;
      }else{
        snapH = h + (bestCy.delta * 2);
      }
    }

    const minW = 180, minH = 140;
    const maxW = 1400, maxH = 1100;
    snapW = clamp(Math.round(snapW), minW, maxW);
    snapH = clamp(Math.round(snapH), minH, maxH);

    // Guide positions in world-space (for screen-space overlays)
    let snapLineX = null;
    let snapLineY = null;
    let snappedX = false;
    let snappedY = false;

    if(bestRight.d <= SNAP_DIST || bestCx.d <= SNAP_DIST){
      if(bestRight.d <= bestCx.d){
        snapLineX = myRight + bestRight.delta;
        snappedX = true;
      }else{
        snapLineX = myCx + bestCx.delta;
        snappedX = true;
      }
    }
    if(bestBottom.d <= SNAP_DIST || bestCy.d <= SNAP_DIST){
      if(bestBottom.d <= bestCy.d){
        snapLineY = myBottom + bestBottom.delta;
        snappedY = true;
      }else{
        snapLineY = myCy + bestCy.delta;
        snappedY = true;
      }
    }

    const snapActive = (snappedX || snappedY);

    return { w: snapW, h: snapH, snapLineX, snapLineY, snapActive };

  }



  window.addEventListener("mousemove", (e) => {
    window.__lastMouseX = e.clientX;
    window.__lastMouseY = e.clientY;
    if(drag.active){
      const p = worldFromClient(e.clientX, e.clientY);

      // If we started a drag on a grouped card, decide whether this is a folder-move (brief hold) or a pull-out (immediate move)
      if(drag.pendingGroupDrag){
        const pd = drag.pendingGroupDrag;
        const mdx = Math.abs(e.clientX - pd.startClientX);
        const mdy = Math.abs(e.clientY - pd.startClientY);

        // If the user moves immediately, cancel the pending folder-move and treat as a single-card drag.
        if(mdx > 6 || mdy > 6){
          if(pd.timer){ clearTimeout(pd.timer); }
          drag.pendingGroupDrag = null;
        }
      }
// Push a single undo point when a drag actually moves
      if(drag.start && !drag.pushed){
        const dx0 = Math.abs(p.x - drag.start.x);
        const dy0 = Math.abs(p.y - drag.start.y);
        if(dx0 > 0.5 || dy0 > 0.5){
          pushHistory();
          drag.pushed = true;
        }
      }

      // Multi-drag: move every selected card by the same world delta
      if(drag.start && drag.starts && drag.ids && drag.ids.length){
        const dx = p.x - drag.start.x;
        const dy = p.y - drag.start.y;

        for(const id of drag.ids){
          const c = cards.find(x => x.id === id);
          const s = drag.starts.get(id);
          if(!c || !s) continue;

          let nx = s.x + dx;
          let ny = s.y + dy;

          // Optional: hold Shift while dragging to snap-align the PRIMARY card,
          // and apply the same delta to all.
          if(e.shiftKey && id === selectedId){
            const snapped = snapAlign(nx, ny, id);
            const ddx = snapped.x - nx;
            const ddy = snapped.y - ny;
            nx = snapped.x;
            ny = snapped.y;

            // apply the snap adjustment to everyone else
            for(const id2 of drag.ids){
              if(id2 === id) continue;
              const c2 = cards.find(x => x.id === id2);
              const s2 = drag.starts.get(id2);
              if(!c2 || !s2) continue;
              c2.x = Math.round(s2.x + dx + ddx);
              c2.y = Math.round(s2.y + dy + ddy);
            }
            // set primary after adjusting others
          }

          c.x = Math.round(nx);
          c.y = Math.round(ny);
        }

        // While dragging, if the cursor rests over another card briefly, arm a "group on drop" target.
        const cand = (() => {
          // Compute a union bbox for the dragged/selected cards (world coords)
          const dragIds = (drag.ids && drag.ids.length ? drag.ids : (selectedId ? [selectedId] : []));
          let dragBox = null;
          for(const id of dragIds){
            const cc = getCardById(id);
            if(!cc) continue;
            const { w, h } = getCardDimsFor(cc);
            const r = { x: cc.x, y: cc.y, r: cc.x + w, b: cc.y + h };
            if(!dragBox){
              dragBox = { x: r.x, y: r.y, r: r.r, b: r.b };
            }else{
              dragBox.x = Math.min(dragBox.x, r.x);
              dragBox.y = Math.min(dragBox.y, r.y);
              dragBox.r = Math.max(dragBox.r, r.r);
              dragBox.b = Math.max(dragBox.b, r.b);
            }
          }

          function overlapOk(a, b){
            const ix = Math.max(0, Math.min(a.r, b.r) - Math.max(a.x, b.x));
            const iy = Math.max(0, Math.min(a.b, b.b) - Math.max(a.y, b.y));
            const inter = ix * iy;
            if(inter <= 0) return false;
            const areaA = (a.r-a.x) * (a.b-a.y);
            const areaB = (b.r-b.x) * (b.b-b.y);
            const ratio = inter / Math.min(areaA, areaB);
            return ratio >= 0.18;
          }

          for(let i=cards.length-1; i>=0; i--){
            const o = cards[i];
            if(!o) continue;
            if(dragIds.includes(o.id)) continue;

            const { w, h } = getCardDimsFor(o);

            // Stricter hit test: cursor must be clearly inside the target card (avoid accidental grouping near edges)
            const inset = 10;
            if(!(p.x >= o.x + inset && p.x <= o.x + w - inset && p.y >= o.y + inset && p.y <= o.y + h - inset)){
              continue;
            }

            // Also require a meaningful overlap between the dragged cards' bbox and the target card
            if(dragBox){
              const ob = { x: o.x, y: o.y, r: o.x + w, b: o.y + h };
              if(!overlapOk(dragBox, ob)) continue;
            }

            return o.id;
          }
          return null;
        })();

        if(cand !== groupHoverCandidate){
          groupHoverCandidate = cand;
          if(groupTargetTimer){ clearTimeout(groupTargetTimer); groupTargetTimer = null; }
          groupTargetId = null;
          if(cand){
            groupTargetTimer = setTimeout(() => {
              // Arm + show "jiggle" feedback first...
              groupTargetId = cand;
              render();

              // ...then, if you're still holding over the same card, form the group seamlessly.
              setTimeout(() => {
                if(!drag.active) return;
                if(groupHoverCandidate !== cand) return;

                // Determine which cards are being dragged/selected to group into the hovered target.
                const idsToGroup = (drag.ids && drag.ids.length ? drag.ids : (selectedId ? [selectedId] : [])).slice();
                if(!idsToGroup.length) return;
                // If we're only dragging the hovered target itself, there's nothing to group.
                if(idsToGroup.every(id => id === cand)) return;

                if(!drag.pushed) { pushHistory(); drag.pushed = true; }

                // Group ALL dragged/selected cards with the hovered target (iOS-folder style)
                const targetCard = getCardById(cand);
                if(!targetCard) return;

                const existingGroup = !!(targetCard.groupId || idsToGroup.some(id => { const t = getCardById(id); return t && t.groupId; }));
                let gid = targetCard.groupId || null;
                // idsToGroup was computed above

                for(const id of idsToGroup){
                  if(id === cand) continue;
                  const cc = getCardById(id);
                  if(!cc || cc.locked) continue;

                  // If either side already has a group, merge; otherwise create a new one.
                  if(!gid){
                    gid = groupCards(cc.id, cand);
                  }else{
                    const prev = cc.groupId;
                    targetCard.groupId = gid;
                    cc.groupId = gid;
                    if(prev && prev !== gid){
                      mergeGroups(gid, prev);
                      gid = targetCard.groupId || gid;
                    }
                  }
                }
                if(!gid) return;

                // If we're dropping into an EXISTING folder, don't re-pack the whole layout.
                // Only auto-pack when creating a brand new folder from two ungrouped items.
                if(!existingGroup) layoutGroup(gid, cand);
// After grouping, keep dragging whatever you were already dragging.
// (Don't reset drag baselines here â€” that can cause the dragged cards to "detach"
// and makes you feel like you have to re-click.)
drag.ids = (drag.ids || []).filter(id => {
  const cc = getCardById(id);
  return cc && !cc.locked;
});
if(drag.starts instanceof Map){
  for(const id of Array.from(drag.starts.keys())){
    if(!drag.ids.includes(id)) drag.starts.delete(id);
  }
}
// clear jiggle state
                groupTargetId = null;
                render();
              }, GROUP_JIGGLE_MS);
            }, GROUP_HOVER_MS);
          } else {
            render();
          }
        }

        render();
      }
      return;
    }


    if(isPanning){
      view.x = viewStart.x + (e.clientX - panStart.x);
      view.y = viewStart.y + (e.clientY - panStart.y);
      applyView();
    }
  });

  window.addEventListener("mouseup", (e) => {
    if(drag.active){
      // Clear any pending grouping hover state
      if(groupTargetTimer){ clearTimeout(groupTargetTimer); groupTargetTimer = null; }
      groupTargetId = null;

      // If the drag moved at least a few pixels, suppress the background click that follows
      try{
        if(drag.start){
          const end = worldFromClient(e?.clientX ?? 0, e?.clientY ?? 0);
          const dx = Math.abs(end.x - drag.start.x);
          const dy = Math.abs(end.y - drag.start.y);
          if(dx > 2 || dy > 2) suppressNextClick = true;
        }
      }catch(_){}
      
// Dragging a card should NEVER auto-ungroup.
// Ungrouping is an explicit action via the context menu.
drag.active = false;
      drag.ids = [];
      drag.start = null;
      drag.starts = null;
      save();
    }
    if(isPanning){
      isPanning = false;
      document.body.classList.remove("bbShiftPanning");
      save();
    }
  });


  /* ---------- Mobile: touch gestures (two-finger pan + pinch zoom) ---------- */
  const _touchPointers = new Map(); // pointerId -> {x,y}
  let _touchGesture = null; // { startWorld:{x,y}, startView:{x,y,scale}, startCount, longPressTimer, down:{x,y}, moved }

  function _isTouch(e){ return e && e.pointerType === "touch"; }
  function _centroid(){
    let sx=0, sy=0, n=0;
    _touchPointers.forEach(p=>{ sx+=p.x; sy+=p.y; n++; });
    return n? { x:sx/n, y:sy/n, n } : { x:0, y:0, n:0 };
  }
  function _distance2(){
    const pts = Array.from(_touchPointers.values());
    if(pts.length < 2) return 0;
    const a=pts[0], b=pts[1];
    const dx=a.x-b.x, dy=a.y-b.y;
    return Math.hypot(dx,dy);
  }
  function _cancelLongPress(){
    if(_touchGesture && _touchGesture.longPressTimer){
      clearTimeout(_touchGesture.longPressTimer);
      _touchGesture.longPressTimer = null;
    }
  }
  function _maybeStartLongPress(e){
    // Only for single-touch, and only on non-interactive surface (avoid menus / inputs)
    const ae = document.activeElement;
    const tag = ae && ae.tagName ? ae.tagName.toLowerCase() : "";
    if(tag === "input" || tag === "textarea" || tag === "select") return;

    const hitMenu = e.target.closest && e.target.closest(".menu, .menuDrop, .modal, .ctx");
    if(hitMenu) return;

    if(!_touchGesture) _touchGesture = { moved:false };
    const downX = e.clientX, downY = e.clientY;
    _touchGesture.down = { x: downX, y: downY };
    _touchGesture.moved = false;

    _touchGesture.longPressTimer = setTimeout(()=>{
      // If user didn't move much and still single touch, open context menu.
      if(!_touchGesture || _touchGesture.moved) return;
      if(_touchPointers.size !== 1) return;

      const hitCard = e.target.closest && e.target.closest(".card");
      const cardId = hitCard ? (hitCard.dataset && hitCard.dataset.id) : null;
      openCtx(downX, downY, cardId);
    }, 520);
  }

  // Touch -> pointer events on viewport
  viewport.addEventListener("pointerdown", (e) => {
    if(!_isTouch(e)) return;

    // prevent page scroll during board interaction
    document.body.classList.add("bbNoScroll");

    _touchPointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    try{ viewport.setPointerCapture(e.pointerId); }catch(_){}

    if(_touchPointers.size === 1){
      _maybeStartLongPress(e);
      return;
    }

    // Two-finger gesture starts: cancel long-press and any mouse-style panning
    _cancelLongPress();
    isPanning = false;

    const c = _centroid();
    const startWorld = worldFromClient(c.x, c.y);
    _touchGesture = {
      startWorld,
      startView: { x: view.x, y: view.y, scale: view.scale },
      startDist: _distance2(),
      startCount: _touchPointers.size,
      moved: true
    };
  }, { passive:false });

  viewport.addEventListener("pointermove", (e) => {
    if(!_isTouch(e)) return;
    if(!_touchPointers.has(e.pointerId)) return;

    _touchPointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    // cancel long press on movement
    if(_touchGesture && _touchGesture.down){
      const dx = e.clientX - _touchGesture.down.x;
      const dy = e.clientY - _touchGesture.down.y;
      if(Math.hypot(dx,dy) > 8){
        _touchGesture.moved = true;
        _cancelLongPress();
      }
    }

    // Only handle pinch/pan when two fingers are down
    if(_touchPointers.size >= 2 && _touchGesture && _touchGesture.startWorld){
      e.preventDefault();

      const rect = viewport.getBoundingClientRect();
      const c = _centroid();
      const dist = _distance2();
      const base = _touchGesture.startView;

      let newScale = base.scale;
      if(_touchGesture.startDist > 0 && dist > 0){
        newScale = clamp(base.scale * (dist / _touchGesture.startDist), 0.25, 3.0);
      }
      view.scale = newScale;

      // Keep the same world point under the centroid while it moves (pan + pinch together)
      view.x = (c.x - rect.left) - (_touchGesture.startWorld.x * view.scale);
      view.y = (c.y - rect.top ) - (_touchGesture.startWorld.y * view.scale);

      applyView();
      return;
    }
  }, { passive:false });

  function _endTouchPointer(pid){
    _touchPointers.delete(pid);
    if(_touchPointers.size < 2){
      // End gesture
      if(_touchGesture && _touchGesture.startWorld){
        save();
      }
      _touchGesture = _touchPointers.size ? _touchGesture : null;
    }
    if(_touchPointers.size === 0){
      _cancelLongPress();
      document.body.classList.remove("bbNoScroll");
    }
  }

  viewport.addEventListener("pointerup", (e) => { if(_isTouch(e)) _endTouchPointer(e.pointerId); }, { passive:false });
  viewport.addEventListener("pointercancel", (e) => { if(_isTouch(e)) _endTouchPointer(e.pointerId); }, { passive:false });

  // Zoom with scroll wheel (no Ctrl needed)
  viewport.addEventListener("wheel", (e) => {
    e.preventDefault();

    const mouse = { x: e.clientX, y: e.clientY };
    const before = worldFromClient(mouse.x, mouse.y);

    const delta = -e.deltaY;
    const factor = delta > 0 ? 1.10 : 0.90;
    const nextScale = clamp(view.scale * factor, 0.25, 3.0);
    view.scale = nextScale;

    const after = worldFromClient(mouse.x, mouse.y);
    view.x += (after.x - before.x) * view.scale;
    view.y += (after.y - before.y) * view.scale;

    applyView();
    save();
  }, { passive: false });

// Keyboard shortcuts
  
  // Track modifier keys so Shift-snapping can be toggled mid-gesture (some browsers don't update shiftKey reliably during pointer capture)
  let __shiftDown = false;
  window.addEventListener("keydown", (e)=>{ if(e.key === "Shift") __shiftDown = true; }, { passive: true });
  window.addEventListener("keyup",   (e)=>{ if(e.key === "Shift") __shiftDown = false; }, { passive: true });
  window.addEventListener("blur", ()=>{ __shiftDown = false; }, { passive: true });

window.addEventListener("keydown", (e) => {
    if(modalOverlay.style.display === "flex") return;

    const isMac = /Mac|iPhone|iPad|iPod/.test(navigator.platform);
    const cmd = isMac ? e.metaKey : e.ctrlKey;
    if(cmd){
      const k = e.key.toLowerCase();
      if(k === "f"){
        e.preventDefault();
        openFindOverlay(findInput ? findInput.value : "");
        return;
      }
      if(k === "a"){
        e.preventDefault();
        selectAllCards();
        return;
      }
      if(k === "c"){
        e.preventDefault();
        copyCards();
        return;
      }
      if(k === "x"){
        e.preventDefault();
        cutCards();
        return;
      }
      if(k === "v"){
        e.preventDefault();
        pasteCards();
        return;
      }
    }

    if((e.key === "Delete" || e.key === "Backspace") && selectedId){
      e.preventDefault();
      deleteSelected();
      return;
    }
    if(e.key.toLowerCase() === "n"){
      const center = worldFromClient(window.innerWidth/2, window.innerHeight/2);
      // N = header card (Shift+N kept as alternate for blank)
      createCardAt(center.x - 170, center.y - 75, e.shiftKey ? { blank: true } : {});
      return;
    }
    if(e.key.toLowerCase() === "b"){
      const center = worldFromClient(window.innerWidth/2, window.innerHeight/2);
      createCardAt(center.x - 170, center.y - 75, { blank: true });
      return;
    }
  });

  // Center view around the extents of all cards (not a fixed origin).
  function centerView(){
    if(!viewport) return;
    if(!cards || cards.length === 0){
      // Fallback: sane default if board is empty
      view = { x: 120, y: 100, scale: 1 };
      applyView();
      save();
      return;
    }

    let minX = Infinity, minY = Infinity, maxR = -Infinity, maxB = -Infinity;
    for(const c of cards){
      const r = (typeof rectForCard === "function") ? rectForCard(c) : { x:c.x||0, y:c.y||0, r:(c.x||0)+340, b:(c.y||0)+150 };
      if(r.x < minX) minX = r.x;
      if(r.y < minY) minY = r.y;
      if(r.r > maxR) maxR = r.r;
      if(r.b > maxB) maxB = r.b;
    }

    const cx = (minX + maxR) / 2;
    const cy = (minY + maxB) / 2;

    const vr = viewport.getBoundingClientRect();
    // Keep current zoom; just pan to center cards in the viewport.
    view.x = (vr.width / 2) - (cx * view.scale);
    view.y = (vr.height / 2) - (cy * view.scale);

    applyView();
    save();
  }


  // Buttons
  btnCenter.onclick = () => {
    centerView();
  };

  btnExport.onclick = () => {
    hideCtx(); hideColorPopover();
    const json = JSON.stringify({ view, cards }, null, 2);
    // quick export via prompt modal (simple)
    const w = window.open("", "_blank");
    if(!w){ alert("Popup blocked. Use the clipboard export in a different browser, or allow popups."); return; }
    w.document.write(`<pre style="white-space:pre-wrap;word-break:break-word;font-family:ui-monospace,monospace;padding:16px;background:#0f1115;color:#fff;">${escapeHtml(json)}</pre>`);
  };

  btnImport.onclick = () => {
    hideCtx(); hideColorPopover();
    const txt = prompt("Paste Beat Board JSON to import (this will replace the current board):");
    if(!txt) return;
    try{
      const parsed = JSON.parse(txt);
      if(!parsed || !Array.isArray(parsed.cards) || !parsed.view) throw new Error("Invalid format.");
      view = parsed.view;
      cards = parsed.cards;
      cards.forEach(c => {
        if(!("preset" in c)) c.preset = c.color || "neutral";
        if(!("customColor" in c)) c.customColor = null;
        delete c.time;
      });
      save();
      render();
    }catch(err){
      alert("Import failed:\n" + err.message);
    }
  };

  btnClear.onclick = () => {
    const ok = confirm("Reset the board? This clears all cards.");
    if(!ok) return;
    cards = [];
    selected.clear();
    selectedId = null;
    view = { x: 120, y: 100, scale: 1 };
    save();
    render();
  };

  // Initial load
  if(!load()){
    const gapX = 360, gapY = 200;

    // Center the default 15-beat seed on the board (board is 6000x4000)
    const { w: _cw, h: _ch } = getCardDims();
    const layoutColsTop = 6;
    const layoutRows = 3;
    const layoutW = (layoutColsTop - 1) * gapX + _cw;
    const layoutH = (layoutRows - 1) * gapY + _ch;
    const startX = Math.round((6000/2) - (layoutW/2));
    const startY = Math.round((4000/2) - (layoutH/2));

    const seed = [
      { title:"1. PROLOGUE", preset:"act1",
        body:"" },
      { title:"2. OPENING IMAGE", preset:"act1",
        body:"" },
      { title:"3. THEME STATED", preset:"act1",
        body:"" },
      { title:"4. SETUP", preset:"act1",
        body:"" },
      { title:"5. INCITING INCIDENT", preset:"act1",
        body:"" },
      { title:"6. DEBATE - REFUSAL OF CALL", preset:"act1",
        body:"" },

      { title:"7. BREAK INTO ACT II - POINT OF NO RETURN", preset:"act2",
        body:"" },
      { title:"8. FUN AND GAMES (THE PROMISE OF THE PREMISE)", preset:"act2",
        body:"" },
      { title:"9. MIDPOINT - POINT OF NO", preset:"act2",
        body:"" },
      { title:"10. BAD GUYS CLOSE IN", preset:"act2",
        body:"" },
      { title:"11. ALL IS LOST", preset:"act2",
        body:"" },
      { title:"12. DARK NIGHT OF THE SOUL", preset:"act2",
        body:"" },

      { title:"13. BREAK INTO ACT III - CROSSING THE LAST THRESHOLD", preset:"act3",
        body:"" },
      { title:"14. FINALE", preset:"act3",
        body:"" },
      { title:"15. FINAL IMAGE", preset:"act3",
        body:"" },
    ];

    cards = seed.map((s, i) => {
      const row = i < 6 ? 0 : i < 12 ? 1 : 2;
      const col = row === 2 ? i - 12 : (row === 1 ? i - 6 : i);
      return {
        id: uid(),
        x: startX + col * gapX,
        y: startY + row * gapY,
        preset: s.preset,
        customColor: null,
        title: s.title,
        body: s.body
      };
    });

    // Center the view on the seeded cards (so the board opens in the middle by default)
    try{
      const { w: cw, h: ch } = getCardDims();
      const minX = Math.min(...cards.map(c=>c.x));
      const minY = Math.min(...cards.map(c=>c.y));
      const maxX = Math.max(...cards.map(c=>c.x + cw));
      const maxY = Math.max(...cards.map(c=>c.y + ch));
      const cx = (minX + maxX) / 2;
      const cy = (minY + maxY) / 2;
      view.scale = 1;
      view.x = Math.round(window.innerWidth/2 - cx * view.scale);
      view.y = Math.round(window.innerHeight/2 - cy * view.scale);
      applyView();
    }catch(e){}


    save();
  }

  // --- Boot render (restore view/grid immediately) ---
  try{ updateGridClass(); }catch(_){}
  try{ applyView(); }catch(_){}
  try{ render(); }catch(_){}

  // --- Last-chance persistence on tab close / background ---
  window.addEventListener("beforeunload", () => { try{ save(true); }catch(_){} });
  document.addEventListener("visibilitychange", () => {
    if(document.hidden){ try{ save(true); }catch(_){} }
  }, { passive: true });


  // ---------- Keyboard basics ----------

  window.addEventListener("keydown", (e) => {
    if(e.defaultPrevented) return;
    if(isTypingContext()) return;

    const meta = e.metaKey || e.ctrlKey;

    // If ink mode is active, Ctrl/Cmd+Z should undo ink (not cards).
    // We handle it here (capture) so it wins over other shortcuts.
    if(penMode && meta && !e.altKey && (e.key === "z" || e.key === "Z") && !e.shiftKey){
      // Prevent double-firing from multiple handlers / key repeat
      if(e.repeat){ e.preventDefault(); return; }
      const __now = (window.performance && performance.now) ? performance.now() : Date.now();
      if(window.__lastInkUndoKeyTime && (__now - window.__lastInkUndoKeyTime) < 80){ e.preventDefault(); return; }
      window.__lastInkUndoKeyTime = __now;

      e.preventDefault();
      undoInk();
      return;
    }

    // Select all
    if(meta && (e.key === "a" || e.key === "A")){
      e.preventDefault();
      selected = new Set(cards.map(c => c.id));
      selectedId = cards.length ? cards[cards.length - 1].id : null;
      syncSelectionClasses();
      return;
    }

    // Undo / redo
    if(meta && (e.key === "z" || e.key === "Z")){
      e.preventDefault();
      if(e.shiftKey) redo();
      else undo();
      return;
    }
    if(meta && (e.key === "y" || e.key === "Y")){
      e.preventDefault();
      redo();
      return;
    }

    // Group / ungroup
    if(meta && !e.shiftKey && (e.key === "g" || e.key === "G")){
      if(selected.size < 2) return;
      e.preventDefault();
      groupSelectedIntoFolder();
      return;
    }
    if(meta && e.shiftKey && (e.key === "g" || e.key === "G")){
      if(selected.size === 0) return;
      e.preventDefault();
      pushHistory();
      ungroupIds(Array.from(selected));
      save();
      render();
      return;
    }

    // Delete selected
    if(e.key === "Backspace" || e.key === "Delete"){
      if(selected.size === 0) return;
      e.preventDefault();
      deleteSelected();
      return;
    }
  }, { capture: true });

  render();
})();


  // Cursor cue for SHIFT+drag panning
  window.addEventListener("keydown", (e)=>{
    if(e.key === "Shift") document.body.classList.add("bbShiftPan");
  });
  window.addEventListener("keyup", (e)=>{
    if(e.key === "Shift"){
      document.body.classList.remove("bbShiftPan");
      document.body.classList.remove("bbShiftPanning");
    }
  });



// =====================================================
// Box select (desktop-style) using a top-level overlay
// - Drag on empty background to select multiple cards
// - SHIFT+drag pans (existing)
// - CTRL/CMD while dragging = additive
//
// This overlay is appended to <html> and styled with !important
// to avoid stacking-context / transform issues.
// =====================================================
(function(){
  const viewport = document.getElementById("viewport");
  const board = document.getElementById("board");
  if(!viewport || !board) return;

  const bb = window.__BB;
  if(!bb) return;

  // Create overlay on <html> so it stays above everything
  let ov = document.getElementById("bbMarqueeOverlay");
  if(!ov){
    ov = document.createElement("div");
    ov.id = "bbMarqueeOverlay";
    document.documentElement.appendChild(ov);
  }

  // Apply base styles with !important
  const imp = (k,v)=> ov.style.setProperty(k, v, "important");
  imp("position","fixed");
  imp("z-index","2147483647");
  imp("border","3px solid rgba(255,255,255,0.75)");
  imp("background","rgba(255,255,255,0.16)");
  imp("border-radius","12px");
  imp("display","none");
  imp("pointer-events","none");
  imp("left","0px");
  imp("top","0px");
  imp("width","0px");
  imp("height","0px");

  let selecting = false;
  let start = {x:0,y:0};
  let additive = false;
  let didDrag = false;

  function sync(){ bb.syncSelectionClasses(); }
  function clear(){ bb.clearSelection(); }
  function rect(a,b){
    const left = Math.min(a.x,b.x);
    const top = Math.min(a.y,b.y);
    const right = Math.max(a.x,b.x);
    const bottom = Math.max(a.y,b.y);
    return {left, top, right, bottom, w:right-left, h:bottom-top};
  }
  function show(r){
    imp("display","block");
    imp("left", r.left + "px");
    imp("top", r.top + "px");
    imp("width", r.w + "px");
    imp("height", r.h + "px");
  }
  function hide(){ imp("display","none"); }

  function intersects(r,b){
    return !(b.left > r.right || b.right < r.left || b.top > r.bottom || b.bottom < r.top);
  }

  function compute(r){
    const cur = bb.getSelected();
    const next = new Set(additive ? [...cur] : []);
    board.querySelectorAll(".card").forEach(el=>{
      const b = el.getBoundingClientRect();
      const bbx = {left:b.left, top:b.top, right:b.right, bottom:b.bottom};
      if(intersects(r, bbx)) next.add(el.dataset.id);
    });
    bb.setSelected(next);

    // Keep a sensible primary selection for UI/keyboard actions
    const curId = bb.getSelectedId();
    if(next.size === 0){
      bb.setSelectedId(null);
    } else if(!curId || !next.has(curId)){
      bb.setSelectedId(Array.from(next).at(-1));
    }
  }

  function inViewportXY(x,y){
    const vr = viewport.getBoundingClientRect();
    return x >= vr.left && x <= vr.right && y >= vr.top && y <= vr.bottom;
  }

  window.addEventListener("mousedown", (e)=>{
    if(e.button !== 0) return;
    if(e.shiftKey) return; // Shift+drag is pan
    if(!inViewportXY(e.clientX, e.clientY)) return;

    // IMPORTANT: never start marquee selection when interacting with UI overlays
    // (e.g. ink panel sliders/buttons). This listener runs in CAPTURE phase.
    const hitUI = e.target && e.target.closest && (
      e.target.closest("#inkPanel") ||
      e.target.closest(".menubar") ||
      e.target.closest(".menuDropdown") ||
      e.target.closest(".menuBtn") ||
      e.target.closest(".ctx") ||
      e.target.closest(".topbar")
    );
    if(hitUI) return;

    const hitCard = e.target.closest && e.target.closest(".card");
    const hitModal = e.target.closest && e.target.closest(".modal");
    if(hitCard || hitModal) return;

    // Let explicit folder halo/frame elements handle their own drags.
    // (This mousedown handler runs in CAPTURE phase; if we don't bail out here,
    // it will swallow the event and the halo will never be draggable.)
    const hitHalo = e.target.closest && e.target.closest(".groupHalo, .groupFramePart");
    if(hitHalo) return;

    // If you click empty space inside a folder halo, drag the whole folder instead of starting a selection box.
    try{
      const pW = bb.worldFromClient(e.clientX, e.clientY);
      const gid = bb.getGroupAtWorldPoint(pW.x, pW.y);
      if(gid){
        bb.activeFolderId = gid;
          startFolderDrag(gid, e.clientX, e.clientY);
        // Prevent the selection rectangle from starting
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }catch(_){}

    selecting = true;
    didDrag = false;
    additive = (e.ctrlKey || e.metaKey);
    start = {x:e.clientX, y:e.clientY};
    if(!additive) clear();

    document.body.classList.add("bbSelecting");
    show({left:start.x, top:start.y, right:start.x, bottom:start.y, w:0, h:0});

    e.preventDefault();
    e.stopPropagation();
  }, true);

  window.addEventListener("mousemove", (e)=>{
    if(!selecting) return;
    const r = rect(start, {x:e.clientX, y:e.clientY});
    if(r.w >= 2 || r.h >= 2){
      didDrag = true;
      show(r);
      compute(r);
    }
    e.preventDefault();
    e.stopPropagation();
  }, true);

  window.addEventListener("mouseup", (e)=>{
    if(!selecting) return;
    selecting = false;
    document.body.classList.remove("bbSelecting");
    if(didDrag) bb.setSuppressNextClick(true);
    hide();
    e.preventDefault();
    e.stopPropagation();
  }, true);

  // Clear multi-select on background click
  viewport.addEventListener("click", (e)=>{
    // If the click is on the top menubar / dropdowns / context menu, do NOT clear selection.
    // This handler runs in CAPTURE phase, so bubbling stopPropagation is too late.
    const hitUI = e.target && e.target.closest && (
      e.target.closest(".menubar") ||
      e.target.closest(".menuDropdown") ||
      e.target.closest(".menuBtn") ||
      e.target.closest(".ctx") ||
      e.target.closest(".topbar")
    );
    if(hitUI) return;

    if(bb.getSuppressNextClick()){ bb.setSuppressNextClick(false); return; }
    const hitCard = e.target.closest && e.target.closest(".card");
    const hitModal = e.target.closest && e.target.closest(".modal");
    if(hitCard || hitModal) return;

    // If you click empty space inside a folder halo, drag the whole folder instead of starting a selection box.
    try{
      const pW = bb.worldFromClient(e.clientX, e.clientY);
      const gid = bb.getGroupAtWorldPoint(pW.x, pW.y);
      if(gid){
        bb.activeFolderId = gid;
          startFolderDrag(gid, e.clientX, e.clientY);
        // Prevent the selection rectangle from starting
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }catch(_){}
    if(e.ctrlKey || e.metaKey) return;
    clear();
  }, true);


  // Keep outlines after re-render
  const mo = new MutationObserver(()=> sync());
  mo.observe(board, {childList:true, subtree:true});
})();


  // --- Live colour updates (no Apply button needed) ---
  (function enableLiveColour(){
    try{
      let pushed = false;
      let rafId = 0;
      let pendingHex = null;

      function commitNow(hex){
        if(!editingCardId) return;
        const c = cards.find(x => x.id === editingCardId);
        if(!c) return;
        if(!pushed){
          try{ pushHistory(); }catch(e){}
          pushed = true;
        }
        c.customColor = (hex || "#c9c9c9").toLowerCase();
        try{ save(); }catch(e){}
        try{ render(); }catch(e){}
        try{ syncSelectionClasses(); }catch(e){}
      }

      function commitThrottled(hex){
        pendingHex = hex;
        if(rafId) return;
        rafId = requestAnimationFrame(() => {
          rafId = 0;
          commitNow(pendingHex);
        });
      }

      // Reset the "one history push" per editor session
      const _openEditor = openEditor;
      openEditor = function(cardId){
        pushed = false;
        return _openEditor(cardId);
      };

      // Wrap existing setEditorColorUI so ANY colour selection commits immediately
      const _setEditorColorUI = setEditorColorUI;
      setEditorColorUI = function(hex){
        _setEditorColorUI(hex);
        commitThrottled(hex);
      };

      // Also update live while dragging the custom picker (it updates editColorInput value internally)
      const panel = document.getElementById("customPickerPanel");
      const sv = document.getElementById("svCanvas");
      const hue = document.getElementById("hueSlider");
      const hexInput = document.getElementById("hexInput");

      function panelOpen(){
        return panel && panel.style.display !== "none";
      }

      if(sv){
        sv.addEventListener("mousemove", () => {
          if(panelOpen() && editColorInput) setEditorColorUI(editColorInput.value);
        }, {passive:true});
        sv.addEventListener("touchmove", () => {
          if(panelOpen() && editColorInput) setEditorColorUI(editColorInput.value);
        }, {passive:true});
      }
      if(hue){
        hue.addEventListener("input", () => {
          if(panelOpen() && editColorInput) setEditorColorUI(editColorInput.value);
        }, {passive:true});
      }
      if(hexInput){
        hexInput.addEventListener("input", () => {
          if(panelOpen() && editColorInput) setEditorColorUI(editColorInput.value);
        }, {passive:true});
      }

      // Hide Apply button visually (CSS already does it) and make it non-interactive
      const apply = document.getElementById("customPickerApply");
      if(apply){ apply.disabled = true; apply.tabIndex = -1; }
    }catch(e){
      console.warn("Live colour disabled:", e);
    }
  // Keyboard nudge: Arrow keys move selected cards
  // NOTE: Cards use contenteditable text; we still allow arrow nudging so it works reliably.
  // We only bail if the user is focused in real form fields (inputs/textareas/selects).
  




})();

</script><script id="hideViewToggleGridJS">
(function(){
  function run(){
    const btn = document.getElementById('menuToggleGrid');
    if(!btn) return;
    // Hide the button
    btn.style.display = 'none';
    // Hide separator just before it (common pattern)
    const prev = btn.previousElementSibling;
    if(prev && prev.classList && prev.classList.contains('menuSep')){
      prev.style.display = 'none';
    }
    // Hide separator just after it
    const next = btn.nextElementSibling;
    if(next && next.classList && next.classList.contains('menuSep')){
      next.style.display = 'none';
    }
  }
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', run);
  else run();
})();
</script><script id="bgPanelEventShield">
(function(){
  function shieldEvent(ev){
    const t = ev.target;
    if(!t) return;
    const panel = (t.closest && t.closest('#bgPanel')) ? t.closest('#bgPanel') : null;
    if(panel){
      // Let the control work normally, but prevent the app's global handlers from hijacking it.
      ev.stopImmediatePropagation();
      // Don't call preventDefault here; native <select> needs it.
    }
  }

  // Run in capture phase on window so we beat app-level capture listeners.
  ['pointerdown','pointerup','pointermove','mousedown','mouseup','click','dblclick','contextmenu','wheel','touchstart','touchend','touchmove'].forEach(function(type){
    window.addEventListener(type, shieldEvent, true);
  });
})();
</script>
</div><script id="bbCleanupTopLeftText">
/* Cleanup: remove any accidental stray text nodes or debug fragments rendered at top-left. */
(function(){
  function isSuspiciousText(t){
    if(!t) return false;
    const s = t.trim();
    if(!s) return false;
    // Common accidental fragments from pasted JS/template strings
    return (
      s.startsWith("=") ||
      s.includes("ev.client") ||
      s.includes("escapeHtml") ||
      s.includes("${") ||
      s.includes("vr.left") ||
      s.includes("o.x +") ||
      s.includes("r.right ||") ||
      s.includes("r.bottom ||")
    );
  }

  function run(){
    try{
      // Remove any non-whitespace direct text nodes under body (should never exist in a clean doc)
      const body = document.body;
      for(const n of Array.from(body.childNodes)){
        if(n.nodeType === Node.TEXT_NODE && n.textContent && n.textContent.trim()){
          n.remove();
        }
      }

      // Remove suspicious tiny fragments near top-left
      const all = Array.from(document.querySelectorAll("body *"));
      for(const el of all){
        // Skip legitimate UI areas
        if(el.closest(".topbar") || el.closest("#bgPanel") || el.closest("#editModal") || el.closest(".menu")) continue;

        const txt = (el.textContent || "").trim();
        if(!txt || txt.length > 200) continue;
        if(!isSuspiciousText(txt)) continue;

        const r = el.getBoundingClientRect();
        if(r.left < 80 && r.top < 80){
          el.remove();
        }
      }
    }catch(_){}
  }

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", run, { once:true });
  }else{
    run();
  }
})();
</script>
</body>
</html> cc.id === sid);
  if(!sc) continue;
  resizing.selfStartPos.set(sid, { x: sc.x, y: sc.y });
}
&gt;